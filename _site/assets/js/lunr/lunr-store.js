var store = [{
        "title": "2nd week summary",
        "excerpt":"2주차 정리      라이브러리, 프레임워크 차이            라이브러리: 기능 하나에 대해서만 제공(제한적인 용도)       프레임워크: 틀이 잡혀져 있다.(다양한 용도, 범용적) =&gt; 커스터마이징이 어러움.               AWS EC2            인스턴스 == 임대받은 컴퓨터 1대.               힙 영역            동적할당시 할당되는 메모리 영역.       자바, 파이썬은 Garbage collector가 있으므로 굳이 free 안해줘도 안쓰는 공간은 할당 해제됨.(But, file은 일일이 close해줘야함)               파이썬 자료구조            tuple                    가공된 데이터의 내용이 바뀌지 않도록 방어하기 위해 사용.           상수와 비슷한 역할을 한다.                       dic                    내부적으로는 트리 형태를 띈다.           검색시간: O(1)이지만 실제로는 트리 형태를 띄므 로 O(1)에 가까운 O(logn)이다.                       map()                    데이터 구조의 각 원소들에 동일한 함수를 적용하여 새로운 데이터를 만드는 파이썬의 기본 함수.                               JSON            JavaScript Object Notation.       서버와 통신하는 기본 데이터 양식으로 많이 사용된다.       JSONLint: JSON 형식에 맞는지 유효성을 검사해주는 사이트.       json.loads(): JSON을 읽어 dic으로 변환.       json.dumps(): dic을 읽어 JSON으로 변환.               API            여러 서비스들 간에 범용으로 쓰이는 인터페이스.       REST API: 웹서버를 이용하여 API 제공. JSON을 데이터 양식으로 활용한다.               DialogFlow: 사용자의 입력 의도를 파악하여 의도에 맞게 Flask를 동작시키는 역할.       Slack 챗봇 Flow            사용자가 문장 입력       Slack이 사용자가 입력한 문장 Flask에 전달       Flask가 DialogFlow로 전달받은 문장 전달       DialogFlow가 정의된 Intent들을 바탕으로 전달된 문장의 문맥 파악       DialogFlow의 분석 결과를 Flask로 전달       Flask에 정의된 함수 중 전달된 Intent에 맞는 함수 실행       Flask가 Slack으로 함수 실행으로 만들어진 response 전달       Slack에서 사용자로 response 전달               Git            Fetch: 저장된 것을 가져온다.       Branch: 가지치기.(Master = 최종 결과물, 배포판)       Merge: Branch 병합.       장점: 분산 작업 가능, 오프라인 개발 가능 - 중앙 서버에 접속하지 않고 각자의 환경에서 작업할 수 있으므로.       명령어                    git log: git에 수행한 행동들을 보여준다.           git reset –hard “hash값”: “hash”값의 시점으로 git을 되돌린다.(이 시점 이후에 수행된 모든 commit은 다 취소됨)           git push -f: 강제로 push.           git commit –amend: commit 메시지 수정 가능.                       topic branch: 기능 추가, 버그 수정 등 단위작업을 위한 branch.       Merge 과정                    다른 branch에서 commit           Master에서 git merge 실행           conflict 없으면 commit, conflict 있으면 어떤 부분을 반영할지 결정 후 commit           git에 push                       pull: fetch와 merge를 한번에 진행한다.            ","categories": ["CSE"],
        "tags": ["Basic"],
        "url": "keithlee94.github.io/cse/2nd-Week-Summary/",
        "teaser":null},{
        "title": "3rd week summary",
        "excerpt":"Markdown 문법 정리    1. #: 제목 쓸때 사용.  This is h1  This is h2  This is h3  This is h4  This is h5  This is h6    2. «!– –&gt;hr/&gt;: 줄바꿀때 쓴다.  —, , * * *, **, - - -: 전부 줄바꿀때 쓰는 명령어.    3. &gt;: 블럭인용문자.     This is BlockQuote            이거슨 인용문자                      이런식으로 nest 구조를 만드는것도 가능하고                                    이런식으로 인용문 안에 다른 명령어나 코드도 넣을 수 있다.                                                      List                                                   #include &lt;iostream&gt; int main(){    cout &lt;&lt; \"Hello, World!\" &lt;&lt; '\\n';    return 0; }                            4. ```: 코드 입력 가능. 입력 끝나면 다시 써서 닫으면 됨.  #include &lt;iostream&gt; int main(){     cout &lt;&lt; \"Hello, World!\" &lt;&lt; '\\n';     return 0; }    5. 숫자 리스트     첫번째   두번째   세번째   …    6. 순서 없는 리스트     First            Second                    Third                            Fourth                                    Fifth                                            Sixth                                                    Seventh                                                            …                                                                                                                                                                                                                                    7. 링크  Link: [Google][googlelink] [googlelink]https://google.com \"Go google\"  이런식으로 링크걸면됨.  Link: Google   https://keithlee94.github.io/KeithLog/  이런식으로 바로 거는방법도 있음.   https://keithlee94.github.io/KeithLog/    8. 강조  *하이라이트*, _하이라이트_: 이탤릭체 **강조**, __강조__: 볼드체 ~~취소선~~: 단어에 취소선 생김  하이라이트   중요해   강조   강조   취소선    9. 이미지 삽입  ![Alt text](/path/to/img.jpg) - url 넣어줘도 됨. 사이즈 조절 기능은 없기 때문에 &lt;img width=\"\" height=\"\"&gt;&lt;/img&gt;를 이용한다.  ","categories": ["CSE"],
        "tags": ["Markdown"],
        "url": "keithlee94.github.io/cse/3rd-Week-Summary/",
        "teaser":null},{
        "title": "2108",
        "excerpt":"백준 2108번  Link: 2108번: 통계학     문제 설명  문제에서 제시된 간단한 통계를 구하는 문제였다.   평균, 최댓값, 범위까지는 쉽게쉽게 구했는데 최빈값을 어떻게 구할지에 대해서 많이 고민했던 문제.   처음에는 8000개짜리 배열 만들고 숫자 넣을때마다 배열 값에다 1씩 더해서 빈도를 저장하려고 했는데 하다보니 아니다 싶어서 map을 사용했다.   input으로 준 숫자가 map에 없으면 (input, 1)로 초기호하고 있으면 빈도에 해당하는 1을 하나씩 더해가는 방식으로 구현했다.   최빈값을 찾기 위해 map을 한번 싹 돌았다.   조건 중에 최빈값이 여러개면 두번째로 작은 값을 최빈값으로 하라는 조건이 있었는데, 이걸 구현하기 위해 map을 한번 더 돌았다. 이 부분에 대해서는 좀 더 세련된 방법으로 보완할 수 있을 것 같은데 일단은 시간제한도 넉넉해서 그냥 한바퀴 더 도는 방법으로 구현했다.    내가 짠 코드  // // Created by Keith_Lee on 31/12/2018. // #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;math.h&gt; #include &lt;map&gt;  using namespace std;  int N;  int halfProcess(double num){     double high = ceil(num);     double low = floor(num);      if(num &gt;= (high + low) / 2){         return int(high);     }      return int(low); }  int main(){     cin &gt;&gt; N;      vector&lt;int&gt; numbers;     int sum = 0;     map&lt;int, int&gt; frequencies;      int inputNum;      for(int i=0; i&lt;N; i++){         cin &gt;&gt; inputNum;         sum += inputNum;         numbers.push_back(inputNum);         if(frequencies.find(inputNum) == frequencies.end()){             frequencies.insert(make_pair(inputNum, 1));         }         else{             frequencies.find(inputNum)-&gt;second++;         }     }      int temp = 0;     int mostFrequent;     int changeCount = 0;     for(auto iter = frequencies.begin(); iter != frequencies.end(); iter++){         if(iter-&gt;second &gt; temp){             temp = iter-&gt;second;             mostFrequent = iter-&gt;first;             changeCount++;         }     }     for(auto iter = frequencies.begin(); iter != frequencies.end(); iter++){         if(iter-&gt;second == temp &amp;&amp; iter-&gt;first != mostFrequent){             mostFrequent = iter-&gt;first;             break;         }     }      sort(numbers.begin(), numbers.end());      int average = halfProcess(double(sum) / double(N));     int center = numbers[N/2];     int range = numbers[N-1] - numbers[0];      cout &lt;&lt; average &lt;&lt; '\\n' &lt;&lt; center &lt;&lt; '\\n' &lt;&lt; mostFrequent &lt;&lt; '\\n' &lt;&lt; range &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["Realization"],
        "url": "keithlee94.github.io/algorithm/2108/",
        "teaser":null},{
        "title": "1003",
        "excerpt":"백준 1003번  Link: 1003번: 피보나치 함수     문제 설명  피보나치 함수 실행시 0과 1이 몇번이나 출력되는지 구하는 문제.   예전에 풀어본 적 있던 문제였는데 DP를 다시 공부하는 김에 새로 풀어보았다.   다른점이 있다면 예전에는 답을 찾아보고 풀었던것 같은데 이번에는 내 힘만으로 풀었다는 점.   DP를 사용해야 한다는 느낌은 왔는데 어떻게 DP 배열을 채울지가 관건이었다.   시간제한이 0.25초였지만 입력의 크기가 최대 40까지인 것을 보고, 처음부터 DP 배열을 전부 채워놓고 입력에 따라 배열의 값만 리턴해줘도 되겠다는 생각이 들었다.   이렇게 생각하고 풀어봤더니 금방 풀렸다.   이번주는 DP를 집중적으로 풀어볼 예정.    내가 짠 코드  // // Created by Keith_Lee on 01/01/2019. // #include &lt;iostream&gt;  using namespace std;  int T; int DP[41][2];  void fibonacci(int n){     if(n == 0){         DP[n][0]++;     }     else if(n == 1){         DP[n][1]++;     }     else{         DP[n][0] = DP[n-1][0] + DP[n-2][0];         DP[n][1] = DP[n-1][1] + DP[n-2][1];     } }  int main(){     for(int i=0; i&lt;41; i++){         fibonacci(i);     }      cin &gt;&gt; T;      int N;      for(int i=0; i&lt;T; i++){         cin &gt;&gt; N;         cout &lt;&lt; DP[N][0] &lt;&lt; ' ' &lt;&lt; DP[N][1] &lt;&lt; '\\n';     }      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "keithlee94.github.io/algorithm/1003/",
        "teaser":null},{
        "title": "1149",
        "excerpt":"백준 1149번  Link: 1149번: RGB 거리     문제 설명  마을의 집 갯수와 각 집을 빨강, 초록, 파랑으로 각각 칠하는데 드는 비용이 입력으로 주어졌을때 마을의 모든 집을 칠하는 최저 비용을 구하는 문제.   이웃하는 집들은 같은 색으로 칠할 수 없다는 조건도 붙었다.   작년에 답보고 풀었던 기억이 나는 문제. 이번에는 꼭 내 힘으로 풀어내리라 결심하고 풀어보았다.   우선 이웃하는 집들이 같은 색이 될수 없다는 조건을 단순화하여 앞집이랑만 다른 색이면 되지 않나? 라는 생각으로 풀었다.   틀리고 한참 고민하고서야 왜 틀렸는지 알게 되었다. 반드시 최저값만으로 구성된 조합이 존재하지 않는 경우가 있다는 것.   거꾸로도 풀어보고 어떻게든 풀어보려 애써봤는데 결국 안풀려서 예전 답을 보고 풀었다…   생각보다 매우 단순했는데, 처음 칠하는 비용을 0으로 초기화한 다음 모든 경우를 따져가며 답을 구하는 방식이었다.   예를 들면 DP[i][0]은 DP[i-1][1]과 DP[i-1][2] 중 작은 값에다가 칠하는 비용인 price[i][0]을 더하는 식.   즉 DP[i][0]은 i번째 집을 0번째 색으로 칠한다는 것을 의미한다. 당연히 앞집이랑은 색이 겹칠 일이 없다.   온갖 방법 다 생각해보다 답을 봤는데 정말 간단하게 풀려서 허무했다;;;   2시간정도 고민해봤지만 못풀겠어서 결국 포기했던 점이 아쉽지만, 이러저러한 방법을 최대한 시도해 본 점은 나름 만족스럽다.   다음에 푸는 문제들은 이런 고민끝에 끝까지 풀어낼 수 있길!!    내가 짰다가 틀린 코드  // // Created by Keith_Lee on 02/01/2019. //  #include &lt;iostream&gt;  using namespace std;  int N;  int main(){     cin &gt;&gt; N;      int price[N][3];     int DP[N][2];      for(int i=0; i&lt;N; i++){         cin &gt;&gt; price[i][0] &gt;&gt; price[i][1] &gt;&gt; price[i][2];     }      for(int i=0; i&lt;N; i++){         int min = 1001;          if(i == 0){             for(int j=0; j&lt;3; j++){                 if(min &gt; price[0][j]){                     min = price[0][j];                     DP[0][0] = min;                     DP[0][1] = j;                 }             }         }         else{             for(int j=0; j&lt;3; j++){                 if(j != DP[i-1][1]){                     if(min + price[i][j] &gt; DP[i-1][0] + price[i][j]){                         min = price[i][j];                         DP[i][0] = min + DP[i-1][0];                         DP[i][1] = j;                     }                 }             }         }     }      cout &lt;&lt; DP[N-1][0] &lt;&lt; '\\n';      return 0; }    정답 코드  // // Created by Keith_Lee on 02/01/2019. //  #include &lt;iostream&gt;  using namespace std;  int N;  int min(int a, int b){     return (a &gt; b) ? b : a; }  int main(){     cin &gt;&gt; N;      int price[N+1][3];     int DP[N+1][3];      for(int i=1; i&lt;=N; i++){         cin &gt;&gt; price[i][0] &gt;&gt; price[i][1] &gt;&gt; price[i][2];     }      price[0][0] = price[0][1] = price[0][2] = 0;     DP[0][0] = DP[0][1] = DP[0][2] = 0;      for(int i=1; i&lt;N+1; i++){         DP[i][0] = min(DP[i-1][1], DP[i-1][2]) + price[i][0];         DP[i][1] = min(DP[i-1][0], DP[i-1][2]) + price[i][1];         DP[i][2] = min(DP[i-1][0], DP[i-1][1]) + price[i][2];     }      cout &lt;&lt; min(min(DP[N][0], DP[N][1]), DP[N][2]) &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "keithlee94.github.io/algorithm/1149/",
        "teaser":null},{
        "title": "1932",
        "excerpt":"백준 1932번  Link: 1932번: 정수 삼각형     문제 설명  어제 풀었던 RGB거리와 비슷한 유형의 DP 문제.   다른점이 있다면 제한조건인데, 3가지 경우를 고려했어야 했던 RGB 거리와 달리 삼각형을 이루는 정수들의 왼쪽 대각선, 오른쪽 대각선의 2가지 경우로만 이동 가능하므로 오히려 조건은 완화되었다.   딱 문제 보고나서 ‘어 이거 어제 풀었던거랑 비슷한데’ 라는 생각으로 시작했다.   결론부터 말하면 못풀어서 답보고 이해했는데, 접근방법이 아예 잘못되었다.   조건에서 주어졌듯이 2개의 이전 결과값을 비교하고 현재 삼각형 위치의 숫자를 더하면 되는거였는데, 일단 이 조건을 무시하고 최대값만 다 찾았다가 1차로 망했다.   잘못생각했다는걸 알아차리고 다른 방법을 생각해봤는데, 이것도 틀렸다.   뭔지 대충 설명하자면 최대값을 가질때의 배열 인덱스를 따로 받아두고 이 인덱스를 기준으로 다음 최대값을 찾는 방식.   DP에 대해 완벽히 이해하고 있는건 아닌것 같다.   예전 계산 결과 가져다 쓰는 문제구나 하는 느낌은 오는데, 예전 계산 결과를 어떤식으로 저장할 것이며 어떻게 가져다 쓸것인지에 대해 생각해내는 부분이 부족한 것 같다.   문제 보고도 뭔소린가 싶었던 옛날에 비해서는 많이 나아진 편이지만 아직도 갈길이 멀다…    정답 코드  // // Created by Keith_Lee on 03/01/2019. //  #include &lt;iostream&gt; #include &lt;cstring&gt;  using namespace std;  int n; int maximum = 0;  int max(int a, int b){     return (a &gt; b) ? a : b; }  int main(){     cin &gt;&gt; n;      int DP[n+1][n+1];     int tree[n+1][n+1];      bzero(DP, sizeof(DP));     bzero(tree, sizeof(tree));      int inputNum;      for(int i=1; i&lt;=n; i++){         for(int j=1; j&lt;=i; j++){             cin &gt;&gt; inputNum;             tree[i][j] = inputNum;         }     }      for(int i=1; i&lt;=n; i++){         for(int j=1; j&lt;=i; j++){             DP[i][j] = max(DP[i-1][j-1], DP[i-1][j]) + tree[i][j];              if(maximum &lt; DP[i][j]){                 maximum = DP[i][j];             }         }     }      cout &lt;&lt; maximum &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "keithlee94.github.io/algorithm/1932/",
        "teaser":null},{
        "title": "2579",
        "excerpt":"백준 2579번  Link: 2579번: 계단 오르기     문제 설명  오늘도 DP문제다.   그리고 오늘도 내힘으로 푸는데 실패.   앞선 두문제와 비슷하면서도 달랐는데, 이번 문제를 풀수 있느냐 없느냐는 문제를 보고 조건을 이해하여 점화식을 세울 수 있는지였다.   물론 나는 점화식 못세워서 예전 코드 보고, 검색해서 그제서야 이해해서 풀었다.   점화식 세우는 방법은 우선 DP배열의 3번째까지 채우는 방법과 동일했다.   그전에 이 문제에서 DP 배열의 의미를 이해할 필요가 있었다.   DP[N]이란 N번째 계단을 밟았음을 의미한다.   이렇게 이해하고 시작해보면 DP[1]은 첫번째 계단을 밟은것이므로 score[1]이 된다.   DP[2]는 첫번째 계단, 두번째 계단을 둘 다 밟았을때와 두번째 계단만 밟았을때의 점수를 비교하여 큰 값이 곧 DP[2]의 값이 된다.   DP[3]은 조건에 의해 세 계단을 연속으로 밟을 수 없고, 한번에 최대 2개의 계단만 오를 수 있으므로 첫번째 계단과 세번째 계단을 밟았을 때, 두번째 계단과 세번째 계단을 밟았을때의 점수를 비교하여 큰 값이 DP[3]이 된다.   DP[4]를 생각해보자. DP[4]는 첫번째 계단, 세번째 계단, 네번째 계단의 점수를 더한 값과 첫번째 계단, 두번째 계단, 네번째 계단의 점수를 더한 값을 비교하여 더 큰 값이 DP[4]이다.   이는 곧 DP[1] + score[3] + score[4], DP[2] + score[4]를 비교하는 것과 같다.   이를 토대로 점화식을 세워 보면, DP[N] = max(DP[N-3] + score[N-1] + score[N], DP[N-2] + score[N])이라는 점화식을 얻을 수 있다.   이 점화식대로 풀면 풀리는 문제다.   항상 느끼는건데 점화식 세우는게 정말 너무 어렵다. 규칙은 나름대로 찾은것 같지만 뭔가 나사 하나씩은 꼭 빠져있다는 생각이 든다.   푸는방법 까먹을때쯤 한번 더 풀어봐야 할 문제인것 같다.    정답 코드  // // Created by Keith_Lee on 04/01/2019. //  #include &lt;iostream&gt;  using namespace std;  int N;  int max(int a, int b){     return (a &gt; b) ? a : b; }  int main(){     cin &gt;&gt; N;      int DP[N+1];     int score[N+1];      for(int i=1; i&lt;=N; i++){         cin &gt;&gt; score[i];     }      DP[1] = score[1];     DP[2] = max(score[1] + score[2], score[2]);     DP[3] = max(score[1] + score[3], score[2] + score[3]);      for(int i=4; i&lt;=N; i++){         DP[i] = max(DP[i-2] + score[i], DP[i-3] + score[i] + score[i-1]);     }      cout &lt;&lt; DP[N] &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "keithlee94.github.io/algorithm/2579/",
        "teaser":null},{
        "title": "4th week summary",
        "excerpt":"Java 스터디 내용 정리    Project, Package 분리 이유  프로젝트의 각 기능을 쪼개기 위해 패키지 사용.   논리적으로 따로 나눠 작업하기 위해 분리하는 경우가 대다수이다.    Java의 특징     객체지향            시스템의 기본 구성단위는 객체(Object) 이다.       객체: 일종의 부품 역할.       여러 부품들을 모아 조립하듯이 프로그램을 완성한다.           플랫폼 독립적            하드웨어, OS와 상관없이 모든 환경에서 동작 가능.       이유: JVM 위에서 작동하므로.           분산 프로그래밍: 원격 접속 가능.   멀티스레드    Java 컴파일 과정     소스코드 작성: (…).java 파일 생성.   컴파일            명령어: javac (…).java                    javac -d …: 패키지가 있을 경우 자동으로 패키지 폴더를 생성하며 컴파일.                       JVM이 인식 가능한 byte code로 번역하는 과정.       결과: Bytecode 생성 - (…).class 파일 생성.           실행            명령어: java (…)       JVM 위에서 실행됨.              C의 경우 실행파일을 다른 환경에서 실행시키면 실행 안됨.   Java의 경우 JVM이 존재하므로 다른 환경에서 실행 가능함.    Primitive Data Type  기본적인 값을 기억하는 type.   1 byte = 8 bit   char = 16 bit = 2 byte   int = 32 bit = 4 byte   float = 32 bit = 4 byte   double = 64 bit = 8 byte   long = 64 bit = 8 byte    Reference Data Type  객체의 참조값을 기억하는 type.   class, interface, 배열 등.     String: class이므로 Reference Type이다.    Literal  값 자체.   예: 3.14, 10, ‘C’, false, …   정수 리터럴 = 4바이트에 저장됨.    논리연산자     &amp;&amp; 연산자: 앞조건이 false면 뒤에 오는 조건 확인하지 않고 연산 종료.   &amp; 연산자: 앞조건이 false여도 뒤에 오는 조건을 확인한 후 연산 종료.                                   ’                       ’, ‘           ’ 연산자도 동일함.                            3항연산자  (x &gt; y) ? x : y =&gt; 실행결과: x가 y보다 크면 x, 작거나 같으면 y가 된다.    for ~ each  int sum = 0; int[] su = {24, 6, 5, 36, 36, 65, 245, 56, 3, 64};  for(int s: su){     System.out.println(s);     sum += s; }  실행결과: sum에는 su 배열의 모든 숫자를 더한 값이 저장되고, su 배열의 모든 원소가 한번씩 출력된다.   =&gt; 배열 내 모든 원소에 한번씩 접근한다.(파이썬과 유사함)    Error, Exception     Error            복구 불가능       프로그램이 비정상적으로 종료됨.           Exception            일종의 가벼운 에러       프로그램상으로 수정 가능함.       Java가 해결 방법을 알려줄 수 있음.            배열 기본값     배열의 type에 따라 다르게 배열 생성시 기본값으로 자동으로 채워진다.   int형: 0   boolean형: false   double형: 0.0   String형: null            참조형 type의 배열의 기본값은 항상 null이다.            main메소드의 args 사용법     Run Configuration 설정   Arguments -&gt; Program arguments -&gt; ${string-prompt} 설정.   new 키워드  객체를 만들때 사용하는 키워드.   method     C의 함수와 같다.   클래스 내에서 객체가 가져야 할 기능을 정의.   독립적인 기능들을 분리하여 재사용 가능하도록 하기 위해 사용.   return type, method 이름, parameter list가 반드시 있어야 한다.   method 내에 method 정의 불가능.   arraycopy()     배열 복사 함수.   System.arraycopy(소스배열, 소스배열의 시작위치, 목적배열, 목적배열의 시작위치, 길이);   작은 배열일 경우 통상적인 반복문이 더 효율적.   배열이 클때 사용시 효율적이다.   다차원 배열 길이  su = new int[5][3]; su2 = new int[3];   su.length: 5   su[0].length: 3   su2.length: 3   =&gt; 가장 첫번째 칸의 숫자가 배열의 길이.    return  문장의 실행을 그자리에서 멈춘다.    ","categories": ["Java"],
        "tags": ["Java"],
        "url": "keithlee94.github.io/java/4th-Week-Summary/",
        "teaser":null},{
        "title": "1463",
        "excerpt":"백준 1463번  Link: 1463번: 1로 만들기     문제 설명  오늘도 내힘으로 푸는데 실패.   이 문제도 직전에 풀었던 계단문제처럼 점화식이 가장 중요했다.   주어진 조건을 곧이곧대로 썼다가 답없는 상황이 나왔다.   가장 먼저 입력된 수를 3으로 나눠떨어지는지 검사하고 나눠떨어지면 3으로 나누는 것을 첫번째 조건으로 넣었고   3으로 나눠떨어지지 않으면 2로 나눠떨어지는지 검사하고 나눠떨어지면 2로 나누는 것을 두번째 조건으로 넣었다.   이 두가지를 만족하지 않을때 1을 빼는 것으로 3가지 조건을 넣었다.   도무지 어떻게 더 나갈지 모르겠어서 예전 답을 다시 찾아봤다.   예전 답도 구글링해서 답 찾아보고 풀었는데, 1년동안 실력이 전혀 안늘어난 느낌이다.   정답은 우선 1을 뺀 다음, 3으로 나눠떨어지면 3으로 나눴을때와 1을 뺐을때의 DP를 비교하는 것이었다.   3으로 나눠떨어지지 않을 경우, 2로 나눠떨어지면 2로 나눴을때와 1을 뺐을때의 DP를 비교한다.   나머지 경우는 당연히 1을 뺀 값이 DP에 들어간다.   오늘로 DP에서 5문제를 풀고있는데, 문제마다 매번 다른 개념인것 같은 느낌이다.   DP 문제 전반에 걸칠 수 있는 개념이 안잡힌 느낌. 첫술에 배부를수는 당연히 없지만 이대로 갔을때 실력이 늘긴 할지, DP에 대한 접근 방법을 제대로 파악할 수 있긴 할지 매우 걱정된다.     정답 코드  // // Created by Keith_Lee on 07/01/2019. //  #include &lt;iostream&gt; #include &lt;string.h&gt;  using namespace std;  int min(int a, int b){     return a &gt; b ? b : a; }  int main(){     int N;     int DP[1000000];      cin &gt;&gt; N;      bzero(DP, sizeof(DP));      for(int i=2; i&lt;=N; i++){         DP[i] = DP[i-1] + 1; // 기본적으로 1 빼준다.          if(i % 2 == 0){             DP[i] = min(DP[i], DP[i/2] + 1); // 2로 나눠떨어지면 2로 나눴을때와 1뺐을때를 비교한다.         }         if(i % 3 == 0){             DP[i] = min(DP[i], DP[i/3] + 1); // 3으로 나눠떨어지면 3으로 나눴을때와 1뺐을때를 비교한다.         }     }      cout &lt;&lt; DP[N] &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "keithlee94.github.io/algorithm/1463/",
        "teaser":null},{
        "title": "Swea_1289",
        "excerpt":"SWEA 1289번  Link: 1289번: 원재의 메모리 복구하기     문제 설명  무난하게 풀었던 구현 문제.   string 처리에서 살짝 헤맨것 말고는 무난하게 풀었다.     정답 코드  // // Created by Keith_Lee on 07/01/2019. //  #include &lt;iostream&gt; #include &lt;string.h&gt;  using namespace std;  int T;  int main(){     cin &gt;&gt; T;      string input = \"\";      for(int test=1; test&lt;=T; test++){         int count = 0;         string modified = \"\";          cin &gt;&gt; input;          for(int i=0; i&lt;input.length(); i++){             modified.push_back('0');         }          for(int i=0; i&lt;input.length(); i++){             if(modified[i] != input[i]){                 if(input[i] == '0'){                     for(int j=i; j&lt;modified.length(); j++){                         modified[j] = '0';                     }                 }                 else if(input[i] == '1'){                     for(int j=i; j&lt;modified.length(); j++){                         modified[j] = '1';                     }                 }                 count++;             }         }          cout &lt;&lt; '#' &lt;&lt; test &lt;&lt; ' ' &lt;&lt; count &lt;&lt; '\\n';     }      return 0; }    ","categories": ["Algorithm"],
        "tags": ["Realization"],
        "url": "keithlee94.github.io/algorithm/SWEA_1289/",
        "teaser":null},{
        "title": "Swea_3307",
        "excerpt":"SWEA 3307번  Link: 3307번: 최장 증가 부분 수열     문제 설명  완전탐색 문제인줄 알고 앞에서 썼던 DFS 써서 풀었다가 시간초과났던 문제.   조합을 하는건 맞는데, DP로 풀었어야 풀리는 문제였다.   최근에 DP 공부를 하고있었는데도 DP로 풀어야겠다는 생각은 여전히 들지 않았다.   어찌어찌 테스트케이스는 맞출수 있도록 구현했는데, 제출해보니 한개도 못맞히더라.   시험장가서 테스트케이스 맞히고도 탈락하는 경우가 왕왕 있다던데, 이런 경우인가 싶었다.   덤으로 이딴 실력으로 시험장에 가지 않았다는 점이 천만다행.   풀이에 대해 설명하자면, 우선 입력받은 숫자들 중 수열의 시작점을 for문을 통해 정한다.   그 다음, 남은 숫자들을 택해서 증가수열을 만들고 그 증가수열의 길이를 갱신하며 최대값을 구하는 문제다.   이를 위한 조건으로 2가지를 넣었다.   첫째는 다음 숫자가 반드시 수열의 시작점보다 큰 숫자일 것.   두번째는 증가수열의 길이가 증가하는 방향일 것.   이 두가지를 만족하지 못하면 증가수열에 숫자를 포함하지 않고, 다음 숫자들을 계속 살펴보는 식이다.   이 문제도 답보고 겨우 풀었는데, DP 문제에 대한 감을 살짝 잡은 것 같다.(아직 확실하진 않음)   이런 최대값 찾는 DP문제의 경우 조건에 맞아 DP 배열의 값을 갱신한 후, 최대값을 갱신하는 작업을 반복하는 방식인 것 같다.   너무 당연한 말을 한것 같지만, 이런 감 찾는데 정말 오래걸렸다.   아무튼   될때까지 하자.     정답 코드  // // Created by Keith_Lee on 08/01/2019. //  #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string.h&gt;  using namespace std;  int T;  int main(){     cin &gt;&gt; T;      for(int test=1; test&lt;=T; test++){         int maximum = 0;         int N;          cin &gt;&gt; N;          int numbers[N];         int DP[N];          for(int i=0; i&lt;N; i++){             cin &gt;&gt; numbers[i];         }          bzero(DP, sizeof(DP));          for(int i=0; i&lt;N; i++){             for(int j=i+1; j&lt;N; j++){                 if(numbers[j] &lt; numbers[i]) continue;                 if(DP[j] &gt;= DP[i] + 1) continue;                 DP[j] = DP[i] + 1; // 증가수열이면서 수열 count가 증가한다면 1 더해줌.                 maximum = max(maximum, DP[j]); // 최대값 갱신.             }         }          cout &lt;&lt; '#' &lt;&lt; test &lt;&lt; ' ' &lt;&lt; maximum+1 &lt;&lt; '\\n';     } }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "keithlee94.github.io/algorithm/SWEA_3307/",
        "teaser":null},{
        "title": "Swea_5215",
        "excerpt":"SWEA 5215번  Link: 5215번: 햄버거 다이어트     문제 설명  완전탐색으로 최적의 조합을 구하는 문제.   문제 보자마자 ‘이건 DFS쓰면 풀리겠구나’ 하는 생각은 들었다.   이렇게 생각하고 풀었는데, DFS 구현에서 정말 많이 헤맸다.   DFS랑 BFS는 그래도 구현방법을 다 외우고 있었다고 생각했었는데 벌써 다 까먹은 모양이다.   예전에 코딩테스트 볼때도 확실하게 몰랐던거니 당연할수도.   어떻게든 고쳐서 해보다 안되서 답 찾아서 풀었다.   핵심은 DFS를 쓰긴 하는데 각각의 재료를 포함했을때와 포함하지 않았을때를 반드시 같이 돌려야 한다는것.   제약조건에 따라 포함하거나 포함안하거나 따지면서 DFS 두번 돌리면 바로 풀린다.   아직도 정말 갈길이 멀다고 생각했다.   DFS, BFS는 자신있다고 생각했는데… 심지어 DFS로 풀어야된다는걸 알면서도 틀려서 더 자괴감 오진다.   될때까지 하자.     정답 코드  // // Created by Keith_Lee on 07/01/2019. //  #include &lt;iostream&gt; #include &lt;vector&gt;  using namespace std;  int T; int N, L; int maximum = 0;  vector&lt;pair&lt;int, int&gt;&gt; base;  void DFS(int start, int calory, int score){     if(start == N){         maximum = maximum &gt; score ? maximum : score;         return;     }     if(calory + base[start].second &lt;= L){         DFS(start+1, calory+base[start].second, score+base[start].first); // start번째 재료 추가     }     DFS(start+1, calory, score); // start번째 재료 거름 }  int main(){     cin &gt;&gt; T;      for(int test=1; test&lt;=T; test++){         cin &gt;&gt; N &gt;&gt; L;          for(int i=0; i&lt;N; i++){             int calory;             int score;              cin &gt;&gt; score &gt;&gt; calory;              base.push_back(make_pair(score, calory));         }          DFS(0, 0, 0);          cout &lt;&lt; '#' &lt;&lt; test &lt;&lt; ' ' &lt;&lt; maximum &lt;&lt; '\\n';         while(!base.empty()){             base.pop_back();         }         maximum = 0;     } }    ","categories": ["Algorithm"],
        "tags": ["DFS"],
        "url": "keithlee94.github.io/algorithm/SWEA_5215/",
        "teaser":null},{
        "title": "10844",
        "excerpt":"백준 10844번  Link: 10844번: 쉬운 계단 수     문제 설명  어제는 피곤함에 빈둥거리다 아무것도 못올렸다.   이 문제는 어제부터 고민하다 방법을 찾았고, 그 방법을 어떻게 구현할지 많은 시행착오를 거친 끝에 결국 풀었다.   사실 맨 마지막에 내 생각이 확실한데 답이 자꾸 틀려서 다른사람 답을 찾아보긴 했지만, 그 답이 내가 생각한 그대로여서 여태껏 답 찾아본 문제들중 가장 치열하게 고민한 문제인 것 같다는 생각을 했다.   그만큼 이번에는 답찾아서 풀었음에도 쪽팔리다는 생각이 들지 않았고.   각설하고, 푸는 방법에 대해 설명해보자면 이 문제에서 각 자릿수가 몇자리수이냐는 아무 상관이 없다.   가장 중요한 것은 1의자리 숫자가 무엇인지.   N이 1일때, 2일때, 3일때의 경우들을 직접 구해보니 1의자리 숫자에 따라 다음 수가 영향을 받는다는 것을 알 수 있었다.   자꾸 보다보니 N일때의 답 = (N-1일때의 답 * 2) - (N-1일때의 계단수 중 첫자리 숫자가 1인 것의 갯수) 라는 규칙을 찾은것같은데, 맞는지는 모르겠다.   어떻게 구현할지 한참 고민하다 저 규칙대로 풀어보기 위해 우선 큐에 넣고 갱신해가면서 모든 경우를 다 돌려봤다.   한 5분은 지나야 전체 답을 구할 수 있더라.   이런 과정을 거치면서 이 문제를 어떻게하면 이전 N에서 얻은 답을 사용할수 있을지에 대해 중점적으로 고민해보았고, 결국 1의자리 숫자만이 영향을 미친다는 점을 찾기에 이르렀다.   이 문제를 풀며 가장 고무적이었다고 생각했던 부분은 DP의 특성을 어떻게든 적용하기 위해 노력했다는 점.   앞에서 구한 답을 어떻게 써먹을수 있는지 그 어느때보다 치열하게 고민한 것 같다.   이 문제를 풀어낸 것이 앞으로 DP문제를 푸는데 있어 전환점이 되길!!     정답 코드  // // Created by Keith_Lee on 08/01/2019. //  #include &lt;iostream&gt; #include &lt;strings.h&gt;  using namespace std;  int main(){     int N;      cin &gt;&gt; N;      unsigned long long DP[101][11];     bzero(DP, sizeof(DP));      for(int i=1; i&lt;10; i++){         DP[1][i] = 1;     }      for(int i=2; i&lt;=N; i++) {         DP[i][0] = DP[i-1][1];         for(int j=1; j&lt;10; j++){             DP[i][j] = (DP[i-1][j-1] + DP[i-1][j+1]) % 1000000000;         }     }      unsigned long long sum = 0;     for(int i=0; i&lt;10; i++){         sum += DP[N][i];     }     cout &lt;&lt; (sum % 1000000000) &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "keithlee94.github.io/algorithm/10844/",
        "teaser":null},{
        "title": "2293",
        "excerpt":"백준 2293번  Link: 2293번: 동전 1     문제 설명  이 문제도 어떻게든 DP로 풀어보려 온갖 방법으로 생각해봤다.   우선 각 동전들에 대해 최대로 쓸 수 있는 갯수를 구한 다음 하나씩 빼가면서 조합을 구하려고 생각해봤다.   그런데 동전이 몇종류나 있을지도 모르고 시간도 그만큼 오래걸릴것 같아 이 생각은 접었다.   암만 고민해봐도 이 방법 말고는 떠오르는 방법이 없어 결국 답을 찾아봤다.   답 찾아보니 점화식을 세울줄 알아야 풀 수 있는 문제더라.   심지어 그 점화식을 어떻게 세우는지에 대해서도 설명이 자세하게 나와있는게 잘 없어서 한참 뒤지면서 여러개 찾아보다가 겨우 이해했다.   어떤 블로그에서 표를 그려가면서 풀면 금방 이해하고 점화식을 세울 수 있을거라 했는데, 점화식에 대해 이해하고 나니 왜 그렇게 말했는지 알 것 같다.   점화식을 구하는 과정이다.     1원만 쓸 때 각 금액에 대해 나올 수 있는 경우의 수                                             1원             2원             3원             4원             5원             6원             7원             8원             9원             10원                                         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}       2원도 쓸 때 각 금액에 대해 나올 수 있는 경우의 수                                             1원             2원             3원             4원             5원             6원             7원             8원             9원             10원                                         {1, 2, 2, 3, 3, 4, 4, 5, 5, 6}    규칙  2원 경우의수 = 1원, 2원을 쓸때 0원 경우의수 + 1원만 쓸때 2원에 대한 경우의 수   3원 경우의수 = 1원, 2원을 쓸때 1원 경우의수 + 1원만 쓸때 3원에 대한 경우의 수   4원 경우의수 = 1원, 2원을 쓸때 2원 경우의수 + 1원만 쓸때 4원에 대한 경우의 수   …   1원, 2원을 쓸때 K원을 만드는 경우의 수: DP[K] += DP[K - 2]      5원도 쓸 때 각 금액에 대해 나올 수 있는 경우의 수                                             1원             2원             3원             4원             5원             6원             7원             8원             9원             10원                                         {1, 2, 2, 3, 4, 5, 6, 7, 8, 10}    규칙  6원 경우의수 = 1원, 2원, 5원을 쓸때 6원 경우의수 + 1원, 2원을 쓸때 6원에 대한 경우의 수   7원 경우의수 = 1원, 2원, 5원을 쓸때 7원 경우의수 + 1원, 2원을 쓸때 7원에 대한 경우의 수   …   1원, 2원, 5원을 쓸때 K원을 만드는 경우의 수: DP[K] += DP[K - 5]   최종 점화식: x원을 추가했을때 K원을 만드는 경우의 수: DP[K] += DP[K - x]   이대로 코드로 옮기면 풀린다.   작은문제로 쪼개고 그 결과를 저장하며 DP문제를 해결하는 유형에 대해서는 어떻게든 방법을 생각해낼 수 있을것 같은데, 점화식 짜서 풀어야되는 문제는 정말 답이 없는것 같다.    정답 코드  // // Created by Keith_Lee on 10/01/2019. //  #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt;  using namespace std;  int N, K;  int main(){     cin &gt;&gt; N &gt;&gt; K;      int DP[10001] = {0, };     int coins[101];      for(int i=1; i&lt;=N; i++){         cin &gt;&gt; coins[i];     }      DP[0] = 1;      for(int i=1; i&lt;=N; i++){         for(int j=1; j&lt;=K; j++){             if(j &gt;= coins[i]){                 DP[j] += DP[j - coins[i]];             }         }     }      cout &lt;&lt; DP[K] &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "keithlee94.github.io/algorithm/2293/",
        "teaser":null},{
        "title": "2156",
        "excerpt":"백준 2156번  Link: 2156번: 포도주 시식     문제 설명  문제를 보자마자 예전에 풀었던 계단 오르기와 비슷한 문제라는 생각이 들었다.   Link: 2579번: 계단 오르기   차이점이 있다면 계단 오르기의 경우 마지막 계단을 반드시 밟아야 했지만, 이 문제는 3잔을 연속으로 마실 수 없다는 제약을 제외하면 어떠한 제약사항이 없다는 점이다.   점화식으로 풀어야 한다는 점은 동일하다.   예전에 계단 오르기를 풀때 점화식 세우는 과정을 제대로 이해하지 못한 것 같다.   이번 문제에서도 점화식 세우는데 많은 어려움을 겪었고, 결국 에전에 풀었던 계단 오르기 문제를 다시 보면서 점화식을 어떻게 세워야 하는지 생각했다.   또, 마지막 계단을 반드시 밟아야 한다는 제약사항을 빼고 구현하는 방법에 대해서도 많이 고민했던것 같다.   결론적으로는 답을 찾아서 풀었다.   점화식 세우는 연습은 얼마나 해야 점화식을 세울 줄 알게 되려나??    정답 코드  // // Created by Keith_Lee on 11/01/2019. //  #include &lt;iostream&gt; #include &lt;vector&gt;  using namespace std;  int N;  int maximum(vector&lt;int&gt; numbers){     int result = 0;      for(int i=0; i&lt;numbers.size(); i++){         if(numbers[i] &gt; result){             result = numbers[i];         }     }      numbers.clear();     return result; }  int main(){     cin &gt;&gt; N;      int DP[10001];     int score[10001];      for(int i=1; i&lt;=N; i++){         cin &gt;&gt; score[i];     }      vector&lt;int&gt; to_compare;      DP[1] = score[1];     DP[2] = max(score[1] + score[2], score[2]);      for(int i=3; i&lt;=N; i++){         to_compare.push_back(DP[i-1]);         to_compare.push_back(DP[i-2] + score[i]);         to_compare.push_back(DP[i-3] + score[i] + score[i-1]);         DP[i] = maximum(to_compare);     }      cout &lt;&lt; DP[N] &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "keithlee94.github.io/algorithm/2156/",
        "teaser":null},{
        "title": "5th week summary",
        "excerpt":"알고리즘 스터디 내용 정리    알고리즘 설계 기법     완전검색: Brute Force            시간이 가장 많이 걸린다.       반드시 답을 찾을 수 있다 =&gt; 소요 시간 비교의 척도가 된다.       시간 내에 답을 찾을 수 있는지 사전에 확인해봐야 한다.           탐욕기법: Greedy            현재의 위치에서 최선의 선택을 한다.       선택이 옳았음을 증명하는 과정이 필요하다.       코드가 짧다.       답을 못찾을 수 있다.           가지치기: Backtracking            답이 될 수 없는 것은 탐색하지 않는다.           분할정복: Divide &amp; Conquer            부분해로 전체 해를 구해 나간다.           동적계획법: Dynamic Programming            부분해로 전체 해를 구해 나간다.(분할정복과 유사)       분할정복과의 차이: 부분해를 따로 저장함으로써 중복된 계산을 방지한다.            정렬     버블 정렬            O(n^2)       맨 뒤에 정렬된 원소는 고정시킨다.           카운팅 정렬            O(n+k)       n이 비교적 작을때만 가능.       양의 정수만 정렬 가능.           선택 정렬            O(n^2)           퀵 정렬            O(nlogn)       상용 API의 정렬은 거의 퀵정렬로 구현되어 있음: 카운팅 정렬이 가장 빠르지만 대상이 정수일때만 사용 가능하므로 제약사항이 없는 퀵정렬로 구현.           병합 정렬            O(nlogn)           가능하면 카운팅 정렬 사용, 안되면 API 사용.    입력 방식 비교     Scanner: 편하지만 시간이 많이 걸린다.   BufferedReader: 시간이 적게 걸리나 문자열로만 리턴 가능.            사용 예시           BufferedReader br = new BufferedReader(new InputStreamReader(System.in));   String s = br.readLine(); // 문자열로만 리턴. 사용자가 입력한 한 줄을 문자열로 통째로 받아옴.   s = \"20\";    int num = Integer.parseInt(s); // 숫자로 변경됨.    s = \"1 2 3 4 5\";   String[] arr = s.split(\" \"); // s를 공백단위로 쪼갠다 =&gt; arr: 5개의 문자열이 들어간다.                            출력 방식 비교     System.out.println(): 출력하기 쉬우나 느리다.   BufferedWriter: 빠르게 출력 가능.            사용 예시           BufferedWriter bw = new BufferedWriter(System.out);   bw.write(\"abcde\"); // 줄 안바뀜.   bw.write(\"\\n\"); // 줄바꿈하려면 개행문자 써줘야 함.                            static / non-static  static 멤버는 non-static 멤버에 접근할 수 없다: static 멤버는 객체 생성 전에 사용할 수 있고, non-static 멤버는 객체 생성 후에 사용할 수 있기 때문.     static            클래스 정보가 처음 로딩된 후 ~ 프로그램 종료시까지 사용 가능.(속도 빠름)       단점: 메모리에 상주하므로 메모리 낭비 가능성 존재.           non-static            객체 생성 시점 ~ 참조변수가 없어질때까지 사용 가능.            Java 프로그램 메모리 영역     Call Stack: 메인 메소드, 지역변수 + 메인 메소드에서 호출된 메소드, 지역변수 저장.   Heap   Method Area   의 3가지 영역이 프로그램 실행시 자동으로 생성됨.    반복문, 재귀함수     반복문: CPU의 연산만 사용하므로 메모리 사용량이 적다.   재귀함수: 속도가 느리고 Call Stack 영역의 메모리를 많이 사용한다.   =&gt; 꼭 필요한 경우에만 재귀함수 사용할것.(필요할때: 동적으로 반복문을 추가해야할 때)   재귀함수의 인자도 Call Stack에 계속 쌓이므로 반드시 필요한 경우가 아니면 전역변수 등으로 처리하여 메모리를 절약할 수 있다.      재귀함수 예시: 2진수 3자리를 모두 출력하는 재귀함수     void twoThree(int i, int end, int[] arr){ // i: 시작 차수, end: 종료 차수, arr: 숫자 저장할 배열   if(i == end){       System.out.println(Arrays.toString(arr));       return;   }   else{       arr[i] = 0;       twoThree(i+1, end, arr);       arr[i] = 1;       twoThree(i+1, end, arr);   } }              Java 내용 정리    class, object     class: 틀   object: 틀에서 만든 대상.    class 정의     class명: 특수문자는 $, _만 허용. 길이제한 없음. 반드시 문자로 시작(숫자로 시작할 수 없음)   class를 개발한다 = 부품을 만드는 것과 같다. =&gt; 재활용성을 염두에 두고 개발해야 한다.   class 내 field값을 초기화하지 않고 객체 생성시 각 타입의 기본값으로 초기화된다.    객체 생성     Class Area에서 호출하려는 class가 있는지 찾는다.   있으면 Heap 영역에 객체 주소 할당.   생성된 객체에 할당된 주소값 저장.            Class Loader: 하드디스크에 있는 class 파일을 메모리로 읽어온다.       Class Area: 메모리로 읽어온 클래스의 정보를 저장하는 곳.            생성자     클래스와 이름이 같은 메소드.   반드시 리턴타입이 없어야 한다.   객체 생성시 항상 호출된다 =&gt; 반드시 있어야 한다.(초기화작업 필요없을 경우 생략 가능)   생성자를 따로 정의해두지 않았다면 컴파일러가 컴파일 시 기본 생성자를 코드에 삽입한다.   기본 생성자: 아무 파라미터가 없는 생성자.    this()     생성자 안에서만 사용 가능한 메소드.   다른 여러 생성자가 있으면 this()를 통해 다른 생성자 실행 가능.   다른 생성자 호출시 넘겨줄 인자가 없으면 임의로 기본값을 정해 넘길 수 있다. =&gt; 아무 인자 없이 호출시 전부 설정된 기본값으로 들어간다.   목적: 중복 코드를 줄이기 위해.    Overloading     같거나 비슷한 일을 하는 메소드 구현시 메소드 이름을 같게 정의하여 사용을 편리하게 한다.   메소드명은 같고, 파라미터가 다르다.    접근 수식어(=접근 지정자, 접근 제한자)     public: 모든 경우 접근 가능.   protected: 패키지 상관없이 상속관계면 접근 가능.   default: 아무 접근 지정자가 없으면 default. 같은 패키지 내에서만 접근 가능.   private: 같은 class 내에서만 접근 가능.       같은 패키지 &amp; 상속관계: default, protected, public 접근 가능.   같은 패키지 &amp; 다른 클래스: default, protected, public 접근 가능.   같은 클래스: default, private, protected, public 접근 가능.   다른 패키지 &amp; 상속관계: protected, public 접근 가능.   다른 패키지: public 접근 가능.    getter, setter  함부로 데이터에 접근하려는 시도를 방지할 수 있다.    한개의 .java파일 내에 여러개의 클래스     한 클래스 내에 여러 클래스 생성 가능.   But, 접근지정자는 단 하나의 클래스에만 붙일 수 있다.(.java파일의 파일명과 일치하는 클래스에만 붙일 수 있음): 프로그램 외부에서 무분별하게 접근하는 것을 막기 위함(보안적 측면)   파일명과 일치하지 않는 모든 클래스들은 default 접근 지정자만 혀용한다.   class에 대한 접근 지정자는 public, default의 2가지만 가능.    API     Application Programming Interface   객체지향 언어에서 class 단위로 미리 구현되어 제공되는 프로그램.   class 단위의 library.    객체지향형 언어의 3가지 특징     Encapsulation(캡슐화)   Inheritance(상속)   Polymorphism(다형성)    Inheritance     Java에서는 단일 상속만 지원.(부모는 하나만 가능)   class 설계시 특정 class를 상속받아 그 class의 variable과 메소드를 사용할 수 있다.   is a 관계            자식이 부모자리에 갈 수 있으나 부모가 자식자리에 갈 수 없다.       예: Tiger is an Animal - Tiger: 자식, Animal: 부모.           Generalization: class들의 공통된 특징을 모아 super class를 만든다.   Specialization: 비슷한 속성, 기능을 가진 클래스를 상속받아 새로운 클래스를 만든다.(sub class를 만든다)   sub class object 생성시 자동으로 super class의 생성자가 먼저 실행된다.            parent 객체가 먼저 생성된다.       상속관계가 여러 단계를 거치면 메모리가 낭비될 수 있다 =&gt; 상속구조를 최소화하는 것이 좋다.            Overriding     부모에게 물려받은 메소드를 자식 클래스에 맞게 재정의하는 것.   메소드 이름, 리턴 타입, 파라미터 모두 부모클래스의 메소드와 일치해야 한다.   바꿀 수 있는것: 메소드 바디, 접근 지정자.   접근 지정자는 부모의 접근 지정자와 같게 하거나 범위를 넓히는 방향으로만 가능하다.(좁아지면 안됨)   @Override annotation이 붙는다.   오버라이딩한 후에는 부모의 메소드 대신 항상 자식이 오버라이딩한 메소드가 실행된다.    @annotation     프로그램에 대한 설명이나 설정사항 등을 나타냄.   함부로 지우다가 큰일난다.    super, this     static 메소드 내에서 사용 불가.   static 메소드 내에서 굳이 쓰려면: non static 메소드를 메소드에서 super나 this를 사용하도록 새롭게 정의한 후 static 메소드에서 그 메소드를 호출한다.   super는 한번만 쓸 수 있다: super.super 안됨.    NullPointerException     객체 생성이 안된 상태에서 객체의 메소드 호출시 발생.    상속관계에서 인자 있는 생성자     부모, 자식의 생성자 인자 중 겹치는게 있으면 super(겹치는인자, 겹치는인자, …)을 쓴 다음 자식만의 인자를 사용하여 따로 초기화하면 편하다.   목적: 코드 중복 제거 + 자식이 별도의 생성자를 정의할 수 있도록 한다.   주의사항: super(…) 구문이 항상 맨 먼저 나와야 한다.    상속관계 예시  class Parent{}  class Child extends Parent{}  Parent x = new Child(); // 가능: 자식은 부모자리에 갈 수 있다. Child x = new Parent(): // 불가능: 부모는 자식자리에 갈 수 없다.    Polymorphism(다형성)     생성된 객체를 가리키는 레퍼런스(변수)의 타입이 여러가지인 경우.   타입 캐스팅: 실제 저장되어 있는 객체가 캐스팅할 타입보다 작은 타입이어야 형변환 가능.            반대로 할 경우 컴파일은 되지만 실행시 Exception 발생.           상속관계에서는 부모가 항상 자식보다 큰 타입이 된다.    Polymorphism 예시  class GrandParent{     String name = \"Doe\";      public void printName(){         System.out.println(name);     }  }  class Parent extends GrandParent{     String name = \"Tom\";     String address = \"Seoul\";      public void printName(){         System.out.println(name);     }      public void printAddress(){         System.out.println(address);     }  }  public class Child extends Parent{     public void printName(){         System.out.println(\"Tomson\");     }      public void callSuper(){         super.printName();     }      public static void main(String[] args){         Parent x = new Child(); // 가능         GrandParent c = new Child(); // 가능         Child y = new Parent(); // 불가능          c.printName(); // 결과: Tomson =&gt; GrandParent의 printName을 Parent가, Parent의 printName을 Child가 재정의하므로 Child까지의 범위에서 가장 마지막에 재정의된 Child의 printName이 실행된다.         c.callSuper(); // 에러: GrandParent 타입의 상위가 없기 때문.         c.printAddress(); // 에러: GrandParent에 printAddress 메소드가 정의되어 있지 않다.         System.out.println(c.getClass().getSimpleName()); // 결과: Child =&gt; c의 타입은 GrandParent지만, 실제로 저장된 객체는 Child이므로 Child가 출력된다.(getClass: 실제로 저장된 객체의 타입을 가져온다.)                  GrandParent e = new Parent();         e.printName(); // 결과: Tom =&gt; GrandParent의 printName을 Parent가 재정의했으므로 Parent까지의 범위에서 가장 마지막에 재정의된 Parent의 printName이 실행된다.         System.out.println(e.getClass().getSimpleName()); // 결과: Parent.     } }    ","categories": ["Java"],
        "tags": ["Java"],
        "url": "keithlee94.github.io/java/5th-Week-Summary/",
        "teaser":null},{
        "title": "1520",
        "excerpt":"백준 1520번  Link: 1520번: 내리막 길     문제 설명  평범한 길찾는문제일줄 알고 우선 BFS부터 냅다 써서 풀었다.   분명 틀린 답은 아니다. 그런데 문제의 의도는 BFS 대신 DFS를 사용하여 메모리를 절약하고, DFS에 DP를 적용하여 시간을 절약하는 것이 의도였다.   DFS에 DP를 접목시키는 문제는 처음 보는것 같다.   그 느린 DFS를 이렇게 보완할수도 있구나 하는 생각이 들었다.   이 문제를 풀면서 BFS와 DFS의 차이를 제대로 체감할 수 있었던 것 같다.   BFS는 시간 내에 해를 찾을 수 있지만, 큐를 사용하는 만큼 더 많은 메모리 공간을 사용한다는 점이 특징.   DFS는 메모리 공간은 절약할 수 있지만, 깊이가 깊어질수록 매우 많은 시간을 요구한다는 점이 특징이다.   이러한 DFS의 깊이에 따른 문제를 보완하는 방법으로 DP를 사용하는 문제였다.   둘을 어떻게 접목시킬지 방법이 안떠올라서 결국 답을 찾아보고서야 이해할 수 있었다.   우선 DP 배열을 전부 -1로 초기화하고 시작한다.   그 다음, DFS를 목적지부터 (0, 0)까지 가도록 거꾸로 실행한다.   DFS에 들어가면 우선 DP 배열부터 살펴보게 되는데, DP[startX][startY]가 -1이 아니라는 것은 이미 저장된 값이 있으며, 이는 이미 탐색해서 구한 값이 있음을 의미하므로 그대로 리턴한다.   만약 startX나 startY가 범위를 벗어나면 0을 리턴하고, (0, 0)에 도착하게 되면 1을 리턴한다.   이 3가지 조건문에 걸리지 않았다는 것은 아직 탐색하지 않은 곳임을 의미하므로 탐색을 진행한다.   가장 먼저 DP[startX][startY]를 0으로 설정한다.   그 다음은 통상 아는 DFS를 진행하는데, 내려가는 방향으로만 갈 수 있고 우리는 DFS를 거꾸로 진행하고 있으므로 map[nextX][nextY]가 map[startX][startY]보다 클 경우에만 DFS를 진행한다.   조금 다른점이 있다면 통상 아는 DFS였다면 DFS(nextX, nextY)만 부르고 끝났겠지만, 이 문제는 DP를 접목시켜야 하므로 DP[startX][startY]의 값에 DFS(nextX, nextY)를 더한 값을 설정한다.   이때 연쇄적으로 재귀함수를 돌다 더 갈수 없으면 DP[startX][startY]를 리턴하고, 리턴되는 값을 계속 더해주는 것이다.   같은 방법으로 4방향 모두 탐색하며 DFS를 완성한다.   풀이방법을 외워둬야 할 것 같은 문제다.   BFS와 DFS의 차이점, DFS와 DP의 연계를 모두 배울 수 있는 문제였다. 까먹을때쯤 꼭 다시풀어볼 문제.    BFS로 풀다 틀린 코드  // // Created by Keith_Lee on 13/01/2019. //  #include &lt;iostream&gt; #include &lt;queue&gt;  using namespace std;  int N, M;  int dx[4] = {0, 0, 1, -1}; int dy[4] = {1, -1, 0, 0};  int map[501][501];  int BFS(int startX, int startY){     int result = 0;     queue&lt;pair&lt;int, int&gt;&gt; Queue;      Queue.push(make_pair(startX, startY));  //    vector&lt;pair&lt;int, int&gt;&gt; visits;      while(!Queue.empty()){         int currentX = Queue.front().first;         int currentY = Queue.front().second;         Queue.pop();  //        visits.push_back(make_pair(currentX, currentY));          if(currentX == N &amp;&amp; currentY == M){ //            for(int i=0; i&lt;visits.size(); i++){ //                cout &lt;&lt; map[visits[i].first][visits[i].second] &lt;&lt; ' '; //            } //            cout &lt;&lt; '\\n'; //            visits.clear();             result++;         }          for(int i=0; i&lt;4; i++){             int nextX = currentX + dx[i];             int nextY = currentY + dy[i];              if(nextX &gt; 0 &amp;&amp; nextX &lt;= N &amp;&amp; nextY &gt; 0 &amp;&amp; nextY &lt;= N){                 if(map[currentX][currentY] &gt; map[nextX][nextY]){                     Queue.push(make_pair(nextX, nextY));                 }             }         }     }      return result; }  int main(){     cin &gt;&gt; M &gt;&gt; N;      for(int i=1; i&lt;=M; i++) {         for (int j = 1; j &lt;= N; j++) {             cin &gt;&gt; map[i][j];         }     }      cout &lt;&lt; BFS(1, 1) &lt;&lt; '\\n';      return 0; }    정답 코드  // // Created by Keith_Lee on 13/01/2019. //  #include &lt;iostream&gt; #include &lt;memory.h&gt;  using namespace std;  int N, M;  int map[501][501]; int DP[501][501];  int dx[4] = {0, 0, 1, -1}; int dy[4] = {1, -1, 0, 0};  int DFS(int startX, int startY){     if(DP[startX][startY] != -1){         return DP[startX][startY];     }     if(startX &lt; 0 || startX &gt;= N || startY &lt; 0 || startY &gt;= M){         return 0;     }     if(startX == 0 &amp;&amp; startY == 0){         return 1;     }      DP[startX][startY] = 0;      for(int i=0; i&lt;4; i++){         int nextX = startX + dx[i];         int nextY = startY + dy[i];          if(map[nextX][nextY] &gt; map[startX][startY]){             DP[startX][startY] += DFS(nextX, nextY);         }     }      return DP[startX][startY]; }  int main(){     cin &gt;&gt; N &gt;&gt; M;      for(int i=0; i&lt;N; i++){         for(int j=0; j&lt;M; j++){             cin &gt;&gt; map[i][j];         }     }     memset(DP, -1, sizeof(DP));      cout &lt;&lt; DFS(N-1, M-1) &lt;&lt; '\\n';      for(int i=0; i&lt;N; i++){         for(int j=0; j&lt;M; j++){             cout &lt;&lt; DP[i][j] &lt;&lt; ' ';         }         cout &lt;&lt; '\\n';     }      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DP","DFS","BFS"],
        "url": "keithlee94.github.io/algorithm/1520/",
        "teaser":null},{
        "title": "16234",
        "excerpt":"백준 16234번  Link: 16234번: 인구 이동     문제 설명  작년 하반기 삼성 SW 역량테스트 문제다.   시험장에서 문제 보고 뭔가싶어서 바로 넘기고 다른문제 올인하다 결국 둘다 못풀어서 광탈했던 악몽이 다시 떠오른다.   아무 문제나 붙잡고 풀다가 다 안풀려서 어차피 한번은 풀어야될 문제라 결국 붙잡고 풀었다.   예전부터 지인들이 니가 문제보고 쫄아서그렇지 별거 아닌문제다 라는 말을 했었는데 막상 풀어보니 틀린말은 아닌거같다.   하지만 내가 저날 시험장에서 이문제를 제대로 읽고 이해했다고 해도 시간안에 푸는건 무리였을것 같다.   BFS를 여러번 해야되는 문제다.   map에서 수정할 부분이 어디인지 찾아내는 부분에서 BFS를 해야 하고, 수정할 부분을 찾은 다음 map을 수정하기 위한 BFS를 해야하는 문제.   거기다 이 과정을 더이상 수정할 부분이 없을때까지 반복해야 한다.   BFS문제라는 느낌은 확실히 들었다.   처음에 문제 접했을땐 map에서 수정할 부분을 찾는 과정에 대해 BFS를 써야겠다는 생각이 안들었다.   그래서 3중 for문을 사용해서 수정할 부분을 찾아 마킹했다.   그 이후 map을 수정하는 부분에 대해서는 BFS로 구현하여 풀어보았다.   풀어본 다음 테스트케이스들을 넣어보니, 단순히 3중 for문으로는 풀수 없는 문제라는 것을 깨달았다.   마지막까지 가장 애먹였던 부분이 이부분인데, map에서 수정할 부분을 단순히 1로 마킹할 경우 영역간 경계가 있으나 이 경계를 무시하고 BFS를 진행하는 문제가 생긴다.   BFS로 바꿔서 해보고도 마지막에 이부분을 놓쳐 한번 더 삽질하다 결국 풀었다.   막상 풀고나니 별거 아닌건 맞는데, 시험장의 압박감과 이 시험볼 당시 알고리즘 공부도 어설프게 하고 간 나는 절대 못풀었을 것 같다는 생각이 들었다.   얻어가는 점은 몇번씩 실패하고도 남의 도움 안받고 내 힘만으로 풀어냈다는 점, BFS문제를 혼자 힘만으로 제대로 풀어냈다는 점이다.   이런 점을 밑거름삼아 앞으로 있을 역량테스트에서도 포기하지 않고 끝까지 풀어내는 것이 목표이다.   다시는 악몽 안꾸련다. 앞으로도 화이팅!!!    정답 코드  // // Created by Keith_Lee on 15/01/2019. //  #include &lt;iostream&gt; #include &lt;memory.h&gt; #include &lt;queue&gt; #include &lt;vector&gt;  using namespace std;  int N, L, R; int dx[] = {0, 0, 1, -1}; int dy[] = {1, -1, 0, 0};  int map[50][50] = {0, }; int toChange[50][50] = {0, }; int visit[50][50] = {0, };  vector&lt;pair&lt;int, int&gt;&gt; changes(){     vector&lt;pair&lt;int, int&gt;&gt; result;      for(int i=0; i&lt;N; i++){         for(int j=0; j&lt;N; j++){             if(toChange[i][j] != 0){                 result.push_back(make_pair(i, j));             }         }     }      return result; }  void toChange_init(){     int areaCount = 1;      for(int i=0; i&lt;N; i++){         for(int j=0; j&lt;N; j++){             queue&lt;pair&lt;int, int&gt;&gt; Queue;             Queue.push(make_pair(i, j));              while(!Queue.empty()){                 int currentX = Queue.front().first;                 int currentY = Queue.front().second;                 Queue.pop();                  for(int k=0; k&lt;4; k++){                     int nextX = currentX + dx[k];                     int nextY = currentY + dy[k];                      if(nextX &gt;= 0 &amp;&amp; nextX &lt; N &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; N){                         int gap = abs(map[currentX][currentY] - map[nextX][nextY]);                         if(gap &gt;= L &amp;&amp; gap &lt;= R &amp;&amp; toChange[nextX][nextY] == 0){                             toChange[nextX][nextY] = areaCount;                             Queue.push(make_pair(nextX, nextY));                         }                     }                 }             }              areaCount++;         }     } }  void BFS(int currentX, int currentY){     vector&lt;pair&lt;int, int&gt;&gt; visited;      queue&lt;pair&lt;int, int&gt;&gt; Queue;     Queue.push(make_pair(currentX, currentY));      int changeCount = 0;     int changeSum = 0;     visit[currentX][currentY] = 1;      while(!Queue.empty()){         int startX = Queue.front().first;         int startY = Queue.front().second;         Queue.pop();          changeCount++;         changeSum += map[startX][startY];         visited.push_back(make_pair(startX, startY));          for(int i=0; i&lt;4; i++){             int nextX = startX + dx[i];             int nextY = startY + dy[i];              if(nextX &gt;= 0 &amp;&amp; nextX &lt; N &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; N){                 if(visit[nextX][nextY] == 0 &amp;&amp; toChange[nextX][nextY] == toChange[startX][startY]){                     Queue.push(make_pair(nextX, nextY));                     visit[nextX][nextY] = 1;                 }             }         }     }      for(int i=0; i&lt;visited.size(); i++){         map[visited[i].first][visited[i].second] = changeSum / changeCount;     } }  int main(){     cin &gt;&gt; N &gt;&gt; L &gt;&gt; R;      for(int i=0; i&lt;N; i++){         for(int j=0; j&lt;N; j++){             cin &gt;&gt; map[i][j];         }     }      int count = 0;      while(true) {         memset(toChange, 0, sizeof(toChange));         memset(visit, 0, sizeof(visit));          toChange_init();          vector&lt;pair&lt;int, int&gt;&gt; ones = changes();         if (ones.size() == 0) {             break;         }          for (int i = 0; i &lt; ones.size(); i++) {             if (visit[ones[i].first][ones[i].second] == 0) {                 BFS(ones[i].first, ones[i].second);             }         }          count++;     }      cout &lt;&lt; count &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DFS","BFS"],
        "url": "keithlee94.github.io/algorithm/16234/",
        "teaser":null},{
        "title": "6th week summary",
        "excerpt":"알고리즘 스터디 내용 정리    자료구조     선형            이전, 이후 데이터가 1:1 관계이다.       특정 데이터의 다음에 올 데이터가 무엇인지 확실히 알 수 있다.(예: 배열, 연결리스트)           비선형            이전, 이후 데이터가 1:다 or 다:다 관계이다.       특정 데이터의 다음에 올 데이터가 무엇인지 확실하게 알 수 없다.       전체를 빠짐없이 순회하며 한번씩만 방문하는 것이 관건(예: 그래프)                    그래프                            트리: 사이클이 없어야 한다.               트리를 제외한 나머지: 사이클이 있을 수 있다.                                                    검색     순차 검색            O(n) -&gt; Best: O(1), Worst: O(n), Average: O(n/2) = O(n)       정렬 여부와 상관없이 사용 가능.           이진 검색            O(log n)       Divide &amp; Conquer       자료가 정렬된 상태에서만 사용 가능.       데이터 양이 많을수록 유리함.            정렬되지 않은 데이터 검색     이진 검색            정렬       이진검색                    O(n^2) + O(log n) = O(n^2) 소요.                           순차검색: O(n)   결론: 정렬 알고리즘에서 이미 순차검색보다 성능이 떨어지므로 정렬되지 않은 데이터에 대해서는 순차검색을 사용하는 것이 유리하다.    Java 메모리 영역     Call Stack: 자동으로 초기화되지 않음.   Heap: 자동으로 초기화됨.   Method Area: 자동으로 초기화됨.   Constant Pool: Method Area에 포함됨. 상수를 재활용하기 위해 존재함.(여러개의 상수가 있어도 해싱하여 저장되므로 검색시간이 느려지는 일이 없다.)    String 선언별 차이점     String str1 = “abc”; =&gt; Constant Pool에 생성된다.   String str2 = new String(“abc”); =&gt; Heap에 생성된다.   String str3 = “abc”; =&gt; str1과 같은 주소가 할당된다.   str1, str3처럼 기본형으로 만들 경우 Constant Pool에 저장되고, 둘의 값이 같을 경우 같은 주소가 할당된다.    StringTokenizer     문자열을 쪼갤때 사용한다.   정규식을 인자로 허용하지 않으므로 String.split()보다 속도가 빠르다.    StringBuilder, StringBuffer     문자열 저장시 사용.    Object.equals()     어떤 자식 클래스에서 사용할지 모르므로 == 연산자로 구현되어 있다.   내용 비교하려면: 자식 클래스에서 오버라이딩하여 사용해야 함.    DP와 Divide &amp; Conquer     Divide &amp; Conquer: 작은 문제를 해결하여 큰 문제를 해결하는 기법.   DP: Divide &amp; Conquer + Memoization. 작은 문제를 해결하고 이를 따로 저장해둠으로써 똑같은 작은 문제를 다시 풀게 되어 발생하는 시간 낭비를 줄일 수 있다.    Java 스터디 내용 정리    자주 오버라이딩하는 함수들  1. toString()  - 오버라이딩 했을 경우: System.out.println(객체); 실행시 객체의 클래스에서 재정의된 toString()이 실행됨. - 오버라이딩 안했을 경우: System.out.println(객체); 실행시 주소값만 출력된다 - Object 클래스의 toString()은 객체의 주소값만 돌려주므로. - 출력함수의 인자로 객체를 넣을 시 자동으로 toString()이 호출된다.   2. hashCode()  - 같은 객체인지 확인할 때 사용.   3. equals()  - 두 객체의 내용물이 같은지 확인할 때 사용. - Object.equals(): 단순 객체 주소 비교. - String.equals(): Object.equals()를 오버라이딩하여 문자 하나씩 비교하여 일치하는지 확인.    String 객체의 특징     String 클래스의 메소드들은 원본 데이터를 바꾸지 않는다.   String은 final 상수이므로 내용을 바꿀때마다 새로운 데이터가 heap에 쌓인다.    사용 제한자  1. final  - class, method, variable에 붙일 수 있다. - class앞에 붙으면: 상속 불가. 그 클래스 안의 모든 method, field는 내용을 변경할 수 없다. - method앞에 붙으면: 오버라이딩 불가, 오버로딩은 가능. - field앞에 붙으면: 값 수정 불가.(변수가 상수로 변한다.)   2. static  - member변수, member메소드, block에 붙일 수 있다. - static이 붙은 모든 것들은 main 메소드 실행 전에 Class Area에 한개씩만 생성된다.     - 실행 전에 만들어진다.     - 컴파일이 완료된 시점에 생성되므로 따로 객체를 만들 필요가 없다. - static이 없는 모든 것들은 main 메소드 실행 후 Heap에 생성된다.     - 실행 후에 만들어진다. - static variable = class variable - non-static variable = instance variable - 다른 클래스에서도 사용 가능: class이름.변수이름 or class이름.메소드이름 으로 사용 가능. - static block: main 메소드보다 우선순위가 높다.     - main 메소드보다 먼저 실행된다.     - static block간 우선순위는 코드 내 순서와 같다. - static 메소드 내에서는 this, super 키워드를 사용할 수 없다.     - 이유: this, super 키워드는 객체가 있을때만 사용 가능하다.     - static 메소드는 객체가 생성되기 전에 실행되므로 this, super 키워드를 사용할 수 없다.   3. abstract  - abstract: 추상적인, 구체적이지 않은, 완성되지 않은. - abstract 클래스: 클래스 내에 abstract 메소드가 존재한다. - abstract 메소드: 바디가 없는 미완성 메소드. abstract 클래스 내에만 정의 가능.(C의 prototype과 같다.) - concrete 메소드: 바디가 있는 완성된 메소드. abstract 클래스 내에도 정의 가능. - abstract 메소드가 있으면 객체 생성 불가능.     - 미완성 메소드가 있다 = 미완성 클래스이다.     - 자식 클래스에서 상속받아 완성시켜야 객체 생성이 가능하다.(자식 클래스가 오버라이딩해야 한다.) - 장점: 상속관계로 묶여있으므로 여러 종류의 객체들을 부모 타입으로 묶어 하나의 자료구조에 넣고 handling할 수 있다. - 용도     - 타입을 물려주는 용도로 빈 껍데기만 미리 만들어놓는다.     - 객체 생성을 막는 용도로도 사용 가능하다.    interface     추상 클래스와 유사하다.   시작 키워드가 class가 아닌 interface이다.(용도는 추상 클래스와 같이 타입을 물려주는 용도이다.)   상수와 추상 메소드들로만 구성되어 있다: concrete 메소드를 포함할 수 없다.   내부 메소드에 별도로 abstact를 붙일 필요가 없다: interface 자체가 미완성이므로 포함하는 모든 메소드들에 자동으로 public abstract 키워드가 붙는다.   내부 field에는 자동으로 static final 키워드가 붙는다: 값을 변경할 수 없다.   자식 클래스에서 상속시 extends가 아닌 implements 키워드를 사용해야 한다.   다중 상속 지원: implements 키워드를 통해 여러 클래스를 상속 가능하다.   extends와 달리 implements 클래스1, 클래스2, … 형태로 사용 가능.   예:       class ICircle extends Boat implements IShape, Seoul   =&gt; iCircle의 타입이 될 수 있는 것: Boat, IShape, Seoul.           의존성 감소: 고치는 부분을 줄일 수 있다 - 유지보수를 편하게 해준다.   interface와 interface 간에도 상속관계 성립 가능.   interface 예시    위 그림처럼 관계를 만든 다음       void pay(Thing x){       ...   }   메소드를   void pay(Valuable x){       ...   }   으로 변경한다.            instanceof     상속관계가 없을 경우 사용 불가능한 연산자.   작은 타입 -&gt; 큰 타입 순서로 사용해야 한다.    has-a 관계     서로 의존성을 갖게 되는 관계(Coupling) - 지양해야 함.   한 클래스가 다른 클래스를 인자로 가지고 있는 관계.   수정사항 발생시 두개의 클래스를 전부 수정해야 한다.   보완: interface를 사용하여 타입의 자유도를 높여 의존성을 낮출 수 있다.    Collections     여러개의 데이터를 저장.   저장 방식에 따라 List, Set, Map으로 나뉜다.                  구분       List       Set       Map                       중복       허용       허용 X       허용 X                 순서       있음       없음       없음           1. List: 기존 배열과 유사.  - ArrayList - Vector     - 아무 인자 없이 생성시 10칸짜리 Vector가 생성되고, 용량이 부족하면 기존의 크기를 2배로 늘린 후 재배치.     - Vector.capacity(): Vector 전체의 크기 리턴.     - Vector.size(): Vector 내 component 갯수 리턴.   2. Set: 집합과 같은 개념.  - HashSet   3. Map: (Key, Value) 쌍으로 데이터 저장, Key값 중복 불가.  - HashMap - HashTable      Iterator: 순서 없는 자료구조를 탐색하기 위해 사용함.    Generic Programming     HashMap&lt;K, V&gt; 와 같이 &lt;…&gt;의 형태를 이룬다.   &lt;&gt; 안에는 객체만 올 수 있다: 기본형을 사용하고싶을 경우 wrapper class로 바꿔 넣어야 한다.            예: int형 ArrayList - ArrayList           Generic을 사용할 경우 클래스 변동사항이 있으면 적용되는 시점이 미뤄진다: 객체 생성시 유연성이 생긴다.            통상 클래스들은 한번 컴파일하면 다시 컴파일하지 않는 이상 변경사항이 반영되지 않는다.           클래스는 완성되었으나 타입이 정해지지 않은 형태이다.            설계 단계에서는 타입 미정.       객체 생성시 타입 확정.       결론: compile time에서는 타입이 결정되지 않은 상태, runtime에서 타입이 결정.           예시       public class MyClass&lt;X&gt;{       private X data;        public X getData(){           return data;       }        public void setData(X data){           this.data = data;       }        public static void main(String[] args){           MyClass&lt;String&gt; m1 = new MyClass&lt;&gt;();           MyClass&lt;Integer&gt; m2 = new MyClass&lt;&gt;();           MyClass&lt;Circle&gt; m3 = new MyClass&lt;&gt;();       }   }    =&gt; m1, m2, m3의 타입은 모두 MyClass로 같다.            Singleton Pattern     디자인 패턴: 설계 패턴. 클래스를 설계하는 패턴을 의미.   어플리케이션 전체에서 객체를 한개만 생성하여 사용하는 패턴: 하나의 객체를 전체가 공유한다.   클래스명에 static이 붙는다: 오직 하나의 객체만 생성한다.   조건            field: private static이며 클래스 자신의 타입으로 선언되어야 한다.       생성자: private으로 설정.       객체를 생성하여 리턴하는 static 메소드가 반드시 있어야 한다.(통상 getInstance()라는 메소드 정의)           외부에서 객체 생성에 영향을 주지 않도록 한다            생성자는 Default 생성자만 두는 경우가 대부분이다.       생성자, 생성 메소드 오버로딩하지 않음.           예시       public class Speaker{       private static Speaker speaker;       private int volume;        private Speaker(){           volume = 5;       }        public static Speaker getInstance(){           if(speaker == null){               speaker = new Speaker();           }            return speaker;       }        public int getVolume(){           return volume;       }        public void setVolume(int volume){           this.volume = volume;       }   }    public class SingletonTest{        public static void main(String[] args){           Speaker s1 = Speaker.getInstance();           Speaker s2 = Speaker.getInstance();           Speaker s3 = Speaker.getInstance();            System.out.println(s1 == s2);           System.out.prinltn(s2 == s3);            s1.setVolume(10);           System.out.println(s1.getVolume());           System.out.println(s2.getVolume());           System.out.println(s3.getVolume());       }   }    실행 결과: s1, s2, s3의 주소값은 전부 같다.   =&gt; 전부 똑같은 하나의 객체만을 가리키고 있으므로, 한 객체에서 volume을 변경하면 모든 객체의 volume이 똑같이 바뀐다.            Comparable, Comparator     객체의 정렬과 관련한 인터페이스.   Comparable: 클래스 내부에 객체의 정렬 기준을 만들어놓고자 할때 사용하는 인터페이스.(반드시 한개만 존재한다.)   Comparator: 클래스 외부에 특정 객체의 정렬 기준을 명시하는 인터페이스.(클래스 내부의 Comparable 이외의 정렬 기준이 필요할 경우 별도의 클래스를 만들어 정의한다. - 정렬 기준은 한 메소드 내에 한개만 정의 가능.)   sort()로 정렬 가능한 객체: Comparator나 Comparable 인터페이스를 implements 하고 있어야 한다.    Class 종류     VO            Value Object       값을 저장할 수 있는 객체.           DAO            Data Access Object       이미 만들어진 VO를 프로세싱하는 목적.       CRUD: Create, Read, Update, Delete 기능 수행.           CO            Client Object            ","categories": ["Java"],
        "tags": ["Java"],
        "url": "keithlee94.github.io/java/6th-Week-Summary/",
        "teaser":null},{
        "title": "11724",
        "excerpt":"백준 11724번  Link: 11724번: 연결 요소의 개수     문제 설명  기초적인 DFS, BFS 문제다.   2차원 배열에 연경 요소들을 1로 표시하고, BFS나 DFS를 사용하여 탐색하면서 연결된 요소의 갯수를 구하는 문제.   한가지 간과하기 쉬운 사실은, 이 그래프는 방향이 없는 그래프이기 때문에 연결시 쌍방향을 전부 1로 설정해줘야 한다는 점.   처음에는 배열 인덱스때문에 두어번 틀렸다가 맞게 풀었더니 시간초과가 났다.   BFS를 사용하여 시간 내에 풀기 위해서는 큐에서 정점을 뺄 때가 아닌 큐에 넣는 시점에 visit을 표시해야 한다는 것을 알게 되었다.   오늘은 BFS, DFS 감찾는다고 생각하고 앞으로 집중적으로 어려운 문제도 풀어볼 예정이다.    정답 코드  // // Created by Keith_Lee on 21/01/2019. //  #include &lt;iostream&gt; #include &lt;queue&gt;  using namespace std;  int N, M; int map[1001][1001] = {0, }; bool visit[1001] = {false, };  int result = 0;  void BFS(int start){     queue&lt;int&gt; Queue;     Queue.push(start);      while(!Queue.empty()){         int next = Queue.front();         Queue.pop();          for(int i=1; i&lt;=N; i++){             if(!visit[i] &amp;&amp; map[next][i] == 1){                 visit[i] = true;                 Queue.push(i);             }         }     }      result++; }  int main(){     cin &gt;&gt; N &gt;&gt; M;      for(int i=0; i&lt;M; i++){         int start, end;         cin &gt;&gt; start &gt;&gt; end;         map[start][end] = 1;         map[end][start] = 1;     }      for(int i=1; i&lt;=N; i++){         if(!visit[i]){             visit[i] = true;             BFS(i);         }     }      cout &lt;&lt; result &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DFS","BFS"],
        "url": "keithlee94.github.io/algorithm/11724/",
        "teaser":null},{
        "title": "2583",
        "excerpt":"백준 2583번  Link: 2583번: 영역 구하기     문제 설명  기초적인 BFS 문제다.   2차원 배열에 모눈종이를 표시하고, 표시되지 않은 부분들에 대해 BFS를 진행하며 각 영역의 크기와 총 영역 갯수를 구하는 문제.   문제 보기에 좌표가 조금 다르게 표현되어 있어 이를 2차원 배열로 옮기는 과정에서 생각을 좀 했었다.   좌표만 잘 옮기면 무난히 풀 수 있는 문제.    정답 코드  // // Created by Keith_Lee on 22/01/2019. //  #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;string.h&gt; #include &lt;algorithm&gt;  using namespace std;  int M, N, K; int result = 0;  int map[100][100]; bool visit[100][100];  int dx[4] = {0, 0, 1, -1}; int dy[4] = {1, -1, 0, 0};  vector&lt;int&gt; areas;  void BFS(int startX, int startY){     queue&lt;pair&lt;int, int&gt;&gt; Queue;     Queue.push(make_pair(startX, startY));      int area = 1;      while(!Queue.empty()){         int currentX = Queue.front().first;         int currentY = Queue.front().second;         Queue.pop();          for(int i=0; i&lt;4; i++){             int nextX = currentX + dx[i];             int nextY = currentY + dy[i];              if(nextX &gt;= 0 &amp;&amp; nextX &lt; M &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; N){                 if(!visit[nextX][nextY] &amp;&amp; map[nextX][nextY] == 0){                     visit[nextX][nextY] = true;                     Queue.push(make_pair(nextX, nextY));                     area++;                 }             }         }     }      result++;     areas.push_back(area); }  int main(){     cin &gt;&gt; M &gt;&gt; N &gt;&gt; K;      bzero(map, sizeof(map));      for(int i=0; i&lt;K; i++){         int startX, startY, endX, endY;          cin &gt;&gt; startX &gt;&gt; startY &gt;&gt; endX &gt;&gt; endY;          for(int j=startY; j&lt;endY; j++){             for(int k=startX; k&lt;endX; k++){                 map[j][k] = 1;             }         }     }      for(int i=0; i&lt;M; i++){         for(int j=0; j&lt;N; j++){             if(!visit[i][j] &amp;&amp; map[i][j] == 0){                 visit[i][j] = true;                 BFS(i, j);             }         }     }      sort(areas.begin(), areas.end());     cout &lt;&lt; result &lt;&lt; '\\n';     for(int i=0; i&lt;areas.size(); i++){         cout &lt;&lt; areas[i] &lt;&lt; ' ';     }     cout &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["BFS"],
        "url": "keithlee94.github.io/algorithm/2583/",
        "teaser":null},{
        "title": "7562",
        "excerpt":"백준 7562번  Link: 7562번: 나이트의 이동     문제 설명  이번에도 BFS문제다.   기본적인 BFS문제와 다른 점은 나이트의 이동 반경을 전부 표시하려면 8가지의 경우의 수가 나온다는 점인데 이 8가지를 전부 고려해보고 이동시켜야 한다.   8가지 경우를 각 경우에 대해 다 찾아봐야 해서 시간초과 날줄 알았는데 정직하게 BFS 돌려도 시간내에 풀리는 문제였다.   답을 구하려면 BFS를 진행하며 거친 트리의 레벨을 구하면 되는데, 이 과정에서 어떻게 구현할지 고민을 많이 했던 것 같다.   보통 아는 BFS대로 하면 말도안되는 큰수가 나오더라.   어떻게할지 고민해보다 예전에 풀었던 BFS 문제 중 큐에 있는 모든 원소를 pop해서 저장한 다음, 그 모든 원소에 대해 각각 BFS를 진행하는 문제를 풀어본 기억이 났다.   그대로 적용해서 풀어보니 바로 풀렸다.   그 문제 풀때는 풀이방법을 모르겠어서 답을 봤던것 같은데, 이번에는 내가 직접 방법을 떠올려 구현하고 풀었다는 점은 발전 요소.   앞으로도 트리 레벨 구하는 유형은 이런식으로 풀면 될것 같다.    정답 코드  // // Created by Keith_Lee on 22/01/2019. //  #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;string.h&gt;  using namespace std;  int I; int result = 0;  int map[300][300]; bool visit[300][300];  int dx[8] = {-2, -1, 1, 2, -2, -1, 1, 2}; int dy[8] = {-1, -2, -2, -1, 1, 2, 2, 1};  void BFS(int startX, int startY, int endX, int endY){     queue&lt;pair&lt;int, int&gt;&gt; Queue;     Queue.push(make_pair(startX, startY));     visit[startX][startY] = true;      while(!Queue.empty()){         vector&lt;pair&lt;int, int&gt;&gt; currents;          while(!Queue.empty()){             int currentX = Queue.front().first;             int currentY = Queue.front().second;             Queue.pop();             currents.push_back(make_pair(currentX, currentY));         }          for(int q=0; q&lt;currents.size(); q++){             int currentX = currents[q].first;             int currentY = currents[q].second;              if(currentX == endX &amp;&amp; currentY == endY){                 return;             }              for(int i=0; i&lt;8; i++){                 int nextX = currentX + dx[i];                 int nextY = currentY + dy[i];                  if(nextX &gt;= 0 &amp;&amp; nextX &lt; I &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; I) {                     if(!visit[nextX][nextY]){                         visit[nextX][nextY] = true;                         Queue.push(make_pair(nextX, nextY));                     }                 }             }         }          result++;      } }  int main(){     int tc;     cin &gt;&gt; tc;      for(int test=0; test&lt;tc; test++){         bzero(visit, sizeof(visit));         result = 0;         cin &gt;&gt; I;          int startX, startY;         cin &gt;&gt; startX &gt;&gt; startY;          int endX, endY;         cin &gt;&gt; endX &gt;&gt; endY;          BFS(startX, startY, endX, endY);          cout &lt;&lt; result &lt;&lt; '\\n';     }      return 0; }    ","categories": ["Algorithm"],
        "tags": ["BFS"],
        "url": "keithlee94.github.io/algorithm/7562/",
        "teaser":null},{
        "title": "7569",
        "excerpt":"백준 7569번  Link: 7569번: 토마토     문제 설명  이번에도 BFS문제다.   저번에 컨디션 아주 별로였던날 한번 보고 어떻게풀지 감이 안와서 포기하고 삼성 기출문제 풀었었는데, 오늘은 마음잡고 제대로 들여다봤다.   백준에는 똑같은 이름의 조금 간단한 문제가 하나 있는데, 이 문제는 그 문제에서 3차원 공간에 대해 생각해보는 요소가 추가된 문제다.   Link: 7576번: 토마토   풀이 방법은 이 문제를 푸는 방법과 크게 다를게 없다.   그저께 풀었던 문제도 그랬는데, 이 문제나 저 문제도 BFS를 통해 트리를 탐색한다고 생각해볼때 몇개의 레벨을 탐색했는지 세면 되는 문제다.   우선 input값이 1인 것들을 visit했다고 표시한 다음 큐에 넣는다.   그리고 BFS를 진행하는데, 우선 트리의 레벨을 세기 위해 큐의 모든 요소들을 벡터에 따로 빼놓고 벡터의 요소들에 대한 BFS를 진행한다.   주의해야 할 점은 3차원적 요소도 고려해야 하는 만큼, 기존 4방향에 더해 위 상자, 아래 상자도 고려하며 구현해야 한다.   이외에는 기존 BFS와 다를 게 없다.   while문을 한번 끝낼때마다 결과값을 1씩 더해주는 식으로 완전탐색을 진행하면 답이 나온다.   나같은 경우에는 결과값의 초기값을 0으로 설정해뒀기 때문에 최종 결과 출력 전에 구한 결과값에서 1을 뺀 값이 맞는 값이다.   BFS가 끝난 후, map에 0이 남아있는지 세보고 결과값을 설정해준 다음 출력해주니 바로 풀렸다.   3차원 배열을 써야 풀릴것 같긴 했는데 시간초과나 메모리초과로 실패하지 않을까 고민하면서 구현했다.   실제로 돌려보니 메모리는 꽤 많이 사용하면서도 시간초과 없이 풀리는걸 보니 아주 무식하게 3차원 배열을 전부 탐색하며 푸는 문제가 맞았던 것 같다.    정답 코드  // // Created by Keith_Lee on 24/01/2019. //  #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt;  using namespace std;  int map[100][100][100] = {0, }; bool visit[100][100][100] = {false, };  int dx[4] = {0, 0, 1, -1}; int dy[4] = {1, -1, 0, 0}; int dz[2] = {-1, 1};  // 가로, 세로, 높이 int M, N, H; int result = 0;  queue&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; Queue;  void BFS(){     while(!Queue.empty()){         vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; starts;          while(!Queue.empty()){             starts.push_back(make_pair(Queue.front().first, make_pair(Queue.front().second.first, Queue.front().second.second)));             Queue.pop();         }          for(int v=0; v&lt;starts.size(); v++){             int startZ = starts[v].first;             int startX = starts[v].second.first;             int startY = starts[v].second.second;              for(int i=0; i&lt;4; i++){                 int nextX = startX + dx[i];                 int nextY = startY + dy[i];                  if(nextX &gt;= 0 &amp;&amp; nextX &lt; N &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; M){                     if(!visit[startZ][nextX][nextY] &amp;&amp; map[startZ][nextX][nextY] == 0){                         visit[startZ][nextX][nextY] = true;                         map[startZ][nextX][nextY] = 1;                         Queue.push(make_pair(startZ, make_pair(nextX, nextY)));                     }                 }             }              for(int i=0; i&lt;2; i++){                 int nextZ = startZ + dz[i];                  if(nextZ &gt;= 0 &amp;&amp; nextZ &lt; H){                     if(!visit[nextZ][startX][startY] &amp;&amp; map[nextZ][startX][startY] == 0){                         visit[nextZ][startX][startY] = true;                         map[nextZ][startX][startY] = 1;                         Queue.push(make_pair(nextZ, make_pair(startX, startY)));                     }                 }             }         }          result++;      }  }  int main(){     cin &gt;&gt; M &gt;&gt; N &gt;&gt; H;      // (층, (가로, 세로)) 쌍으로 저장한다.     vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; coordinates;      for(int i=0; i&lt;H; i++){         for(int j=0; j&lt;N; j++){             for(int k=0; k&lt;M; k++){                 cin &gt;&gt; map[i][j][k];                 if(map[i][j][k] == 1){                     visit[i][j][k] = true;                     Queue.push(make_pair(i, make_pair(j, k)));                 }             }         }     }      BFS();      for(int i=0; i&lt;H; i++){         for(int j=0; j&lt;N; j++){             for(int k=0; k&lt;M; k++){                 if(map[i][j][k] == 0){                     result = -1;                     break;                 }             }         }     }      if(result != -1){         cout &lt;&lt; result-1 &lt;&lt; '\\n';     }     else{         cout &lt;&lt; -1 &lt;&lt; '\\n';     }      return 0; }    ","categories": ["Algorithm"],
        "tags": ["BFS"],
        "url": "keithlee94.github.io/algorithm/7569/",
        "teaser":null},{
        "title": "10026",
        "excerpt":"백준 10026번  Link: 10026번: 적록색약     문제 설명  이번에도 BFS 문제.   각각의 색깔명에 대해 전체 map이 몇개의 영역으로 나눠지는지 구하는 문제였다.   한가지 특이했던 점은 적록색맹이라는 상황을 줌으로써 R값과 G값을 같은 값으로 보고 풀어야 하는 부분이 존재했다는 점.   적록색맹이 아닌 사람과 적록색맹인 사람의 경우를 따로 나눠 구해야 한다.   처음에는 map을 아예 새로 만들까 했었는데, 조건문에서 R과 G에 대한 조건을 or로 묶으니 굳이 안그래도 해결됐다.    정답 코드  // // Created by Keith_Lee on 28/01/2019. //  #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;string.h&gt;  using namespace std;  int N; char map[101][101]; bool visit[101][101];  int dx[4] = {0, 0, 1, -1}; int dy[4] = {1, -1, 0, 0};  int normalResult = 0; int redGreenResult = 0;  void BFS_normal(int startX, int startY){     queue&lt;pair&lt;int, int&gt;&gt; Queue;      Queue.push(make_pair(startX, startY));     visit[startX][startY] = true;      while(!Queue.empty()){         int currentX = Queue.front().first;         int currentY = Queue.front().second;         Queue.pop();          for(int i=0; i&lt;4; i++){             int nextX = currentX + dx[i];             int nextY = currentY + dy[i];              if(nextX &gt;= 1 &amp;&amp; nextX &lt;= N &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt;= N){                 if(map[startX][startY] == 'R'){                     if(map[nextX][nextY] == 'R' &amp;&amp; !visit[nextX][nextY]){                         visit[nextX][nextY] = true;                         Queue.push(make_pair(nextX, nextY));                     }                 }                 else if(map[startX][startY] == 'G'){                     if(map[nextX][nextY] == 'G' &amp;&amp; !visit[nextX][nextY]){                         visit[nextX][nextY] = true;                         Queue.push(make_pair(nextX, nextY));                     }                 }                 else if(map[startX][startY] == 'B'){                     if(map[nextX][nextY] == 'B' &amp;&amp; !visit[nextX][nextY]){                         visit[nextX][nextY] = true;                         Queue.push(make_pair(nextX, nextY));                     }                 }             }         }     }      normalResult++; }  void BFS_redGreen(int startX, int startY){     queue&lt;pair&lt;int, int&gt;&gt; Queue;      Queue.push(make_pair(startX, startY));     visit[startX][startY] = true;      while(!Queue.empty()){         int currentX = Queue.front().first;         int currentY = Queue.front().second;         Queue.pop();          for(int i=0; i&lt;4; i++){             int nextX = currentX + dx[i];             int nextY = currentY + dy[i];              if(nextX &gt;= 1 &amp;&amp; nextX &lt;= N &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt;= N){                 if(map[startX][startY] == 'R' || map[startX][startY] == 'G'){                     if((map[nextX][nextY] == 'R' || map[nextX][nextY] == 'G') &amp;&amp; !visit[nextX][nextY]){                         visit[nextX][nextY] = true;                         Queue.push(make_pair(nextX, nextY));                     }                 }                 else if(map[startX][startY] == 'B'){                     if(map[nextX][nextY] == 'B' &amp;&amp; !visit[nextX][nextY]){                         visit[nextX][nextY] = true;                         Queue.push(make_pair(nextX, nextY));                     }                 }             }         }     }      redGreenResult++; }  int main(){     cin &gt;&gt; N;      for(int i=1; i&lt;=N; i++){         for(int j=1; j&lt;=N; j++){             cin &gt;&gt; map[i][j];         }     }      for(int i=1; i&lt;=N; i++){         for(int j=1; j&lt;=N; j++){             if(!visit[i][j]){                 BFS_normal(i, j);             }         }     }      bzero(visit, sizeof(visit));      for(int i=1; i&lt;=N; i++){         for(int j=1; j&lt;=N; j++){             if(!visit[i][j]){                 BFS_redGreen(i, j);             }         }     }      cout &lt;&lt; normalResult &lt;&lt; ' ' &lt;&lt; redGreenResult &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["BFS"],
        "url": "keithlee94.github.io/algorithm/10026/",
        "teaser":null},{
        "title": "2644",
        "excerpt":"백준 2644번  Link: 2644번: 촌수계산     문제 설명  역시나 BFS문제.   저번에 풀었던 토마토 문제처럼, 이 문제도 트리 내에서 출발지와 목적지를 설정하여 목적지까지 도달하는데 거치는 트리 레벨을 세면 되는 문제였다.   주의해야할 점은 방향이 없는 그래프 문제였다는 점.   이외에는 다소 평이했던 문제였다…   라고 하기에는 막판에 뻘짓을 좀 했다.   도달할 수 없는 경우 -1로 처리하는 부분에서 살짝 헤맸던 것 빼고는 할만한 문제였다.    정답 코드  // // Created by Keith_Lee on 28/01/2019. //  #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt;  using namespace std;  int map[101][101] = {0, }; bool visit[101][101] = {false, };  int n;  int BFS(int start, int end){     int result = 0;      queue&lt;int&gt; Queue;     Queue.push(start);      while(!Queue.empty()){         vector&lt;int&gt; available;          while(!Queue.empty()) {             available.push_back(Queue.front());             Queue.pop();         }          for(int i=0; i&lt;available.size(); i++) {             int current = available[i];              for (int j = 1; j &lt;= n; j++) {                 if (map[current][j] == 1 &amp;&amp; !visit[current][j]) {                     visit[current][j] = true;                     visit[j][current] = true;                     Queue.push(j);                 }             }         }          result++;          for(int i=1; i&lt;=n; i++){             if(visit[end][i] &amp;&amp; visit[i][end]){                 return result;             }         }      } }  int main(){     cin &gt;&gt; n;      int start, end;     cin &gt;&gt; start &gt;&gt; end;      int m;     cin &gt;&gt; m;      for(int i=0; i&lt;m; i++){         int x, y;         cin &gt;&gt; x &gt;&gt; y;          map[x][y] = 1;         map[y][x] = 1;     }      int result = BFS(start, end);      bool find = false;     for(int i=1; i&lt;=n; i++){         if(visit[end][i] &amp;&amp; visit[i][end]){             find = true;         }     }      if(!find){         result = -1;     }      cout &lt;&lt; result &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["BFS"],
        "url": "keithlee94.github.io/algorithm/2644/",
        "teaser":null},{
        "title": "7th week summary",
        "excerpt":"알고리즘 스터디 내용 정리    백트래킹, BFS의 차이     BFS: 모든 경로를 추적해본다.   백트래킹: 추적하는 경로가 해결책이 될 수 없으면 더이상 그 경로를 따라가지 않는다.    Priority Queue     큐에 삽입할때 우선순위를 적용하여 재배치한다.   우선순위가 높은 것이 먼저 pop됨.   배열, 리스트, Heap으로 구현 가능 - Heap이 가장 적합.    연결 리스트, 배열     배열            순차 데이터에 적합       데이터 접근 속도가 빠르다.       단점: 배열 중간에 삽입/삭제시 shift 필요 - 시간 오래걸림, 크기 변경 불가.           연결리스트            비순차적 데이터에 적합       삽입, 삭제가 쉽다.       단점: 필요없는 데이터(front, end 등)가 있음, 데이터 접근속도가 느림.            연결 리스트 종류     List: 순서 있음, 중복 허용.            ArrayList                    배열과 유사           크기 변경 가능           배열 다음으로 접근속도가 빠르다.                       LinkedList                    노드 사용           비순차적 삽입, 삭제 가능           접근속도가 느리다.                           Set: 순서 없음, 중복 불가.            중복 삽입시 새로운 데이터를 저장하지 않음.       HashSet                    hashing기법을 통해 중복 확인(O(1))                       TreeSet                    Binary Search Tree를 사용하여 중복 확인(O(logN))                           Map: 순서 없음, 중복 불가. (키, 값) 쌍으로 데이터 저장.            중복 삽입시 기존의 데이터를 새 데이터로 덮어씀.       키 = 중복 불가, 값 = 중복 가능.       HashMap                    hashing기법을 통해 중복 확인(O(1))                       TreeMap                    Binary Search Tree를 사용하여 중복 확인(O(logN))                              TreeMap, TreeSet의 장점: 미리 정렬이 되어 있는 형태 =&gt; 정렬이 많이 필요하거나 자주 사용될 경우 유용하다.    Java 스터디 내용 정리    예외처리 방법     try ~ catch: 예외 발생 위치에서 바로 처리            try ~ catch ~ finally: 예외 발생 여부와 관계없이 finally는 항상 실행된다.(optional)           throws: 발생한 예외를 호출자로 위임하여 처리            메소드 선언시 사용.       throw: 실제 Exception 발생시 사용.       throws가 붙은 메소드는 반드시 예외처리 내용을 포함해야 한다.(try ~ catch나 if ~ else 등으로 구현)            Exception     상속관계 존재: 여러 Exception을 catch하고자 할 경우 부모타입 하나만 명시하여 여러 Exception들을 한번에 잡을 수 있다.   세분화 방법: 범위가 좁은 Exception -&gt; 넓은 Exception 순으로 코드 작성.   하나의 클래스이다 =&gt; 사용자가 별도로 정의할 수 있다.            정의 방법: 클래스 선언시 extends Exception을 붙인다.           상속관계에서 부모와 자식이 다른 종류의 Exception throw 가능            자식이 throw하는 Exception은 부모가 throw하는 Exception보다 범위가 좁거나 같아야 한다.(더 넓은 범위로 정의 불가)       부모는 Exception을 throw하고 자식은 throw하지 않는 방식도 구현 가능.            Stream     InputStream: 데이터를 받아들인다.   OutputStream: 데이터를 보낸다.   기본적으로 바이트 단위로 데이터 전송.   문자 처리: 바이트로 처리하기 어려우므로 InputStreamReader, OutputStreamWriter를 활용하여 처리한다.   사용 종료후 반드시 close해줘야 한다.    데이터 전송단위별 Stream 종류     byteStream: 1바이트에 코드값을 담아 전송하는 스트림. (InputStream/OutputStream)   characterStream: 2바이트에 코드값을 담아 전송하는 스트림. (InputStreamReader/OutputStreamWriter)    데이터 연결여부에 따른 Stream 종류     NodeStream: 데이터와 직접 연결되어 있는 스트림.   ProcessStream(FilterStream): NodeStream에서 데이터를 받아 가공하는 스트림.(일종의 필터 역할)    Scanner, BufferedReader 속도 차이 원인  Scanner는 1바이트씩 읽어오는 InputStream이고 BufferedReader는 2바이트씩 읽어오는 InputStreamReader이기 때문에 BufferedReader가 속도가 더 빠르다.    Serialization     객체를 스트림을 통해 이동시키려면 직렬화(Serialization) 조건을 만족시켜야 한다.   어떻게: 전송할 객체의 클래스가 Serializable 클래스를 implements 하면 된다. (객체를 배열로 만들어 전송하는 것)   역 직렬화: 직렬화된 배열을 객체로 복원하는 작업.    Thread     Process의 작은 실행 단위.   단독으로 존재할 수 없다: Process 내에 포함된다.   Thread 없이는 프로세스가 동작하지 않는다: 프로세스의 일꾼 역할.   Multi thread            프로그램 하나를 실행시켰을때 여러명의 일꾼이 일하는 것과 같다.       동시에 여러 작업을 나눠서 실행 가능.           장점            CPU의 활용률을 높일 수 있다.       응답성 향상: 작업 시간, 요구 성능에 따라 작업을 분리하여 병렬로 수행 가능.       프로세스 자원 공유: 효율성 향상(메모리 절약)           단점            Context Switching 비용 발생       Thread 제어의 어려움            Thread Life Cycle     New            Thread 객체가 생성된 상태.           Runnable            New 상태의 Thread에 대해 start() 메소드가 호출되면 Runnable 상태로 전환된다.       start() 메소드 호출: 필수로 실행되어야 하는 과정.       Race Condition: Runnable 상태의 Thread들 중 어떤 것이 먼저 실행될지 알 수 없다.           Running            JVM이 Thread의 run() 메소드를 호출하면 Thread 동작.       Thread의 sleep(), wait(), join() 메소드 호출시 Thread가 Waiting Pool로 이동하여 대기 상태로 전환된다.(Thread 동작 일시 정지)                    Runnable 상태로 전환되는 조건                            대기상태의 Thread의 sleep(), join() 시간이 종료되었을 경우               wait()에 대한 notify() 메소드가 호출된 경우               interrupt() 메소드가 호출된 경우               I/O가 종료된 경우                                                   동작중인 Thread에서 yield() 메소드 호출시 동작을 멈추고 Runnable 상태로 전환되어 다시 race condition에 들어간다.   Terminate            Thread의 run() 메소드가 종료되면 Terminate 상태로 전환됨.       한번 소멸한 Thread는 더이상 동작하지 않는다.                    다시 동작시키려면 Thread를 다시 생성하여 다시 동작시켜야 한다.                           Thread 구현     Runnable interface를 implements 하거나 extends 하면 된다. (이미 상속중인 다른 클래스가 있으면 implements하면 됨.)            Runnable을 implements한 경우                    객체는 Thread가 아니다: Runnable 객체이다.           Thread가 수행해야 하는 작업을 run() 메소드에 정의해야 한다.           여러 Thread가 하나의 Runnable 객체를 실행할수도 있고, 각자 다른 Runnable 객체를 실행할수도 있다. (하나의 Runnable 객체일 경우 자원 공유됨)                           Thread.run(): callback 메소드(사용자에 의해 직접 호출되지 않지만 특정 조건을 만족하면 자동으로 실행되는 메소드)            Thread의 run() 메소드를 호출하여 실행하면: main Thread가 실행하는 것.       Thread의 start() 메소드를 호출하여 자동 실행되면: run()이 정의된 클래스의 Thread가 실행하는 것.            Thread 구조        Runnable 객체를 직접 implements 하거나 Runnable 객체를 implements하는 Thread 클래스를 상속받는 두가지 형태 모두 가능.   Thread.run(): 아무 내용 없는 메소드(추상메소드나 다름없다.)            Thread를 상속한 클래스에서 반드시 오버라이딩해야 한다.       Thread 클래스를 추상클래스로 만들 수 없어 이런 형태로 만들어짐.           Thread 객체를 생성하려면 target 객체(Runnable 객체)를 넣어줄 것.            따로 안넣어주면 Thread.run()이 실행되어 아무 결과도 안나옴.            Thread 동기화 문제     데이터가 여러 Thread들에 의해 공유되어 발생.   예       int count = 0;   Thread t1, t2, t3;    public void run(){ // t1, t2, t3가 모두 같은 메소드 사용.       go();   }    /*   * 작업 과정   * 1. 현재 count값 읽기   * 2. 연산   * 3. 새로운 값 저장.   */   public void go(){       count++;       System.out.println(count);   }    =&gt; 각 thread의 접근 순서에 따라 다른 결과가 나온다.           해결: 공유하는 메소드에 synchronized 키워드를 붙인다.            public synchronized void go() {…}       한번에 한 Thread만 자원에 접근할 수 있으므로 순차실행 형태가 된다. (일종의 lock을 거는 것) - 꼭 필요한 부분에만 사용할것.       method뿐 아닌 객체에도 사용 가능. (run() 메소드에는 사용할 수 없다: run()은 오버라이딩된 메소드이므로)            Thread의 method     join(): 다른 Thread가 종료될때까지 join()을 호출하는 Thread가 대기한다.   notify(): Thread와 Thread간에 신호를 줄 때 사용 (깨울 메소드가 없으면 아무 동작도 안함)   wait(): 다른 Thread가 notify()를 호출하기 전까지 대기.      wait(), notify()는 synchronized 영역에서만 사용 가능.    Java 소켓 통신  Server     ServerSocket(port번호) 생성   ServerSocket.accept() 호출            클라이언트가 접속할대까지 기다리고, 클라이언트가 접속하면 클라이언트 소켓을 받아온다.       block되는 특징: 요구 조건(클라이언트의 접속)을 만족하지 않으면 이후 내용을 실행하지 않는다.           도착한 클라이언트 소켓으로부터 입출력 스트림을 얻어낸다.   스트림으로 메시지 전송   ServerSocket 닫기(close() 호출)   스트림 닫기   Client     Socket(서버 ip주소, 서버 port번호) 생성: 소켓 객체가 만들어지는 순간 서버에 접속된다.   생성한 Socket으로부터 입출력 스트림을 얻어낸다.   스트림으로 메시지 전송   Socket 닫기(close() 호출)   스트림 닫기  ","categories": ["Java"],
        "tags": ["Java"],
        "url": "keithlee94.github.io/java/7th-Week-Summary/",
        "teaser":null},{
        "title": "1062",
        "excerpt":"백준 1062번  Link: 1062번: 가르침     문제 설명  29일부터 풀기 시작해서 30일에서 31일 넘어가는 새벽에야 겨우 해결했던 문제.   내 답이 맞는것 같아 계속 고민하다 결국 답을 보고 해결했다.   답을 찾아보고서야 예전에 DFS를 통해 조합을 구하는 방법을 써서 문제를 풀때 어떤식으로 코드를 짰는지 떠오르더라.   정신승리를 좀 하자면, 시간초과가 났긴 했지만 어쨌든 답을 구할 수 있는 방법들을 최대한 생각해보고 여러 방법들을 비교해봤다는 점.   이러는 과정에서 시간초과를 수십번 본 것 같은데, 어떤 부분에서 시간초과가 일어나는지는 짚어냈다.   문제는 그 부분을 고치니 답이 틀렸다는 것.   이렇게 여러번 고민해봐도 도저히 안풀려서 답을 찾아보게 되었다.   답을 보고 나니 뭔가 매우 허무한 느낌이 들었다. 그동안 뭘 짜고 있었나 싶기도 하고.   답을 찾아내기 위해 삽질했던 시간들이 있었기 때문에 정답을 보고서도 이 부분은 나도 구현했는데 왜 틀렸을까 하는 생각이 들게 하였고 이 부분은 이래서 이렇게 짰구나 하는 생각도 들 수 있었던것 같다.   요며칠 단순한 BFS문제를 풀면서 이런식으로 DFS를 통해 조합을 구하고 백트래킹해야 풀리는 문제 푸는 연습을 해야겠다고 생각했는데, 이 문제가 전형적인 그런 문제였다.   시간 지나고 푸는 방법 까먹을때쯤 한번 더 풀어봐야겠다.    삽질했던 코드  #include &lt;iostream&gt; #include &lt;vector&gt;  using namespace std;  int result = 0; int N, K; int candidates[26] = {0, }; int words[50][26] = {0, };  int max(int a, int b){     return a &gt; b ? a : b; }  void searchTeach(int count, int index, int toTeach[26], int limit){     int tempResult = 0;      int temp[26];     for(int i=0; i&lt;26; i++){         temp[i] = toTeach[i];     }      if(candidates[index] == 1){         temp[index] = 1;     }      if(count == limit){         for(int i=0; i&lt;N; i++){             bool invalid = false;              for(int j=0; j&lt;26; j++){                 if(toTeach[j] - words[i][j] &lt; 0){                     invalid = true;                     break;                 }             }              if(!invalid){                 tempResult++;             }         }          result = max(result, tempResult);         return;     }      int next = 0;     for(int i=index+1; i&lt;26; i++){         if(candidates[i] == 1){             next = i;             break;         }     }      searchTeach(count+1, next, temp, limit);     searchTeach(count+1, next, toTeach, limit); }  void toTeach(){     for(int i=0; i&lt;N; i++){         for(int j=0; j&lt;26; j++){             if(candidates[j] != 1){                 candidates[j] = words[i][j];             }         }     } }  int main(){     string word;      cin &gt;&gt; N &gt;&gt; K;      for(int i=0; i&lt;N; i++){         cin &gt;&gt; word;          if(K &gt;= 5){             string temp = word.substr(4, word.length()-8);             for(int j=0; j&lt;temp.length(); j++){                 int current = temp[j] - 'a';                 if(current != 0 &amp;&amp; current != 2 &amp;&amp; current != 8 &amp;&amp; current != 13 &amp;&amp; current != 19){                     words[i][current] = 1;                 }             }         }     }      if(K &lt; 5){         result = 0;     }     else{         toTeach();          int input[26] = {0, };          for(int i=0; i&lt;26; i++){             if(candidates[i] == 1){                 searchTeach(0, i, input, K-5);                 candidates[i]--;             }         }          if(K == 5){             searchTeach(0, 0, input, K-5);         }     }      cout &lt;&lt; result &lt;&lt; '\\n';      return 0; }    정답 코드  // // Created by Keith_Lee on 30/01/2019. //  #include &lt;iostream&gt; #include &lt;vector&gt;  using namespace std;  int result = 0; int N, K;  string words[50]; bool visit[26];  int max(int a, int b){     return a &gt; b ? a : b; }  void searchTeach(int index, int count){     if(count == K-5){         int tempResult = 0;          for(int i=0; i&lt;N; i++){             bool invalid = false;              for(int j=0; j&lt;words[i].length(); j++){                 if(!visit[words[i][j] - 'a']){                     invalid = true;                     break;                 }              }              if(!invalid){                 tempResult++;             }         }          result = max(result, tempResult);         return;     }      for(int i=index; i&lt;26; i++){         if(!visit[i]){             visit[i] = true;             searchTeach(i, count+1);             visit[i] = false;         }     }  }  int main(){     cin &gt;&gt; N &gt;&gt; K;      for(int i=0; i&lt;N; i++){         cin &gt;&gt; words[i];          words[i] = words[i].substr(4, words[i].length()-8);     }      if(K &lt; 5){         result = 0;     }     else if(K == 26){         result = N;     }     else{         visit['a' - 'a'] = true;         visit['n' - 'a'] = true;         visit['t' - 'a'] = true;         visit['c' - 'a'] = true;         visit['i' - 'a'] = true;          searchTeach(0, 0);     }      cout &lt;&lt; result &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["Brute Force","Backtracking"],
        "url": "keithlee94.github.io/algorithm/1062/",
        "teaser":null},{
        "title": "2251",
        "excerpt":"백준 2251번  Link: 2251번: 물통     문제 설명  연휴 시작한 다음날 어떻게 풀지 고민하다 방법만 생각해두고 풀진 않았던 문제.   생각했던 풀이대로 풀어봤는데 우선 틀리고 시작했다.   알고리즘 분류는 BFS로 되어 있는데 굳이 BFS를 써야하나…?? 라는 생각이 좀 들었다.   아무튼 어거지로라도 BFS로 맞춰서 풀어보니 풀렸다.   통상 아는 BFS와는 좀 다른데, 우선 3개의 물통의 양을 전부 한번에 저장해야 한다는 점이 달랐고 길찾는 BFS는 for문 돌려서 4방향정도 생각해보는게 끝인데 이건 6가지 경우를 전부 하나씩 고려해야 한다는 점이 조금 달랐다.   BFS를 이렇게도 쓸수 있구나 하는 생각이 들게 된 문제.   한가지 더 특기하자면 구조체를 직접 정의하고 활용한 첫 문제인 것 같다.   예전에 한번 3가지였나 4가지 값을 큐에 넣고 썼던 적이 있던것 같은데 그때는 make_pair를 여러번 써서 무식하게 해결했던 것 같다.   구조체에 익숙해지면 훨씬 우아한 방법으로 해결 가능할듯 하다.   연휴 내내 놀았으니 이제 다시 또 꾸준히 풀어볼 작정이다.    어림도 없던 코드  // // Created by Keith_Lee on 07/02/2019. //  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt;  using namespace std;  int main(){     int A, B, C;      cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;      bool basket[201];      vector&lt;int&gt; possible;      if(C &gt; 0){         if(!basket[C]) {             possible.push_back(C);             basket[C] = true;         }     }      if(C - (C-A) &gt;= 0){         if(!basket[C-A] &amp;&amp; C-A &gt;= 0) {             possible.push_back(C - A);             basket[C-A] = true;         }     }      if(C - (C-B) &gt;= 0){         if(!basket[C-B] &amp;&amp; C-B &gt;= 0){             possible.push_back(C-B);             basket[C-B] = true;         }     }      if(C - A &gt;= 0){         if(!basket[A]){             possible.push_back(A);             basket[A] = true;         }     }      if(C - B &gt;= 0){         if(!basket[B]){             possible.push_back(B);             basket[B] = true;         }     }      sort(possible.begin(), possible.end());      for(int i=0; i&lt;possible.size(); i++){         cout &lt;&lt; possible[i] &lt;&lt; ' ';     }     cout &lt;&lt; '\\n';      return 0; }    정답 코드  // // Created by Keith_Lee on 07/02/2019. //  #include &lt;iostream&gt; #include &lt;queue&gt;  using namespace std;  struct water{     int a, b, c; };  int A, B, C; bool visit[201][201]; bool result[201];  void BFS(){     queue&lt;water&gt; Queue;     Queue.push({0, 0, C});      while(!Queue.empty()){         water current = Queue.front();         Queue.pop();          if(visit[current.a][current.b]){             continue;         }          visit[current.a][current.b] = true;          if(current.a == 0){             result[current.c] = true;         }          if(current.a + current.b &gt; B) { // A -&gt; B / A + B가 B보다 크면 B는 가득, A는 A + B - B의 용량만큼 찬다.             Queue.push({current.a + current.b - B, B, current.c});         }         else{ // A + B가 B보다 작으므로 A의 물을 전부 B로 붓는다.             Queue.push({0, current.a + current.b, current.c});         }          if(current.a + current.b &gt; A){ // B -&gt; A             Queue.push({A, current.a + current.b - A, current.c});         }         else{             Queue.push({current.a + current.b, 0, current.c});         }          if(current.a + current.c &gt; C){ // A -&gt; C             Queue.push({current.a + current.c - C, current.b, C});         }         else{             Queue.push({0, current.b, current.a + current.c});         }          if(current.a + current.c &gt; A){ // C -&gt; A             Queue.push({A, current.b, current.a + current.c - A});         }         else{             Queue.push({current.a + current.c, current.b, 0});         }          if(current.b + current.c &gt; C){ // B -&gt; C             Queue.push({current.a, current.b + current.c - C, C});         }         else{             Queue.push({current.a, 0, current.b + current.c});         }          if(current.b + current.c &gt; B){ // C -&gt; B             Queue.push({current.a, B, current.b + current.c - B});         }         else{             Queue.push({current.a, current.b + current.c, 0});         }     } }  int main(){     cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;      BFS();      for(int i=0; i&lt;201; i++){         if(result[i]){             cout &lt;&lt; i &lt;&lt; ' ';         }     }     cout &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["BFS"],
        "url": "keithlee94.github.io/algorithm/2251/",
        "teaser":null},{
        "title": "12100",
        "excerpt":"백준 12100번  Link: 12100번: 2048 (Easy)     문제 설명  일단 내 힘만으로 풀었다는 것부터 적고간다ㅋㅋㅋㅋ   DFS를 통해 모든 경우를 고려해봐야 하는 문제였다.   우선 DFS를 구현하기 전에 map을 어떤 식으로 밀고 같은 수를 합치면 되는지를 먼저 고민해봤다.   여러가지 방법을 생각해보던 중 벡터를 활용해서 옮겨야 하는 수들을 전부 집어넣고 옮긴 다음 옮겨진 수들을 합치는 방법을 생각해 봤다.   그런데 이 방법에는 큰 문제가 있는데, 옮기고 합친 다음 다시 옮겨야 한다는 점이었다.   이를 보완하기 위해 벡터에 옮겨야 하는 수들을 전부 넣고 map을 0으로 바꾼 다음, 그 수들을 비교해서 두 숫자가 같은 숫자이면 합치고 뒤의 숫자를 0으로 바꾼다.   이렇게 벡터의 내용을 바꿔준 다음, 별도로 큐를 정의하여 벡터를 한번 순회하며 0이 아닌 수를 만나면 큐에 넣는다.   마지막으로 옮기는 방향에 맞춰 큐의 내용대로 map을 바꿔주는 방법으로 구현하였다.   메모리상으로는 비효율적이겠지만, 중요한건 시간이니 넘어가자…   이렇게 옮기는 함수를 구현한 다음, DFS를 구현하였다.   이 과정에서 많이 고민했는데, 처음에는 DFS의 인자로 DFS 횟수와 map을 주는 방법으로 구현하였다.   이런식으로 하니 분명 모든 경우의 수를 따지긴 하지만 제출해보니 틀렸는데, 바로 map이 제대로 바뀌지 않는 것이 문제였다.   처음에는 DFS가 제대로 돌지 않는게 아닌가 싶어서 string으로 모든 경우를 다 출력해봤다. 확인 결과 모든 경우 따지는건 맞더라.   여기다 map도 같이 찍어보니 map이 제대로 안바뀌는 문제가 있다는 것을 찾아냈다.   이걸 어떻게 해야 해결할 수 있나 한참 고민하던 중, string으로 찍어본 결과를 이용해보자는 생각을 하게 되었다.   string에 찍힌 대로 DFS의 종료 조건에서 map을 바꾸는 방법을 생각해 냈고, 이대로 구현해보니 시간초과가 났다.   DFS 돌때마다 20*20짜리 배열을 계속 돈다고 생각해보면 시간초과 나는게 당연했다.   이 문제를 해결하기 위해 포인터를 사용했는데, 우선 20*20짜리 배열을 map과 같은 내용을 갖도록 초기화해준 다음 2차원 배열 포인터로 이 배열을 가리키도록 한다.   이 2차원 배열 포인터를 map 바꿔주는 함수의 인자로 전달하여 map을 5번 바꿔준 다음, 앞에서 만든 20*20짜리 배열의 내용을 갱신해준다. 또 갱신 과정에서 최대값도 같이 갱신해준다.   이런식으로 구현하여 제출하니 드디어 맞았다고 나왔다.   DFS로 모든 경우를 다 따져보기만 하면 풀리는 문제였다. 다만 그 경우를 따지기 위한 전처리가 상당히 까다로웠던 문제.   이제 DFS로 푸는 방법을 좀 이해한 것 같다.   문제 풀면서 막히는 부분에 대해 어느 부분에서 막히는지 직접 찾아내고 해결했다는 점에서 매우 뿌듯하다.   앞으로도 이렇게 내 힘만으로 풀어내는 문제들이 많이 있길!!    정답 코드  // // Created by Keith_Lee on 08/02/2019. //  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;queue&gt;  using namespace std;  int N; int result = 0; int map[20][20] = {0, };  string progress = \"MMMMM\";  int (*push(char direction, int (*tempMap)[20]))[20]{ // 이동시킨 후 바뀐 map 리턴.     // 상     if(direction == 'U'){         for(int i=0; i&lt;N; i++){             vector&lt;int&gt; toMove; // 위로 이동시킬 숫자들             queue&lt;int&gt; merge; // 이동 후 같은 숫자일때 합치고 저장              for(int j=0; j&lt;N; j++){                 if(tempMap[j][i] != 0){ // 위로 이동시킬 숫자가 있으면                     toMove.push_back(tempMap[j][i]); // 벡터에 넣고                     tempMap[j][i] = 0; // 숫자 자리를 0으로 만든다.                 }             }              for(int j=0; j&lt;toMove.size(); j++){                 if(j+1 &lt; toMove.size() &amp;&amp; toMove[j] == toMove[j+1]){ // 벡터 내에서 같은 숫자가 연속될 경우                     toMove[j] *= 2; // 합친다                     toMove[j+1] = 0; // 뒷 숫자를 0으로 만든다.                 }             }              for(int j=0; j&lt;toMove.size(); j++){ // 벡터를 돌면서                 if(toMove[j] != 0){ // 원소가 0이 아니면                     merge.push(toMove[j]); // 큐에 넣는다.                 }             }              int index = 0;              while(!merge.empty()){ // 큐를 돌면서                 tempMap[index][i] = merge.front(); // 바뀐 숫자를 맵에 반영한다.                 merge.pop();                 index++;             }         }     }      // 하     if(direction == 'D'){         for(int i=0; i&lt;N; i++){             vector&lt;int&gt; toMove; // 아래로 이동시킬 숫자들             queue&lt;int&gt; merge; // 이동 후 같은 숫자일때 합치고 저장              for(int j=N-1; j&gt;=0; j--){ // 아래쪽부터 돌거임                 if(tempMap[j][i] != 0){ // 아래로 이동시킬 숫자가 있으면                     toMove.push_back(tempMap[j][i]); // 벡터에 넣고                     tempMap[j][i] = 0; // 숫자 자리를 0으로 만든다.                 }             }              for(int j=0; j&lt;toMove.size(); j++){                 if(j+1 &lt; toMove.size() &amp;&amp; toMove[j] == toMove[j+1]){ // 벡터 내에서 같은 숫자가 연속될 경우                     toMove[j] *= 2; // 합친다                     toMove[j+1] = 0; // 뒷 숫자를 0으로 만든다.                 }             }              for(int j=0; j&lt;toMove.size(); j++){ // 벡터를 돌면서                 if(toMove[j] != 0){ // 원소가 0이 아니면                     merge.push(toMove[j]); // 큐에 넣는다.                 }             }              int index = 0;              while(!merge.empty()){ // 큐를 돌면서                 tempMap[N-1-index][i] = merge.front(); // 바뀐 숫자를 맵에 반영한다.                 merge.pop();                 index++;             }         }     }      // 좌     if(direction == 'L'){         for(int i=0; i&lt;N; i++){             vector&lt;int&gt; toMove; // 왼쪽으로 이동시킬 숫자들             queue&lt;int&gt; merge; // 이동 후 같은 숫자일때 합치고 저장              for(int j=0; j&lt;N; j++){                 if(tempMap[i][j] != 0){ // 왼쪽으로 이동시킬 숫자가 있으면                     toMove.push_back(tempMap[i][j]); // 벡터에 넣고                     tempMap[i][j] = 0; // 숫자 자리를 0으로 만든다.                 }             }              for(int j=0; j&lt;toMove.size(); j++){                 if(j+1 &lt; toMove.size() &amp;&amp; toMove[j] == toMove[j+1]){ // 벡터 내에서 같은 숫자가 연속될 경우                     toMove[j] *= 2; // 합친다                     toMove[j+1] = 0; // 뒷 숫자를 0으로 만든다.                 }             }              for(int j=0; j&lt;toMove.size(); j++){ // 벡터를 돌면서                 if(toMove[j] != 0){ // 원소가 0이 아니면                     merge.push(toMove[j]); // 큐에 넣는다.                 }             }              int index = 0;              while(!merge.empty()){ // 큐를 돌면서                 tempMap[i][index] = merge.front(); // 바뀐 숫자를 맵에 반영한다.                 merge.pop();                 index++;             }         }     }      // 우     if(direction == 'R'){         for(int i=0; i&lt;N; i++){             vector&lt;int&gt; toMove; // 오른쪽으로 이동시킬 숫자들             queue&lt;int&gt; merge; // 이동 후 같은 숫자일때 합치고 저장              for(int j=N-1; j&gt;=0; j--){ // 오른쪽부터 돌거임                 if(tempMap[i][j] != 0){ // 오른쪽으로 이동시킬 숫자가 있으면                     toMove.push_back(tempMap[i][j]); // 벡터에 넣고                     tempMap[i][j] = 0; // 숫자 자리를 0으로 만든다.                 }             }              for(int j=0; j&lt;toMove.size(); j++){                 if(j+1 &lt; toMove.size() &amp;&amp; toMove[j] == toMove[j+1]){ // 벡터 내에서 같은 숫자가 연속될 경우                     toMove[j] *= 2; // 합친다                     toMove[j+1] = 0; // 뒷 숫자를 0으로 만든다.                 }             }              for(int j=0; j&lt;toMove.size(); j++){ // 벡터를 돌면서                 if(toMove[j] != 0){ // 원소가 0이 아니면                     merge.push(toMove[j]); // 큐에 넣는다.                 }             }              int index = 0;              while(!merge.empty()){ // 큐를 돌면서                 tempMap[i][N-1-index] = merge.front(); // 바뀐 숫자를 맵에 반영한다.                 merge.pop();                 index++;             }         }     }      return tempMap; }  void DFS(int count){     if(count == 5){         int newMap[20][20] = {0, };         int (*temp)[20] = newMap;          for(int i=0; i&lt;N; i++){             for(int j=0; j&lt;N; j++){                 newMap[i][j] = map[i][j];             }         }          for(int i=0; i&lt;progress.length(); i++){             temp = push(progress[i], temp);         }          for(int i=0; i&lt;N; i++){             for(int j=0; j&lt;N; j++){                 newMap[i][j] = temp[i][j];                 if(newMap[i][j] &gt; result){                     result = newMap[i][j];                 }             }         }          return;     }      for(int i=1; i&lt;=4; i++){         if(i == 1){             progress[count] = 'U';         }         else if(i == 2){             progress[count] = 'D';         }         else if(i == 3){             progress[count] = 'L';         }         else if(i == 4){             progress[count] = 'R';         }         DFS(count+1);     } }  int main(){     cin &gt;&gt; N;      for(int i=0; i&lt;N; i++){         for(int j=0; j&lt;N; j++){             cin &gt;&gt; map[i][j];         }     }      DFS(0);      cout &lt;&lt; result &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["Brute Force","DFS"],
        "url": "keithlee94.github.io/algorithm/12100/",
        "teaser":null},{
        "title": "9663",
        "excerpt":"백준 9663번  Link: 9663번: N-Queen     문제 설명  많이들 알고있는 그 n-queen problem 문제다.   백트래킹 알고리즘의 교과서같은 문제로, 그냥 DFS 다돌리면 시간 부족해서 안풀릴 문제다.   짜다가 위키에 있는 소스코드를 봤는데, 내것보단 이게 훨씬 나아보여서 이걸 보고 이해하는 방향으로 했다.   내가 생각했던 것과의 가장 큰 차이점은 체스판을 1차원 배열로만 표현했다는 점.   1차원 배열로만 표현한 덕분에 2차원 배열을 순회하는 데 필요한 2중 for문을 단순 1중 for문으로 끝낼 수 있다는 시간적 이점이 있다.   대각선으로 다른 퀸이 있는지 검사하는 방법을 제일 이해하기 힘들었는데, 우선 지금까지 놓여진 퀸들에 대해 for문을 통해 검사한다.   이 for문의 iter 값은 곧 i번째 행 j번째 열에 퀸이 있는지를 표현하는 것이더라.   abs(count - j) == abs(i - map[j])는 count번째 행 i열의 대각 2방향(위쪽, 아래쪽 모두)에 퀸이 있는지 없는지 검사하는 내용이다.   이 if문에 걸리지 않았다면 퀸을 놓을 수 있는 것이므로 결과값을 1 증가시킨다.   만약 걸렸다면 즉시 for문을 나가고 바깥쪽 for문을 통해 다음 놓을 수 있는 자리를 찾는다.   이런식으로 반복하며 답을 찾는 문제다.   어제만해도 DFS문제에 대해 자신감이 좀 생겼는데 이 문제는 또 다른것 같다.   체스판을 1차원 배열로 표현하고 대각선방향 검사하는 코드만 봐도 아직 많이 모자라다는 걸 알 수 있었다.    정답 코드  // // Created by Keith_Lee on 10/02/2019. //  #include &lt;iostream&gt; #include &lt;stdlib.h&gt;  using namespace std;  int N; int map[14]; int result = 0;  void DFS(int count){     if(count == N){         result++;         return;     }      for(int i=0; i&lt;N; i++){         bool available = true;          for(int j=0; j&lt;count; j++){ // 지금까지 놓아진 퀸들을 검사한다.             if(map[j] == i || abs(count - j) == abs(i - map[j])){                 // map[j] == i: 새로운 퀸을 놓으려는 줄에 이미 다른 퀸이 있다.                 // abs(count - j) == abs(i - map[j]): 새로운 퀸을 놓으려는 위치의 대각선 방향에 이미 다른 퀸이 있다.                 available = false;                 break;             }         }          if(available){             map[count] = i;             // count열 i행에 퀸을 배치한다.             DFS(count+1);         }     } }  int main(){     cin &gt;&gt; N;      DFS(0);      cout &lt;&lt; result &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["Back Tracking"],
        "url": "keithlee94.github.io/algorithm/9663/",
        "teaser":null},{
        "title": "2309",
        "excerpt":"백준 2309번  Link: 2309번: 일곱 난쟁이     문제 설명  평범하게 모든 경우를 따져가며 조건 맞으면 출력해주는 DFS 문제였다.   9개 중 7개를 뽑아 합이 100이 될때 리턴해주면 되는 문제다.   요즘 DFS를 활용한 완전탐색 문제를 많이 접하는 것 같다.   이건 그중에서도 기초적인 문제인듯 하다.   분명 방학 시작 전까지는 이런 쉬운 문제도 쩔쩔매며 어떻게 풀지 고민했을 것 같은데, 어느새 아 이거 DFS로 조합 구해서 풀면 되는 문제네 하고 떠오를 수준이 되었다는 점이 마냥 신기하다.   이런식으로 DP도 정복하는 것이 목표이다.    정답 코드  // // Created by Keith_Lee on 11/02/2019. //  #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt;  using namespace std;  int littles[9] = {0, }; bool visit[9] = {false, }; vector&lt;int&gt; intermediate;  void DFS(int index, int count){     if(index == 9){         if(count == 7){             int sum = 0;              for(int i=0; i&lt;9; i++){                 if(visit[i]){                     sum += littles[i];                 }             }              if(sum == 100){                 for(int i=0; i&lt;9; i++){                     if(visit[i]){                         intermediate.push_back(littles[i]);                     }                 }             }         }          return;     }      visit[index] = true;     DFS(index+1, count+1);     visit[index] = false;     DFS(index+1, count); }  int main(){     for(int i=0; i&lt;9; i++){         cin &gt;&gt; littles[i];     }      DFS(0, 0);      vector&lt;int&gt; result;      for(int i=0; i&lt;7; i++){         result.push_back(intermediate[i]);     }      sort(result.begin(), result.end());      for(int i=0; i&lt;result.size(); i++){         cout &lt;&lt; result[i] &lt;&lt; '\\n';     }      return 0; }    ","categories": ["Algorithm"],
        "tags": ["Brute Force","DFS"],
        "url": "keithlee94.github.io/algorithm/2309/",
        "teaser":null},{
        "title": "14500",
        "excerpt":"백준 14500번  Link: 14500번: 테트로미노     문제 설명  최대 500*500의 지도 위에 블럭을 놓을 수 있는 모든 경우를 고려하여 블럭이 놓인 부분에 위치한 숫자 합의 최대값을 찾는 문제.   우선 블럭을 회전시키거나 대칭시켜보며 나올 수 있는 모든 경우를 생각해보았다.   다 해보니 꽤 많았는데, 19가지였다.   500*500짜리 지도에서 최악의 경우 500 * 500 * 19 = 4750000가지 경우를 전부 고려해봐야 하는데 이게 시간초과 안나고 가능할까? 라는 생각이 먼저 들었다.   처음에는 19가지 도형이 전부 들어갈 수 있는 최소한의 넓이인 4*4짜리 map을 따로 만들어 이걸로 맞춰볼 생각을 해봤는데, 이 안에서 나올 수 있는 19가지 도형의 위치 경우의 수를 구해보니 113가지가 되더라.   이건 아니다 싶어 결국 switch문 안에 19가지 경우를 전부 명시해서 넣고 3중 for문으로 돌렸다.   조건문이 19가지나 되다 보니 중간에 헷갈려서 조건 잘못쓴 경우도 있었고 계산식 잘못 넣은 경우도 있었다.   어찌어찌해서 다 잡아내고 돌려봤는데, 시간초과날줄 알았는데 잘 돌아가서 정답으로 나오더라.   DFS나 BFS처럼 알려진 방법 말고 이런 무식한 방법으로 풀리는 문제도 있구나 하는 생각이 들었다.   아마 시뮬레이션 문제를 풀게 된다면 이런 문제가 아닐까라는 생각도 들었고.   여튼 그리 깊게 생각하지 않아도 풀 수 있는 문제였다.    정답 코드  // // Created by Keith_Lee on 12/02/2019. //  #include &lt;iostream&gt;  using namespace std;  int N, M; int map[500][500] = {0, }; int result = 0;  int max(int a, int b){     return a &lt; b ? b : a; }  int main(){     cin &gt;&gt; N &gt;&gt; M;      for(int i=0; i&lt;N; i++){         for(int j=0; j&lt;M; j++){             cin &gt;&gt; map[i][j];         }     }      for(int i=0; i&lt;N; i++){         for(int j=0; j&lt;M; j++){             for(int shape=0; shape&lt;19; shape++) {                 int sum = 0;                  switch (shape) {                     case 0:                         if(j+3 &lt; M){                             sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i][j+3];                         }                         break;                     case 1:                         if(i+3 &lt; N){                             sum += map[i][j] + map[i+1][j] + map[i+2][j] + map[i+3][j];                         }                         break;                     case 2:                         if(i+1 &lt; N &amp;&amp; j+1 &lt; M){                             sum += map[i][j] + map[i+1][j] + map[i][j+1] + map[i+1][j+1];                         }                         break;                     case 3:                         if(i+2 &lt; N &amp;&amp; j+1 &lt; M){                             sum += map[i][j] + map[i+1][j] + map[i+2][j] + map[i+2][j+1];                         }                         break;                     case 4:                         if(i+2 &lt; N &amp;&amp; j-1 &gt;= 0){                             sum += map[i][j] + map[i+1][j] + map[i+2][j] + map[i+2][j-1];                         }                         break;                     case 5:                         if(i+1 &lt; N &amp;&amp; j+2 &lt; M){                             sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i+1][j];                         }                         break;                     case 6:                         if(i+1 &lt; N &amp;&amp; j+2 &lt; M){                             sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i+1][j+2];                         }                         break;                     case 7:                         if(i+2 &lt; N &amp;&amp; j+1 &lt; M){                             sum += map[i][j] + map[i][j+1] + map[i+1][j+1] + map[i+2][j+1];                         }                         break;                     case 8:                         if(i+2 &lt; N &amp;&amp; j+1 &lt; M){                             sum += map[i][j] + map[i][j+1] + map[i+1][j] + map[i+2][j];                         }                         break;                     case 9:                         if(i-1 &gt;= 0 &amp;&amp; j+2 &lt; M){                             sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i-1][j+2];                         }                         break;                     case 10:                         if(i+1 &lt; N &amp;&amp; j+2 &lt; M){                             sum += map[i][j] + map[i+1][j] + map[i+1][j+1] + map[i+1][j+2];                         }                         break;                     case 11:                         if(i+2 &lt; N &amp;&amp; j+1 &lt; M){                             sum += map[i][j] + map[i+1][j] + map[i+1][j+1] + map[i+2][j+1];                         }                         break;                     case 12:                         if(i-1 &gt;= 0 &amp;&amp; j+2 &lt; M){                             sum += map[i][j] + map[i][j+1] + map[i-1][j+1] + map[i-1][j+2];                         }                         break;                     case 13:                         if(i+2 &lt; N &amp;&amp; j-1 &gt;= 0){                             sum += map[i][j] + map[i+1][j] + map[i+1][j-1] + map[i+2][j-1];                         }                         break;                     case 14:                         if(i+1 &lt; N &amp;&amp; j+2 &lt; M){                             sum += map[i][j] + map[i][j+1] + map[i+1][j+1] + map[i+1][j+2];                         }                         break;                     case 15:                         if(i+1 &lt; N &amp;&amp; j+2 &lt; M){                             sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i+1][j+1];                         }                         break;                     case 16:                         if(i+2 &lt; N &amp;&amp; i-1 &gt;= 0 &amp;&amp; j+1 &lt; M){                             sum += map[i][j] + map[i][j+1] + map[i+1][j+1] + map[i-1][j+1];                         }                         break;                     case 17:                         if(i-1 &gt;= 0 &amp;&amp; j+2 &lt; M){                             sum += map[i][j] + map[i][j+1] + map[i-1][j+1] + map[i][j+2];                         }                         break;                     case 18:                         if(i+2 &lt; N &amp;&amp; j+1 &lt; M){                             sum += map[i][j] + map[i+1][j] + map[i+2][j] + map[i+1][j+1];                         }                         break;                 }                  result = max(sum, result);             }         }     }      cout &lt;&lt; result &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["Brute Force"],
        "url": "keithlee94.github.io/algorithm/14500/",
        "teaser":null},{
        "title": "9019",
        "excerpt":"백준 9019번  Link: 9019번: DSLR     문제 설명  예전에 풀어보다가 실패해서 그대로 접어뒀던 문제.   알고리즘 스터디에서 BFS문제집을 만들었는데 만드는 김에 한번 다시 풀어볼 생각으로 넣었다.   그리고 오늘 다시 풀어서 드디어 맞혔다.   우선 그전에 짰던 코드는 정말 터무니없는 코드였던 것 같다.   아예 새로운 마음으로 짰는데, 처음에 돌려봤을땐 메모리 초과가 났다.   메모리 초과가 날만한 여지들을 전부 없애보려고 큐를 전역변수로 만들어도 보고 큐를 싹 비워도 봤는데 메모리 초과가 잡히지 않더라.   질문게시판을 좀 찾아보던 중 나랑 비슷한 처지인 사람이 글을 올린걸 봤는데, 중복방문을 안하면 메모리 초과 문제를 해결할 수 있을 것이라는 답변을 보았다.   그런데 그대로 실천해보니 이번엔 답이 틀렸다.   무슨 문제일까 해서 모든 경우를 다 찍어봤는데, C++의 모듈러 연산과 내가 아는 모듈러 연산은 다르다는 점이 문제였다.   -1을 10000으로 모듈러 연산을 한다고 생각해보자.   모듈러 연산의 피연산자가 음수이므로 답은 9999가 되어야 한다.   그런데 코드로 옮겨 보니, 9999가 아니라 -1이 그대로 나오더라.   사실 문제 조건에도 -1이 나올 경우 9999로 만들라는 조건이 있었는데, 음수에 대한 모듈러 연산 한번이면 다 해결될줄 알았다.   이 부분까지 잡아내고 돌려보니 바로 맞았다.   내가 아는 상식과 컴퓨터의 연산 방식이 다르다는 점을 알게 된 문제였다.   또, 난 보통 BFS문제를 풀때 방문 여부를 체크해주는 것을 자주 까먹는편인데 시간도 시간이지만 메모리상으로도 문제가 발생할 수 있다는 점을 알게 되었다.   앞으로 BFS문제를 풀때는 방문 여부 체크하는 부분을 빼먹지 말아야겠다.    정답 코드  // // Created by Keith_Lee on 13/02/2019. //  #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;strings.h&gt;  using namespace std;  int T; int A, B; string result;  bool visit[10000] = {false, }; char delta[4] = {'D', 'S', 'L', 'R'};  queue&lt;pair&lt;int, string&gt;&gt; Queue;  void BFS(){     Queue.push(make_pair(A, \"\"));     visit[A] = true;      while(!Queue.empty()){         int current = Queue.front().first;         string currentAnswer = Queue.front().second;         Queue.pop();          if(current == B){             result = currentAnswer;             break;         }          for(int i=0; i&lt;4; i++){             int next = 0;             string temp = \"\";             if(delta[i] == 'D'){                 next = (current * 2) % 10000;             }             else if(delta[i] == 'S'){                 if(current - 1 &gt;= 0){                     next = (current - 1) % 10000;                 }                 else{                     next = 9999;                 }             }             else if(delta[i] == 'L'){                 next += (current % 1000) * 10;                 next += current / 1000;             }             else if(delta[i] == 'R'){                 next += current / 10;                 next += (current % 10) * 1000;             }              if(!visit[next]){                 visit[next] = true;                 temp += delta[i];                 Queue.push(make_pair(next, currentAnswer + temp));             }         }     } }  int main(){     cin &gt;&gt; T;      for(int test=0; test&lt;T; test++){         result = \"\";         bzero(visit, sizeof(visit));          cin &gt;&gt; A &gt;&gt; B;          BFS();          while(!Queue.empty()){             Queue.pop();         }          cout &lt;&lt; result &lt;&lt; '\\n';     }      return 0; }    ","categories": ["Algorithm"],
        "tags": ["Brute Force","BFS"],
        "url": "keithlee94.github.io/algorithm/9019/",
        "teaser":null},{
        "title": "16235",
        "excerpt":"백준 16235번  Link: 16235번: 나무 재테크     문제 설명  작년 삼성 기출문제.   IM쪽 기출문제였는데, 여기 시험보고 온 친구들이 전부 못풀어서 멘탈 터져서 온게 기억이 난다.   풀기 시작한게 목요일이었는데, 목요일에는 별 생각없는 노가다로 풀어봤는데 테스트케이스 3개정도 맞히고 나머지 못맞혀서 왜그럴지 고민해봤다.   그렇게 고민해보다 금요일에는 큐를 써서 한 레벨에 대해 전부 뽑아내고 1년을 진행하는 방식으로 해봤다.   그래도 안풀려서 다시 고민했는데, 토요일엔 놀다가 일요일 와서야 풀었다.   매우 단순한 방법으로 해결했는데, 내가 짠 코드대로면 봄에 죽은 나무가 벡터에서는 살아있기 때문에 죽은 나무의 나이를 -1로 바꾸고, 가을에 번식하는 조건에 나이가 0보다 클때로 한정함으로써 풀 수 있었다.   시뮬레이션 문제인것 같은데, 내가 시험볼때 풀어봤던 큐브 문제에 비해서는 훨씬 깔끔하게 답을 구할 수 있었던 문제인것 같다.   뭐 그때의 나였다면 이런 문제 던져줘도 못풀었을것 같긴 하다만…   어쨌든 곧 시험볼때까지 실력을 꾸준히 키워야겠다는 생각이 든다.    정답 코드  // // Created by Keith_Lee on 14/02/2019. //  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;algorithm&gt;  using namespace std;  struct Tree{     int x, y, age; };  int N, M, K;  int map[11][11] = {0, }; int winterAdd[11][11] = {0, }; int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}; int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};  queue&lt;Tree&gt; Queue;  int compare(const Tree &amp;t1, const Tree &amp;t2){     if(t1.age &lt; t2.age){         return true;     }     return false; }  int BFS(){     for(int i=0; i&lt;K; i++){         vector&lt;Tree&gt; lives;         vector&lt;Tree&gt; deads;          while(!Queue.empty()){             lives.push_back(Queue.front());             Queue.pop();         }          sort(lives.begin(), lives.end(), compare);          for(int j=0; j&lt;lives.size(); j++) {             if (map[lives[j].x][lives[j].y] &gt;= lives[j].age) { // 봄                 map[lives[j].x][lives[j].y] -= lives[j].age;                 Queue.push({lives[j].x, lives[j].y, lives[j].age + 1});                 lives[j].age++;             }             else {                 deads.push_back({lives[j].x, lives[j].y, lives[j].age});                 lives[j].age = -1;             }              if(lives[j].age &gt; 0 &amp;&amp; lives[j].age % 5 == 0){ // 가을                 for(int k=0; k&lt;8; k++){                     int nextX = lives[j].x + dx[k];                     int nextY = lives[j].y + dy[k];                      if(nextX &gt; 0 &amp;&amp; nextX &lt;= N &amp;&amp; nextY &gt; 0 &amp;&amp; nextY &lt;= N){                         Queue.push({nextX, nextY, 1});                     }                 }             }         }          for(int k=0; k&lt;deads.size(); k++){ // 여름             map[deads[k].x][deads[k].y] += deads[k].age / 2;         }          for(int k=1; k&lt;=N; k++){ // 겨울             for(int l=1; l&lt;=N; l++){                 map[k][l] += winterAdd[k][l];             }         }     }      return Queue.size(); }  int main(){     for(int i=0; i&lt;=10; i++){         for(int j=0; j&lt;=10; j++){             map[i][j] = 5;         }     }      cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;      for(int i=1; i&lt;=N; i++){         for(int j=1; j&lt;=N; j++){             cin &gt;&gt; winterAdd[i][j];         }     }      int x, y, z;      for(int i=0; i&lt;M; i++){         cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;          Queue.push({x, y, z});     }      cout &lt;&lt; BFS() &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["Simulation","Brute Force"],
        "url": "keithlee94.github.io/algorithm/16235/",
        "teaser":null},{
        "title": "1931",
        "excerpt":"백준 1931번  Link: 1931번: 회의실배정     문제 설명  Greedy 알고리즘의 대표격인 문제다.   예전에 한번 풀어봤던것 같긴 한데 그때도 틀렸다.   마음 다잡고 다시한번 풀어봤는데, 답이 맞는것 같으면서도 계속 틀렸다고 나오더라.   어떤 부분에서 문제가 있나 해서 질문게시판 돌아다니면서 반례들을 찾아봤는데, 크게 2가지 문제가 있었다.   첫번째는 끝나는 시간이 같은 경우 시작하는 시간이 빠른 회의가 먼저 오도록 정렬되어야 한다는 점.   두번째는 배정 가능한 회의에 포함시킬때 그 회의를 포함하였음을 표시하여 중복으로 포함시켜선 안된다는 점.   첫번째 문제는 정렬 함수를 좀 바꿔서 해결했다.   두번째 문제는 방문 여부를 어떻게 표시할지 고민하다 1부터 2147483647까지의 bool형태의 배열을 만들까 해봤다.   용량이 용량이라 그런지 컴파일 자체가 안되더라.   어떻게할지 고민하다가 구조체에 방문 여부도 포함하도록 바꿔서 제출해보니 바로 맞았다.   Greedy나 BFS나 DFS나 방문여부 표시해주는게 참 중요한 것 같다.   몇년전부터 못풀던 문제였는데 오늘에서라도 풀어서 기분은 좋다.    정답 코드  // // Created by Keith_Lee on 18/02/2019. //  #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt;  using namespace std;  struct meeting{     int start, end;     bool visit; };  int N;  bool compare(meeting a, meeting b){     if(a.end &lt; b.end){         return true;     }     else if(a.end == b.end){         if(a.start &lt; b.start){             return true;         }     }     return false; }  int main(){     cin &gt;&gt; N;      vector&lt;meeting&gt; meetings;      int start, end;      for(int i=0; i&lt;N; i++){         cin &gt;&gt; start &gt;&gt; end;          meetings.push_back({start, end, false});     }      sort(meetings.begin(), meetings.end(), compare);      vector&lt;meeting&gt; available;     available.push_back(meetings[0]);     meetings[0].visit = true;      for(int i=0; i&lt;meetings.size(); i++){         int currentEnd = available[available.size()-1].end;          if(meetings[i].start &gt;= currentEnd &amp;&amp; !meetings[i].visit){             available.push_back(meetings[i]);         }     }      cout &lt;&lt; available.size() &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["Greedy"],
        "url": "keithlee94.github.io/algorithm/1931/",
        "teaser":null},{
        "title": "1946",
        "excerpt":"백준 1946번  Link: 1946번: 신입 사원     문제 설명  오늘도 Greedy문제.   문제 이해하는데 시간이 좀 오래걸렸다.   이해하고 나서 풀어보려는데 처음에는 두 등수의 평균을 구한 다음 평균이 높은 절반끼리 비교하는 방식으로 구현했는데, 일단 시간초과가 났다.   방문 여부를 표시하고 조건에 안맞으면 반복문 중간에서 나가는 방식으로 보완했는데, 이렇게 푸니까 이젠 답이 틀리더라.   그 다음엔 각각의 등수가 1인 경우들은 반드시 포함시키고, 이 둘에 대해 비교하며 카운트를 늘려가는 방식으로 풀어봤는데, 역시 틀렸다.   한참 고민하며 반례 찾으러 질문게시판에 들어가봤는데, 반례 찾다가 다른사람의 아이디어를 보고 힌트를 얻어 풀 수 있었다.   핵심은 한가지 등수로 오름차순 정렬을 하는 것.   이렇게 하면 두가지 등수 중 한가지 등수만 비교하면 풀린다.   나머지 한 등수에 대해 정답에 포함시킨 바로 앞 등수보다 크면 포함시키지 않고, 반대의 경우 작은 등수로 바꿔주고 카운트를 하나 늘린 후 이를 반복하는 방식으로 풀 수 있었다.   아이디어를 짜내보려고 노력한 것까지는 좋았던 것 같으나 핵심을 찾는데에는 도달하지 못했다.   심지어 한가지 등수로 오름차순 정렬하는것까지는 했는데 그 다음을 생각해내지 못했다는 점이 아쉬웠다.    정답 코드  // // Created by Keith_Lee on 19/02/2019. //  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt;  using namespace std;  struct candidates{     int doc, interview; };  bool compare(candidates &amp;a, candidates &amp;b){     if(a.doc &gt; b.doc){         return false;     }     return true; }  int main(){     int T;      cin &gt;&gt; T;      for(int test=0; test&lt;T; test++){         int N;          cin &gt;&gt; N;          vector&lt;candidates&gt; applicants;          for(int i=0; i&lt;N; i++){             int doc, interview;              cin &gt;&gt; doc &gt;&gt; interview;              applicants.push_back({doc, interview});         }          sort(applicants.begin(), applicants.end(), compare);          int count = 1;          int standard = applicants[0].interview;          for(int i=1; i&lt;applicants.size(); i++){             if(standard &gt; applicants[i].interview){                 standard = applicants[i].interview;                 count++;             }         }          cout &lt;&lt; count &lt;&lt; '\\n';     }      return 0; }    ","categories": ["Algorithm"],
        "tags": ["Greedy"],
        "url": "keithlee94.github.io/algorithm/1946/",
        "teaser":null},{
        "title": "2250",
        "excerpt":"백준 2250번  Link: 2250번: 트리의 높이와 너비     문제 설명  이번엔 DFS 문제다.   문제 보고나서 트리 그리는 규칙 이해하는데만 한참 걸린것 같다.   아무튼 이해하고 나서 트리를 직접 그려가면서 규칙을 찾아봤는데,           우선 루트부터 찾은 다음 시작            루트 기준으로 왼쪽 방향으로 DFS시 만나는 가장 마지막 노드가 트리의 가장 왼쪽 노드            루트 기준으로 오른쪽 방향으로 DFS시 만나는 가장 마지막 노드가 트리의 가장 오른쪽 노드            루트 왼쪽 자식에서 오른쪽으로 DFS시 만나는 가장 마지막 노드가 루트 바로 왼쪽 노드            루트 오른쪽 자식에서 왼쪽으로 DFS시 만나는 가장 마지막 노드가 루트 바로 오른쪽 노드       이렇게 5가지 규칙을 찾았다.   이 규칙대로 트리를 만들고 문제를 풀어보려 했는데, 생각처럼 되지 않았다.   이 5가지 말고 내가 놓치고 있는 부분이 무엇인지 계속 생각해봤는데, 한가지 큰 부분을 놓치고 있었다.   이 트리를 그리는 규칙이 트리를 inorder 방식으로 탐색하는 순서와 같다는 점.   이 규칙 찾는데 하루는 더 걸린것 같다.   찾고 나니 푸는데 걸리는 시간은 순식간이었다.   트리의 각 노드들의 레벨만 구하면 되니까.   이 문제 알고리즘 분류가 DFS, 트리였는데 BFS를 넣어야 되지 않나 하는 생각도 들었다.   레벨 찾는데 사용한 알고리즘이 BFS였기 때문.   풀고 나니 나에게 실망스러웠는데, 그새 inorder, preorder, postorder 방식으로 트리 탐색하는 알고리즘을 까먹었다는 점 때문이다.   평소에 잘 알고 있었다면 트리 그리는 규칙 보자마자 아 이거 루트 찾아서 inorder로 탐색하면 끝나는 문제구나 했을텐데…   아무튼 늦게라도 떠올랐다는것 자체는 신기할 따름이다.   아직 갈길이 멀다는 생각밖에 안든다…    정답 코드  // // Created by Keith_Lee on 21/02/2019. //  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;algorithm&gt;  using namespace std;  struct Node{     int num = -1;     int left = 0;     int right = 0;     int parent = -1;     int level = -1;     int location = 0; };  int N; int lastLevel = 0; // 트리 최대 레벨 int place = 1;  Node nodeTree[10001]; // 입력따라 트리 저장할 공간 bool visit[10001] = {false, };  void inOrder(int start){     if(!visit[nodeTree[start].left]){         inOrder(nodeTree[start].left);     }      nodeTree[start].location = place++;     visit[start] = true;      if(!visit[nodeTree[start].right]){         inOrder(nodeTree[start].right);     } }  void BFS(Node start){ // 각 노드들의 레벨을 찾는다.     int level = 1;     queue&lt;Node&gt; Queue;     vector&lt;Node&gt; nodes;      Queue.push(start);      while(!Queue.empty()){         nodes.clear();          while(!Queue.empty()){             Node temp = Queue.front();             Queue.pop();             nodes.push_back(temp);         }          for(int i=0; i&lt;nodes.size(); i++){             Node current = nodes[i];             nodeTree[current.num].level = level;              if(current.left != -1){                 Queue.push(nodeTree[current.left]);             }             if(current.right != -1){                 Queue.push(nodeTree[current.right]);             }         }          level++;     } }  int main(){     visit[0] = true;     cin &gt;&gt; N;      int nodeNum;     int leftChild;     int rightChild;      for(int i=1; i&lt;=N; i++){         cin &gt;&gt; nodeNum &gt;&gt; leftChild &gt;&gt; rightChild;          nodeTree[nodeNum].num = nodeNum;         if(leftChild == -1){             nodeTree[nodeNum].left = 0;         }         else{             nodeTree[nodeNum].left = leftChild;             nodeTree[leftChild].parent = nodeNum;         }          if(rightChild == -1){             nodeTree[nodeNum].right = 0;         }         else{             nodeTree[nodeNum].right = rightChild;             nodeTree[rightChild].parent = nodeNum;         }     }      int root = 0;      for(int i=1; i&lt;=N; i++){         if(nodeTree[i].parent == -1){             root = nodeTree[i].num;             break;         }     }      BFS(nodeTree[root]); // 각 노드의 레벨을 지정한다.      inOrder(root);      for(int i=1; i&lt;=N; i++){         if(lastLevel &lt; nodeTree[i].level){             lastLevel = nodeTree[i].level;         }     }      int maxWidth = 0;     int maxLevel = 0;      vector&lt;int&gt; levels;     for(int i=1; i&lt;=lastLevel; i++){         levels.clear();          for(int j=1; j&lt;=N; j++){             if(nodeTree[j].level == i){                 levels.push_back(nodeTree[j].location);             }         }          sort(levels.begin(), levels.end());          int width = levels[levels.size()-1] - levels[0] + 1;          if(maxWidth &lt; width){             maxLevel = i;             maxWidth = width;         }     }      cout &lt;&lt; maxLevel &lt;&lt; ' ' &lt;&lt; maxWidth &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DFS","Tree","BFS"],
        "url": "keithlee94.github.io/algorithm/2250/",
        "teaser":null},{
        "title": "1309",
        "excerpt":"백준 1309번  Link: 1309번: 동물원     문제 설명  오늘은 DP를 배워서 이제 한동안 DP문제에 매달릴 예정이다.   그 중에서도 아주 간단한 문제를 하나 풀었다.   정말 기본적인 문제라고 할 수 있는데, 몇개 케이스 따져보며 규칙 찾으면 바로 풀리는 문제다.   역시 DP문제답게 규칙만 찾으면 구현은 간단히 끝난다.   이번 기회에 DP에 대해 확실히 정복하고 갈 작정이다.   여전히 갈길이 멀지만, 화이팅.    정답 코드  /// // Created by Keith_Lee on 25/02/2019. //  #include &lt;iostream&gt; #include &lt;strings.h&gt;  using namespace std;  int N;  long long zoo(int n){     long long DP[n+1];     bzero(DP, sizeof(DP));      DP[0] = 0;     DP[1] = 3;     DP[2] = 7;      for(int i=3; i&lt;=n; i++){         DP[i] = (2 * DP[i-1] + DP[i-2]) % 9901;     }      return DP[n]; }  int main(){     cin &gt;&gt; N;      cout &lt;&lt; zoo(N) &lt;&lt; '\\n'; }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "keithlee94.github.io/algorithm/1309/",
        "teaser":null},{
        "title": "11060",
        "excerpt":"백준 11060번  Link: 11060번: 점프 점프     문제 설명  역시 DP문제다.   옆에서 친구가 풀던 문제여서 한번 풀어봤는데, 앞에서 풀었던 문제에서 찾아낸 규칙과 유사한 규칙으로 풀린다는 점을 알아냈다.   될까 해서 돌려보니 역시 성공.   이번에도 코드는 정말 짧다.   하루에 DP를 2문제나 풀어내다니 내 자신이 살짝 놀랍다.   이런식으로 DP에 대한 두려움을 좀 없앨 수 있으면 좋겠다.    정답 코드  // // Created by Keith_Lee on 26/02/2019. //  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;strings.h&gt;  using namespace std;  int N;  int map[1001]; int DP[1001];  int min(vector&lt;int&gt; v){     int result = 99999;      for(int i=0; i&lt;v.size(); i++){         if(result &gt; v[i]){             result = v[i];         }     }      return result; }  int main(){     bzero(DP, sizeof(DP));     bzero(map, sizeof(map));     cin &gt;&gt; N;      for(int i=1; i&lt;=N; i++){         cin &gt;&gt; map[i];     }      for(int i=2; i&lt;=N; i++){         vector&lt;int&gt; temp;          for(int j=1; j&lt;i; j++){             if(j + map[j] &gt;= i){                 temp.push_back(DP[j] + 1);             }         }          DP[i] = min(temp);     }      if(DP[N] == 99999){         DP[N] = -1;     }      cout &lt;&lt; DP[N] &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "keithlee94.github.io/algorithm/11060/",
        "teaser":null},{
        "title": "1890",
        "excerpt":"백준 1890번  Link: 1890번: 점프     문제 설명  오늘도 DP문제.   옆에서 친구가 풀던거 같이 한번 풀어봤는데, 조금 고전했다.   처음에는 BFS로 풀어보려고 했는데 문제 자체가 BFS로 풀기에는 조건이 적당하지 않아서 무한루프로 끝났다.   다른 방법으로 풀 수 있는지 찾아보던 중 어떻게든 규칙을 찾아서 DP로 풀어야겠다는 생각을 했고, 고민끝에 규칙을 찾아 샘플 케이스를 돌려보니 맞았다.   구현하는데 인덱스가 헷갈려서 살짝 애먹긴 했지만 무난히 맞았다.    정답 코드  // // Created by Keith_Lee on 26/02/2019. //  #include &lt;iostream&gt;  using namespace std;  int N;  int map[101][101] = {-1, }; long long DP[101][101] = {0, };  int main(){     cin &gt;&gt; N;      for(int i=1; i&lt;=N; i++){         for(int j=1; j&lt;=N; j++){             cin &gt;&gt; map[i][j];         }     }      DP[1][1] = 1;      for(int i=1; i&lt;=N; i++){         for(int j=1; j&lt;=N; j++){             if(i == j &amp;&amp; i == 0){                 continue;             }              for(int k=0; k&lt;j; k++){                 if(k + map[i][k] == j){                     DP[i][j] += DP[i][k];                 }             }              for(int k=0; k&lt;i; k++){                 if(k + map[k][j] == i){                     DP[i][j] += DP[k][j];                 }             }         }     }  //    for(int i=1; i&lt;=N; i++){ //        for(int j=1; j&lt;=N; j++){ //            cout &lt;&lt; DP[i][j] &lt;&lt; ' '; //        } //        cout &lt;&lt; '\\n'; //    }      cout &lt;&lt; DP[N][N] &lt;&lt; '\\n'; }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "keithlee94.github.io/algorithm/1890/",
        "teaser":null},{
        "title": "11058",
        "excerpt":"백준 11058번  Link: 11058번: 크리보드     문제 설명  이번에도 DP 문제.   예전에 풀었어야 했는데 그땐 DP에 대해 너무 자신이 없어서 쫄아서 패스했던 기억이 난다.   이번에 DP를 제대로 공부하는 김에 풀어봤는데, 생각보다 금방 점화식을 찾아냈다.   물론 여러번 시도해보긴 했지만, 생각했던 점화식이 맞았다.   점화식에 대해 설명하자면 다음과 같다.   현재의 DP 인덱스가 i라고 가정하자.   우선 A만 누르는 경우는 직전 DP값에다 1을 더한 값이다.   이는 곧 DP[i] = DP[i-1] + 1과 같다.   이 다음부터가 꽤 복잡한데, 경우는 다음과 같다.   1) 현재 기준 3번 전 DP에서 Ctrl + A를 눌러 그때 입력된 A들을 모두 선택하고, 2번 전 DP에서 Ctrl + C를 눌러 선택된 것을 복사한 다음 1번 전 DP에서 Ctrl + V를 눌러 복사된 내용을 붙여넣는 경우   이는 곧 DP[i-3]에다가 DP[i-3]을 한번 더 쓰는 것과 같다.   따라서 DP[i] = 2 * DP[i-3] 이다.   2) 현재 기준 4번 전 DP에서 Ctrl + A를 눌러 그때 입력된 A들을 모두 선택하고, 3번 전 DP에서 Ctrl + C를 눌러 선택된 것을 복사한 다음 2번 전, 1번 전 DP에서 Ctrl + V를 눌러 복사된 내용을 붙여넣는 경우   이는 곧 DP[i-4]를 3번 쓰는 것과 같으므로, DP[i] = 3 * DP[i-4] 이다.   이 과정을 DP[0] * (i-1)까지 반복한다.   이 모든 경우의 수들의 최대값이 현재 DP값이 된다.   정답을 얻기 위해 예전 정답을 쌓아 나간다는 생각을 어거지로라도 하다 보니 점화식이 조금은 보이는 것 같다.   이런식으로 DP를 정복할 수 있을것 같다는 자신감을 좀 갖게 해준 문제였다.    정답 코드  // // Created by Keith_Lee on 26/02/2019. //  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;strings.h&gt;  using namespace std;  int N; long long DP[101];  long long max(vector&lt;long long&gt; v){     long long result = -1;      for(int i=0; i&lt;v.size(); i++){         if(v[i] &gt; result){             result = v[i];         }     }      return result; }  int main(){     cin &gt;&gt; N;      bzero(DP, sizeof(DP));      DP[0] = 0;     DP[1] = 1;     DP[2] = 2;     DP[3] = 3;     DP[4] = 4;     DP[5] = 5;     DP[6] = 6;      for(int i=7; i&lt;=N; i++){         vector&lt;long long&gt; temp;          for(int j=3; j&lt;=i; j++){             temp.push_back(DP[i-j]*(j-1));         }          DP[i] = max(temp);     }      cout &lt;&lt; DP[N] &lt;&lt; '\\n';      return 0; }    ","categories": ["Algorithm"],
        "tags": ["DP"],
        "url": "keithlee94.github.io/algorithm/11058/",
        "teaser":null}]
