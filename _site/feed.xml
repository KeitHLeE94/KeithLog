<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="keithlee94.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="keithlee94.github.io/" rel="alternate" type="text/html" /><updated>2019-04-21T21:34:12+09:00</updated><id>keithlee94.github.io/feed.xml</id><title type="html">KeithLog</title><subtitle>SSAFY 교육내용, 알고리즘 문제풀이 정리하여 업로드할 블로그</subtitle><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><entry><title type="html">Os_process_scheduling</title><link href="keithlee94.github.io/os/OS_Process_Scheduling/" rel="alternate" type="text/html" title="Os_process_scheduling" /><published>2019-04-21T00:00:00+09:00</published><updated>2019-04-21T00:00:00+09:00</updated><id>keithlee94.github.io/os/OS_Process_Scheduling</id><content type="html" xml:base="keithlee94.github.io/os/OS_Process_Scheduling/">&lt;h1 id=&quot;cpu-scheduling&quot;&gt;CPU Scheduling&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;발생 경우&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;프로세스가 running -&amp;gt; waiting으로 전환 - Nonpreemptive&lt;/li&gt;
      &lt;li&gt;프로세스가 running -&amp;gt; ready로 전환 - Preemptive&lt;/li&gt;
      &lt;li&gt;프로세스가 waiting -&amp;gt; ready로 전환 - Preemptive&lt;/li&gt;
      &lt;li&gt;프로세스 종료 - Nonpreemptive&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Preemptive
    &lt;ul&gt;
      &lt;li&gt;현재 CPU를 할당받은 프로세스가 다른 프로세스에 자원을 내줄 수 있음&lt;/li&gt;
      &lt;li&gt;문제: race condition - 데이터를 공유하는 경우, 커널모드에서 preemption 발생, OS의 중요 작업중 인터럽트 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Nonpreemptive
    &lt;ul&gt;
      &lt;li&gt;CPU 자원을 할당받은 프로세스가 직접 자원을 반납하기 전까지 계속 자원 점유&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;scheduling-criteria&quot;&gt;Scheduling Criteria&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;CPU Utilization: CPU를 idle 상태로 두지 않는 것. (Maximize)&lt;/li&gt;
  &lt;li&gt;Throughput: 단위시간 동안 끝낼 수 있는 프로세스 수 (Maximize)&lt;/li&gt;
  &lt;li&gt;Turnaround time: 특정 프로세스 실행까지 걸리는 시간 (Minimize)&lt;/li&gt;
  &lt;li&gt;Waiting time: 프로세스가 ready queue에서 대기한 시간 (Minimize)&lt;/li&gt;
  &lt;li&gt;Response time: 프로세스 실행 요청 생성 후 첫 response가 올때까지 걸린 시간 (Minimize)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;fcfs-scheduling&quot;&gt;FCFS Scheduling&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;First Come First Served&lt;/li&gt;
  &lt;li&gt;프로세스 도착 순서대로 CPU 자원 할당.&lt;/li&gt;
  &lt;li&gt;문제점: convoy effect
    &lt;ul&gt;
      &lt;li&gt;실행시간이 짧은 프로세스가 긴 프로세스에 막혀 대기시간이 길어질 수 있다&lt;/li&gt;
      &lt;li&gt;예: I/O bound process가 많은 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;sjf-scheduling&quot;&gt;SJF Scheduling&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Shortest Job Fisrt&lt;/li&gt;
  &lt;li&gt;실행시간(CPU Burst time)이 짧은 프로세스를 먼저 실행한다&lt;/li&gt;
  &lt;li&gt;Optimal: 평균 대기시간이 가장 짧다&lt;/li&gt;
  &lt;li&gt;문제점: 각각의 프로세스들의 실행시간을 알아내기 어렵다&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;srtf-scheduling&quot;&gt;SRTF Scheduling&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Shortest Remaining Time First&lt;/li&gt;
  &lt;li&gt;SJF의 Preemptive 버전&lt;/li&gt;
  &lt;li&gt;단위시간마다 각 프로세스들의 작업 완료까지 남은 시간을 계산하여 남은시간이 가장 짧은 프로세스를 실행한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;priority-scheduling&quot;&gt;Priority Scheduling&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;각각의 프로세스에 우선순위 부여&lt;/li&gt;
  &lt;li&gt;SJF = CPU Burst time이 짧을수록 높은 우선순위&lt;/li&gt;
  &lt;li&gt;문제점: Starvation
    &lt;ul&gt;
      &lt;li&gt;우선순위가 낮은 프로세스가 높은 프로세스에 밀려 무한히 대기하는 현상&lt;/li&gt;
      &lt;li&gt;해결: Aging - 대기한 시간에 따라 우선순위 상향 조정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;round-robin&quot;&gt;Round Robin&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;각각의 프로세스에 실행시간(Time Quantum) 부여&lt;/li&gt;
  &lt;li&gt;프로세스 실행중 Time Quantum이 다 지나면 다른 프로세스에 의해 preemption되고 ready queue의 맨 뒤로 옮겨간다&lt;/li&gt;
  &lt;li&gt;Starvation 문제 해결&lt;/li&gt;
  &lt;li&gt;매 quantum마다 timer interrupt 발생&lt;/li&gt;
  &lt;li&gt;성능
    &lt;ul&gt;
      &lt;li&gt;q가 크면: FCFS와 유사(비효율적)&lt;/li&gt;
      &lt;li&gt;q가 작으면: response time이 빨라지나 context switching overhead가 커진다&lt;/li&gt;
      &lt;li&gt;SJF에 비해 turnaround time이 길지만 response가 더 뛰어나다&lt;/li&gt;
      &lt;li&gt;q 설정: context switching에 걸리는 시간보다 길게 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;multilevel-queue&quot;&gt;Multilevel Queue&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Ready Queue를 여러 큐로 나누는 방식&lt;/li&gt;
  &lt;li&gt;foreground: interactive processes (Round Robin)&lt;/li&gt;
  &lt;li&gt;background: batch processes (FCFS)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;우선순위&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;System processes&lt;/li&gt;
      &lt;li&gt;interactive processes&lt;/li&gt;
      &lt;li&gt;interactive editing processes&lt;/li&gt;
      &lt;li&gt;batch processes&lt;/li&gt;
      &lt;li&gt;student processess&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;multilevel-feedback-queue&quot;&gt;Multilevel Feedback Queue&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스가 현재 큐에서 다른 큐로 이동 가능&lt;/li&gt;
  &lt;li&gt;큐별로 다른 quantum 적용 가능&lt;/li&gt;
  &lt;li&gt;한 큐에서 quantum 내에 작업이 끝나지 않았으면 다음 큐로 이동하는 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;multiple-processor-scheduling&quot;&gt;Multiple Processor Scheduling&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Asymmetric Multiprocessing: 한 프로세서만 시스템 데이터 구조에 접근하여 데이터 공유의 필요성을 줄인다&lt;/li&gt;
  &lt;li&gt;Symmetric Multiprocessing: 각각의 프로세서가 각자 스케줄링을 실행하고 모든 프로세스들이 하나의 ready queue를 공유하거나 각자 다른 ready queue를 갖는 구조&lt;/li&gt;
  &lt;li&gt;Affinity: 특정 코어를 지정하여 task를 수행하도록 하는 설계&lt;/li&gt;
  &lt;li&gt;NUMA
    &lt;ul&gt;
      &lt;li&gt;Non Uniform Memory Access&lt;/li&gt;
      &lt;li&gt;CPU에 묶여있는 메모리에 대해서는 접근 속도가 빠르고, 다른 CPU에 묶여있는 메모리에 대해서는 접근 속도가 느리다&lt;/li&gt;
      &lt;li&gt;Affinity를 고려하여 메모리 배치&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Load Balancing
    &lt;ul&gt;
      &lt;li&gt;작업을 여러 프로세서에 고르게 분산시킨다&lt;/li&gt;
      &lt;li&gt;Push migration: 주기적으로 프로세서들의 작업량을 확인하여 작업이 많은 프로세서의 작업을 작업이 적은 프로세서로 옮긴다&lt;/li&gt;
      &lt;li&gt;Pull migration: 작업이 적은 프로세서가 작업이 많은 프로세서의 작업을 가져온다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;multithread-multicore-system&quot;&gt;Multithread Multicore System&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Memory stall: 프로세서가 요청한 데이터가 메모리로부터 도착하기까지 기다리는 시간&lt;/li&gt;
  &lt;li&gt;Multithread Processor 구조: 2개 이상의 하드웨어 쓰레드가 각각의 코어에 할당되어 하나의 쓰레드에서 memory stall 발생시 다른 쓰레드로 전환하여 작업 처리&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Process Scheduling" /><summary type="html">CPU Scheduling 발생 경우 프로세스가 running -&amp;gt; waiting으로 전환 - Nonpreemptive 프로세스가 running -&amp;gt; ready로 전환 - Preemptive 프로세스가 waiting -&amp;gt; ready로 전환 - Preemptive 프로세스 종료 - Nonpreemptive Preemptive 현재 CPU를 할당받은 프로세스가 다른 프로세스에 자원을 내줄 수 있음 문제: race condition - 데이터를 공유하는 경우, 커널모드에서 preemption 발생, OS의 중요 작업중 인터럽트 발생 Nonpreemptive CPU 자원을 할당받은 프로세스가 직접 자원을 반납하기 전까지 계속 자원 점유</summary></entry><entry><title type="html">Os_multithread</title><link href="keithlee94.github.io/os/OS_Multithread/" rel="alternate" type="text/html" title="Os_multithread" /><published>2019-04-21T00:00:00+09:00</published><updated>2019-04-21T00:00:00+09:00</updated><id>keithlee94.github.io/os/OS_Multithread</id><content type="html" xml:base="keithlee94.github.io/os/OS_Multithread/">&lt;h1 id=&quot;thread&quot;&gt;Thread&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;독립적으로 스케줄링되는 단위&lt;/li&gt;
  &lt;li&gt;프로세스 = 하나 이상의 같은 메모리 공간을 공유하는 쓰레드들로 구성&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;장점&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;반응성: 프로세스가 block되어도 영향 없음&lt;/li&gt;
      &lt;li&gt;자원 공유: 프로세스에 비해 자원공유가 간단&lt;/li&gt;
      &lt;li&gt;경제성: context switching overhead가 프로세스에 비해 적다&lt;/li&gt;
      &lt;li&gt;확장성: 멀티프로세서 장점 활용 가능&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;예: 서버가 클라이언트에 요청을 받으면 새 프로세스를 생성하는 대신 worker thread를 생성하여 요청 처리&lt;/li&gt;
  &lt;li&gt;구성
    &lt;ul&gt;
      &lt;li&gt;stack + register&lt;/li&gt;
      &lt;li&gt;같은 프로세스 내 쓰레드들끼리는 code, data, heap 공유&lt;/li&gt;
      &lt;li&gt;쓰레드 생성시 stack + register만 새로 생성됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;parallelism과-concurrency&quot;&gt;Parallelism과 Concurrency&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Parallelism
- 동시에 2개 이상의 작업을 수행하는 시스템
- 멀티코어 구조에서만 가능
- Data Parallelism: 여러 프로세서에서 동일한 데이터로 동일한 작업 수행
- Task Parallelism: 여러 프로세서에서 서로 다른 쓰레드로 서로 다른 작업 수행

Concurrency
- 2개 이상의 작업이 동시에 진행될 수 있는 시스템
- 싱글코어 구조에서도 가능

차이
- Concurrency
    - 서로 다른 작업들을 중첩시켜 진행하는 방식
    - 여러 작업들이 있을때 한 작업이 끝나기 전 다른 작업 진행 가능
- Parallelism
    - 서로 다른 작업들을 동시에 여러개 처리하는 방식
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;multithreading&quot;&gt;Multithreading&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;User thread: user level thread library가 관리&lt;/li&gt;
  &lt;li&gt;Kernel thread: kernel이 관리&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;종류&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;Many to One
        &lt;ul&gt;
          &lt;li&gt;여러 user thread들이 하나의 kernel thread에 결합&lt;/li&gt;
          &lt;li&gt;하나의 thread가 block되면 다른 thread들도 block됨&lt;/li&gt;
          &lt;li&gt;하나의 kernel thread만이 처리 가능하므로 병렬 실행 불가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;One to One
        &lt;ul&gt;
          &lt;li&gt;하나의 user thread가 하나의 kernel thread에 결합&lt;/li&gt;
          &lt;li&gt;user thread 생성시 연결할 kernel thread도 함께 생성&lt;/li&gt;
          &lt;li&gt;병렬 실행 가능&lt;/li&gt;
          &lt;li&gt;하나의 thread가 block되어도 다른 thread 실행 가능&lt;/li&gt;
          &lt;li&gt;context switching overhead 발생 가능&lt;/li&gt;
          &lt;li&gt;생성 가능한 thread 수 제한&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Many to Many
        &lt;ul&gt;
          &lt;li&gt;여러 user thread가 여러 kernel thread에 결합&lt;/li&gt;
          &lt;li&gt;kernel thread 생성 수 제한 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Two level model
        &lt;ul&gt;
          &lt;li&gt;Many to Many + One to One 형태&lt;/li&gt;
          &lt;li&gt;중요도가 높은 user thread는 One to One 형태로 처리하여 선점권을 부여할 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Multithread" /><summary type="html">Thread 독립적으로 스케줄링되는 단위 프로세스 = 하나 이상의 같은 메모리 공간을 공유하는 쓰레드들로 구성 장점</summary></entry><entry><title type="html">Os_introduction</title><link href="keithlee94.github.io/os/OS_Introduction/" rel="alternate" type="text/html" title="Os_introduction" /><published>2019-04-21T00:00:00+09:00</published><updated>2019-04-21T00:00:00+09:00</updated><id>keithlee94.github.io/os/OS_Introduction</id><content type="html" xml:base="keithlee94.github.io/os/OS_Introduction/">&lt;h1 id=&quot;os의-역할&quot;&gt;OS의 역할&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;자원 관리
2, 프로그램으로부터 컴퓨터가 손상되는것 방지&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;interrupt&quot;&gt;Interrupt&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;하드웨어 인터럽트: I/O 장치가 CPU에 이벤트 발생을 알리는 목적&lt;/li&gt;
  &lt;li&gt;소프트웨어 인터럽트: 프로그램 실행시 사용자 요청이나 에어로 인해 발생
    &lt;ul&gt;
      &lt;li&gt;예: trap, exception&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ISR
    &lt;ul&gt;
      &lt;li&gt;Interrupt Service Routine&lt;/li&gt;
      &lt;li&gt;인터럽트 발생시 CPU가 자동으로 실행.&lt;/li&gt;
      &lt;li&gt;대부분의 인터럽트는 자신만의 ISR을 가지고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인터럽트 발생시&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;인터럽트가 발생한 프로세스의 Program Counter 정보 저장(현재까지 작업내용 저장)&lt;/li&gt;
      &lt;li&gt;ISR 실행하여 인터럽트 처리&lt;/li&gt;
      &lt;li&gt;Program Counter에서 정보 가져와 작업 재개&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;dma&quot;&gt;DMA&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;I/O 장치가 메모리에 빠르게 접근하기 위해 사용.&lt;/li&gt;
  &lt;li&gt;CPU의 개입 없이 버퍼를 통해 메모리에 바로 접근.
&lt;img src=&quot;https://user-images.githubusercontent.com/23356503/56469194-45677180-6471-11e9-8833-ecd3758fda5e.png&quot; alt=&quot;DMA&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Synchronous I/O: I/O 작업이 끝나야 사용자 프로그램으로 제어가 넘어감.&lt;/li&gt;
  &lt;li&gt;Asynchronous I/O: I/O 작업 완료 전 사용자 프로그램으로 제어가 넘어감.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;저장공간&quot;&gt;저장공간&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;register - cache - main memory - ssd - magnetic disk - optical disk - magnetic tape 순으로 빠르다.&lt;/li&gt;
  &lt;li&gt;register, cache, main memory = volatile&lt;/li&gt;
  &lt;li&gt;캐싱: 속도가 더 빠른 저장공간에 사용할 데이터를 임시로 저장하는 것.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;process&quot;&gt;Process&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;현재 실행중인 프로그램&lt;/li&gt;
  &lt;li&gt;single thread: 1개의 Program Counter를 가진다.&lt;/li&gt;
  &lt;li&gt;multi thread: thread당 하나의 Program Counter를 갖는다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OS의 Process Management&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;user / system process 생성, 삭제&lt;/li&gt;
      &lt;li&gt;process 실행 중지, 재개&lt;/li&gt;
      &lt;li&gt;프로세스 동기화 mechanism 제공&lt;/li&gt;
      &lt;li&gt;프로세스간 통신 mechanism 제공&lt;/li&gt;
      &lt;li&gt;deadlock 처리를 위한 mechanism 제공&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Introduction" /><summary type="html">OS의 역할 자원 관리 2, 프로그램으로부터 컴퓨터가 손상되는것 방지</summary></entry><entry><title type="html">Os_process</title><link href="keithlee94.github.io/os/OS_Process/" rel="alternate" type="text/html" title="Os_process" /><published>2019-04-21T00:00:00+09:00</published><updated>2019-04-21T00:00:00+09:00</updated><id>keithlee94.github.io/os/OS_Process</id><content type="html" xml:base="keithlee94.github.io/os/OS_Process/">&lt;h1 id=&quot;process&quot;&gt;Process&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Program in execution&lt;/li&gt;
  &lt;li&gt;프로그램이 메모리에 올라오면 프로세스가 된다.&lt;/li&gt;
  &lt;li&gt;구성 요소
    &lt;ul&gt;
      &lt;li&gt;text section: program code&lt;/li&gt;
      &lt;li&gt;program counter&lt;/li&gt;
      &lt;li&gt;stack: 임시 데이터(로컬 변수 등) 저장&lt;/li&gt;
      &lt;li&gt;data section: 전역변수 저장&lt;/li&gt;
      &lt;li&gt;heap: 실행 도중 동적할당된 메모리 공간
&lt;img src=&quot;https://user-images.githubusercontent.com/23356503/56469277-80b67000-6472-11e9-89e4-70fe4c0288c4.png&quot; alt=&quot;Process Structure&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;process-state&quot;&gt;Process State&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;new: 프로세스가 생성된 상태&lt;/li&gt;
  &lt;li&gt;ready: 프로세서에 할당되길 기다리는 상태&lt;/li&gt;
  &lt;li&gt;waiting: 프로세스가 event 발생을 기다리는 상태&lt;/li&gt;
  &lt;li&gt;running: 작업 수행&lt;/li&gt;
  &lt;li&gt;terminated: 작업 완료후 종료
    &lt;ul&gt;
      &lt;li&gt;new -&amp;gt; ready: 메모리에 올라감&lt;/li&gt;
      &lt;li&gt;ready -&amp;gt; running: CPU 자원 할당&lt;/li&gt;
      &lt;li&gt;running -&amp;gt; ready: 인터럽트 발생&lt;/li&gt;
      &lt;li&gt;running -&amp;gt; waiting: I/O 작업, event 발생&lt;/li&gt;
      &lt;li&gt;waiting -&amp;gt; ready: I/O 작업, event 완료&lt;/li&gt;
      &lt;li&gt;running -&amp;gt; terminated: exit 호출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;pcb&quot;&gt;PCB&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Process Control Block&lt;/li&gt;
  &lt;li&gt;프로세스 정보 저장.
    &lt;ol&gt;
      &lt;li&gt;Process state&lt;/li&gt;
      &lt;li&gt;Program Counter: 프로세스가 다음에 실행할 명령어 주소를 가리킴&lt;/li&gt;
      &lt;li&gt;Process ID&lt;/li&gt;
      &lt;li&gt;CPU Register&lt;/li&gt;
      &lt;li&gt;CPU scheduling information: priority, scheduling queue pointers&lt;/li&gt;
      &lt;li&gt;Memory management information: memory allocated to process&lt;/li&gt;
      &lt;li&gt;Accounting information: CPU usage, clock time elapsed, time limits&lt;/li&gt;
      &lt;li&gt;I/O status information: I/O device allocated to process, list of open files&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;thread&quot;&gt;Thread&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;실행의 흐름&lt;/li&gt;
  &lt;li&gt;각 쓰레드당 하나의 PCB를 갖는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;process-scheduling&quot;&gt;Process Scheduling&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;scheduling queue
    &lt;ul&gt;
      &lt;li&gt;job queue: 시스템의 모든 프로세스들의 집합&lt;/li&gt;
      &lt;li&gt;ready queue: 메인메모리에서 실행 대기중인 프로세스들의 집합&lt;/li&gt;
      &lt;li&gt;device queue: I/O 장치를 기다리는 프로세스들의 집합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;scheduler: CPU가 다음에 실행할 프로세스 선택
    &lt;ul&gt;
      &lt;li&gt;long term: 어떤 프로세스를 ready queue에 넣을지 결정&lt;/li&gt;
      &lt;li&gt;short term: 어떤 프로세스에 CPU 자원을 할당할지 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;I/O Bound Process: CPU 사용시간이 짧다. I/O에 치중.&lt;/li&gt;
  &lt;li&gt;CPU Bound Process: CPU 사용시간이 길다. 연산에 치중.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;context-switch&quot;&gt;Context Switch&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;CPU가 프로세스 전환시 이전 프로세스 상태를 저장하고 새로운 프로세스의 상태 정보를 불러오는 작업.&lt;/li&gt;
  &lt;li&gt;Context: 프로세스 상태 정보. PCB에 저장.&lt;/li&gt;
  &lt;li&gt;Overhead 발생: context switching동안 시스템이 다른 작업을 할 수 없다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순서&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;현재 진행중인 프로세스 정보 PCB에 저장&lt;/li&gt;
      &lt;li&gt;새로 실행할 프로세스의 PCB 정보 불러옴&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;process-creation&quot;&gt;Process Creation&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;부모프로세스가 자식프로세스 생성&lt;/li&gt;
  &lt;li&gt;pid: 프로세스간 구별을 위해 사용&lt;/li&gt;
  &lt;li&gt;자원 공유: 부모와 자식간 자원 공유 가능&lt;/li&gt;
  &lt;li&gt;실행 옵션
    &lt;ul&gt;
      &lt;li&gt;부모가 자식 끝나기까지 기다림&lt;/li&gt;
      &lt;li&gt;부모와 자식이 동시에 실행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;fork()
    &lt;ul&gt;
      &lt;li&gt;새로운 프로세스를 만드는 시스템 콜&lt;/li&gt;
      &lt;li&gt;부모와 완전히 동일한 자식 프로세스 생성&lt;/li&gt;
      &lt;li&gt;pid_t 타입의 pid 리턴
        &lt;ul&gt;
          &lt;li&gt;음수: fork() 실패&lt;/li&gt;
          &lt;li&gt;0: 자식 프로세스&lt;/li&gt;
          &lt;li&gt;자연수: 부모 프로세스&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;exec()
    &lt;ul&gt;
      &lt;li&gt;생성된 자식 프로세스의 context 변경을 위한 시스템 콜&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/23356503/56469481-5619e680-6475-11e9-9ca2-2d28e3ee9f39.png&quot; alt=&quot;Process Creation&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;process-termination&quot;&gt;Process Termination&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;exit()
    &lt;ul&gt;
      &lt;li&gt;프로세스가 실행을 끝내고 OS에 프로세스 삭제를 요청하는 시스템 콜&lt;/li&gt;
      &lt;li&gt;프로세스에 할당된 자원 반환&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;abort()
    &lt;ul&gt;
      &lt;li&gt;부모 프로세스가 자식 프로세스를 종료시키는 시스템 콜&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;zombie process: 종료된 프로세스를 기다리는 부모 프로세스가 없는 프로세스&lt;/li&gt;
  &lt;li&gt;orphan process: 부모 프로세스가 실행 완료 전 종료된 프로세스&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;ipc&quot;&gt;IPC&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;InterProcess Communication: 프로세스간 통신을 위해 필요&lt;/li&gt;
  &lt;li&gt;Shared Memory
  &lt;img src=&quot;https://user-images.githubusercontent.com/23356503/56469538-215a5f00-6476-11e9-984c-33f601c6e3f0.png&quot; alt=&quot;Shared Memory&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;장점: 메모리에 곧바로 접근하므로 속도가 빠르다&lt;/li&gt;
      &lt;li&gt;단점: 동기화가 어렵다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Message Passing
  &lt;img src=&quot;https://user-images.githubusercontent.com/23356503/56469567-96c62f80-6476-11e9-87af-6f153a671e56.png&quot; alt=&quot;Message Passing&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;장점: 동기화가 쉽다&lt;/li&gt;
      &lt;li&gt;단점: 커널에 의존하므로 속도가 느리다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;message-passing&quot;&gt;Message Passing&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;send, receive 기능 제공&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;과정&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;소통하려는 두 프로세스 간 communication link 개설&lt;/li&gt;
      &lt;li&gt;send, receive를 통해 메시지 교환&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Direct Communication
    &lt;ul&gt;
      &lt;li&gt;어떤 프로세스에게 메시지를 보내거나 받을지 명시&lt;/li&gt;
      &lt;li&gt;link가 자동으로 생성됨&lt;/li&gt;
      &lt;li&gt;하나의 link는 한쌍의 프로세스만 연결, 한쌍의 프로세스 간에는 하나의 link만 존재&lt;/li&gt;
      &lt;li&gt;bidirectional&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Indirect Communication
    &lt;ul&gt;
      &lt;li&gt;mailbox(port)를 통해 메시지를 주고받음&lt;/li&gt;
      &lt;li&gt;프로세스간 mailbox를 공유한 경우에만 소통 가능&lt;/li&gt;
      &lt;li&gt;프로세스간 mailbox 공유시에만 link 생성&lt;/li&gt;
      &lt;li&gt;하나의 link에 여러 프로세스 연결 가능, 한쌍의 프로세스 간 여러 link 존재 가능&lt;/li&gt;
      &lt;li&gt;unidirectional, bidirectional&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Synchronization
    &lt;ul&gt;
      &lt;li&gt;blocking send: 메시지 수신 전까지 sender block&lt;/li&gt;
      &lt;li&gt;nonblocking send: block 없이 sender가 메시지 전송&lt;/li&gt;
      &lt;li&gt;blocking receive: 메시지가 들어오기 전까지 receiver block&lt;/li&gt;
      &lt;li&gt;nonblocking receive: block 없이 receiver가 메시지 수신 = 메시지가 null일 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Process" /><summary type="html">Process Program in execution 프로그램이 메모리에 올라오면 프로세스가 된다. 구성 요소 text section: program code program counter stack: 임시 데이터(로컬 변수 등) 저장 data section: 전역변수 저장 heap: 실행 도중 동적할당된 메모리 공간</summary></entry><entry><title type="html">2206</title><link href="keithlee94.github.io/algorithm/2206/" rel="alternate" type="text/html" title="2206" /><published>2019-04-04T00:00:00+09:00</published><updated>2019-04-04T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2206</id><content type="html" xml:base="keithlee94.github.io/algorithm/2206/">&lt;h1 id=&quot;백준-2206번&quot;&gt;백준 2206번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2206&quot;&gt;2206번: 벽 부수고 이동하기&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;예전에 한번 풀어봤던 벽부수고 이동하는 문제.&lt;/p&gt;

&lt;p&gt;간만에 다시한번 풀어봤는데, 그때 답보고 풀어서 그런지 다시봐도 새롭더라.&lt;/p&gt;

&lt;p&gt;여러번 거치다 보니 BFS로 거리 구하는 틀이 거의 정형화됐는데, 예전에는 visit 배열을 만드는 대신 거리를 계산하는 배열을 만들어서 거리를 쟀었다.&lt;/p&gt;

&lt;p&gt;이 문제도 그렇게 풀었는데, 거리 계산 배열을 3차원으로 만들어 벽을 안부쉈을 경우와 부쉈을 경우로 나눠 거리를 구한다.&lt;/p&gt;

&lt;p&gt;큐에도 출발점과 벽 부술수 있는 횟수를 넣고 출발하는데, 만약 목적지에 도착했다면 거리 배열[x][y][남은 부술수있는 횟수] 값을 리턴해준다.&lt;/p&gt;

&lt;p&gt;이외에는 BFS와 크게 다르지 않은데, 벽을 안부수고 0을 찾아 이동한 거리를 구해주고, 부술 수 있는 횟수가 남았으면 벽을 부수고 이동한 거리를 구한 다음 부술 수 있는 횟수를 1 빼준다.&lt;/p&gt;

&lt;p&gt;이런식으로 목적지까지 찾아가서 남은 부술수 있는 횟수에 대한 거리를 구하면 끝.&lt;/p&gt;

&lt;p&gt;이번에서야 예전 답을 좀 이해할 수 있을 것 같다.&lt;/p&gt;

&lt;p&gt;다음에도 한번 더 풀어봐야지.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 03/04/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

struct Point{
    int x, y;
    int breakCount;
};

int map[1000][1000] = {0, };
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
int dist[1000][1000][2] = {0, };

int N, M;

int BFS(){
    queue&amp;lt;Point&amp;gt; Queue;
    Queue.push({0, 0, 1});
    dist[0][0][1] = 1;

    while(!Queue.empty()){
        int currentX = Queue.front().x;
        int currentY = Queue.front().y;
        int breakCount = Queue.front().breakCount;
        Queue.pop();

        if(currentX == N-1 &amp;amp;&amp;amp; currentY == M-1){
            return dist[N-1][M-1][breakCount];
        }

        for(int i=0; i&amp;lt;4; i++){
            int nextX = currentX + dx[i];
            int nextY = currentY + dy[i];

            if(nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt; N &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt; M){
                if(map[nextX][nextY] == 0 &amp;amp;&amp;amp; dist[nextX][nextY][breakCount] == 0){
                    dist[nextX][nextY][breakCount] = dist[currentX][currentY][breakCount] + 1;
                    Queue.push({nextX, nextY, breakCount});
                }
                else if(map[nextX][nextY] == 1 &amp;amp;&amp;amp; breakCount &amp;gt; 0){
                    dist[nextX][nextY][breakCount-1] = dist[currentX][currentY][breakCount] + 1;
                    Queue.push({nextX, nextY, breakCount-1});
                }
            }
        }
    }

    return -1;
}

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;

    for(int i=0; i&amp;lt;N; i++){
        string row;
        cin &amp;gt;&amp;gt; row;

        for(int j=0; j&amp;lt;M; j++){
            map[i][j] = row[j] - '0';
        }
    }

    cout &amp;lt;&amp;lt; BFS() &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="BFS" /><summary type="html">백준 2206번 Link: 2206번: 벽 부수고 이동하기</summary></entry><entry><title type="html">2098</title><link href="keithlee94.github.io/algorithm/2098/" rel="alternate" type="text/html" title="2098" /><published>2019-04-04T00:00:00+09:00</published><updated>2019-04-04T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2098</id><content type="html" xml:base="keithlee94.github.io/algorithm/2098/">&lt;h1 id=&quot;백준-2098번&quot;&gt;백준 2098번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2098&quot;&gt;2098번: 외판원 순회&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;그 유명한 Traveling Salesperson 문제다.&lt;/p&gt;

&lt;p&gt;NP-hard 문제지만, 여기서는 인풋이 좀 작아서 시간안에 풀리도록 만들었다.&lt;/p&gt;

&lt;p&gt;푸는 방법은 사실 단순한데, DFS + Memoization으로 풀면 된다.&lt;/p&gt;

&lt;p&gt;그런데 여기서 중요한 점이 하나 있는데, 출발점을 제외한 모든 도시들은 단 한번만 방문할 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;이 방문 여부를 표시하기 위해 비트마스킹을 사용한다는 점이 큰 차이점이다.&lt;/p&gt;

&lt;p&gt;처음에는 비트마스킹을 안쓰고 단순 DP로만 풀어보려고 했는데, 어떻게 푸는지는 알겠는데 도저히 구현이 안되더라.&lt;/p&gt;

&lt;p&gt;겨우겨우 구현해서 제출해보니 역시나 틀린 답이었다.&lt;/p&gt;

&lt;p&gt;한참 더 고민하다 답을 찾아봤고, 단순 DP로 풀리는 문제가 아니라는 점을 깨달았다.&lt;/p&gt;

&lt;p&gt;푸는 방법은 다음과 같다.&lt;/p&gt;

&lt;p&gt;우선 DFS 함수의 인자를 인덱스와 방문 여부로 받도록 한다.&lt;/p&gt;

&lt;p&gt;여기에 0과 1을 넘겨, 첫 도시에서 시작한다는 점을 명시하여 DFS 함수를 실행한다.&lt;/p&gt;

&lt;p&gt;DFS 함수의 종료 조건은 모든 도시를 방문했다는 경우로, visit이 1을 N만큼 왼쪽으로 shift한 값 - 1과 같은 값이 되면 종료한다.&lt;/p&gt;

&lt;p&gt;이때 그냥 종료하면 안되고, 마지막 방문 도시에서 처음 도시로 가는 길이 없다면 불가능한 경우이므로 무한대값을 리턴한다.&lt;/p&gt;

&lt;p&gt;길이 있다면 그 길을 택했을때의 cost 값을 리턴한다.&lt;/p&gt;

&lt;p&gt;종료조건이 아닐 경우, 현재 인덱스 값과 visit을 통해 DP 배열의 값을 받아온다.&lt;/p&gt;

&lt;p&gt;이때 중요한 점은 DP 배열의 값을 받아오는 것이 아닌 &lt;b&gt;주소값을 받아와야 한다&lt;/b&gt;는 것. 이렇게 하면 DP 배열을 일일이 갱신하지 않고 주소값을 받아온 변수를 변경하면 알아서 DP배열의 값도 바뀐다.&lt;/p&gt;

&lt;p&gt;포인터 연산의 편리함을 다시한번 느끼게 된 계기.&lt;/p&gt;

&lt;p&gt;이렇게 받아온 값이 초기값인 -1이 아니라면 이 값을 그대로 리턴해준다.&lt;/p&gt;

&lt;p&gt;만약 초기값에서 갱신되지 않았다면, 우선 매우 큰 값으로 설정해 준다.&lt;/p&gt;

&lt;p&gt;그 다음, 현재 위치에서 연결되었으며 앞에서 방문하지 않은 도시들에 대해 재귀함수로 탐색하며 최소값을 갱신해 준다. 이때 방문 여부를 1을 도시 번호만큼 왼쪽으로 shift하여 표시한다.&lt;/p&gt;

&lt;p&gt;이렇게 재귀함수를 돌며 갱신된 값이 곧 답이다.&lt;/p&gt;

&lt;p&gt;재귀함수를 돌며 탐색하는 부분이 가장 이해하기 어려웠는데, 순열을 재귀로 만드는 과정과 같다고 생각하면 이해가 빠르다.&lt;/p&gt;

&lt;p&gt;모든 경우를 다 따져가며 최소값을 구하고, 탐색 결과값을 저장하고 이를 불러옴으로써 시간을 단축시킬 수 있는 문제.&lt;/p&gt;

&lt;p&gt;앞으로도 문제풀때 중요한 개념들이 여럿 등장했던 중요한 문제다.&lt;/p&gt;

&lt;p&gt;비트마스킹, 포인터 연산이 아주 중요한 개념임을 깨닫게 된 문제.&lt;/p&gt;

&lt;p&gt;꼭 다시한번 풀어봐야될 문제인 것 같다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 04/04/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string.h&amp;gt;

using namespace std;

int map[16][16] = {0, };
int DP[16][1 &amp;lt;&amp;lt; 16] = {0, };

int N;

int cost(int index, int visit){
    if(visit == (1 &amp;lt;&amp;lt; N) - 1){
        if(map[index][0] == 0){
            return 987654321;
        }

        return map[index][0];
    }

    int&amp;amp; result = DP[index][visit];

    if(result != -1){
        return result;
    }

    result = 999999999;

    for(int i=0; i&amp;lt;N; i++){
        if(visit &amp;amp; (1 &amp;lt;&amp;lt; i) || map[index][i] == 0){
            continue;
        }

        result = min(result, cost(i, (visit | (1 &amp;lt;&amp;lt; i))) + map[index][i]);
    }

    return result;
}

int main(){
    cin &amp;gt;&amp;gt; N;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;N; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    memset(DP, -1, sizeof(DP));

    cout &amp;lt;&amp;lt; cost(0, 1) &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><category term="Bit Masking" /><summary type="html">백준 2098번 Link: 2098번: 외판원 순회</summary></entry><entry><title type="html">10610</title><link href="keithlee94.github.io/algorithm/10610/" rel="alternate" type="text/html" title="10610" /><published>2019-04-02T00:00:00+09:00</published><updated>2019-04-02T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/10610</id><content type="html" xml:base="keithlee94.github.io/algorithm/10610/">&lt;h1 id=&quot;백준-10610번&quot;&gt;백준 10610번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/10610&quot;&gt;10610번: 30&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;예전에 실패했던 문제여서 다시한번 풀어본 문제.&lt;/p&gt;

&lt;p&gt;너무 허무할정도로 쉽게 답이 나와버려서 이걸 도대체 왜 못풀었을까 하는 생각이 들게 하는 문제였다.&lt;/p&gt;

&lt;p&gt;우선 인풋을 string 형태로 받고, 각 자리수를 모두 더해 3의 배수가 되는지 확인한다. 이때 0의 갯수를 세주는 작업도 같이 한다.&lt;/p&gt;

&lt;p&gt;작업 중 0이 아닌 숫자를 만날 경우 벡터에 넣는다.&lt;/p&gt;

&lt;p&gt;반복문을 한번 돌고 나서, 벡터를 정렬한다. 내림차순으로 정렬되므로 끝에서부터 쭉 결과값을 담을 string에 넣는다.&lt;/p&gt;

&lt;p&gt;만약 인풋으로 들어온 숫자가 3의 배수가 아니거나 0을 포함하지 않았다면 -1을 출력하고, 그렇지 않을 경우 만든 string을 출력하면 풀린다.&lt;/p&gt;

&lt;p&gt;에전이랑 생각하는게 많이 달라졌나보다. 이런문제도 못풀었나 하는 생각이 들 정도면.&lt;/p&gt;

&lt;p&gt;그동안 많이 발전했다는 기분에 뿌듯하네ㅋㅋㅋㅋ&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 02/04/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int main(){
    string num;
    cin &amp;gt;&amp;gt; num;

    int zeroCount = 0;
    long long digitSum = 0;
    vector&amp;lt;int&amp;gt; numbers;

    for(int i=num.length()-1; i&amp;gt;=0; i--){
        if(num[i] - '0' == 0){
            zeroCount++;
        }
        else{
            numbers.push_back(num[i] - '0');
            digitSum += num[i] - '0';
        }
    }

    sort(numbers.begin(), numbers.end());

    string result;
    if(zeroCount &amp;gt; 0 &amp;amp;&amp;amp; digitSum % 3 == 0){
        for(int i=numbers.size()-1; i&amp;gt;=0; i--){
            result.push_back(numbers[i] + '0');
        }
        for(int i=0; i&amp;lt;zeroCount; i++){
            result.push_back('0');
        }

        cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';
    }
    else{
        cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Greedy" /><summary type="html">백준 10610번 Link: 10610번: 30</summary></entry><entry><title type="html">1018</title><link href="keithlee94.github.io/algorithm/1018/" rel="alternate" type="text/html" title="1018" /><published>2019-04-01T00:00:00+09:00</published><updated>2019-04-01T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1018</id><content type="html" xml:base="keithlee94.github.io/algorithm/1018/">&lt;h1 id=&quot;백준-1018번&quot;&gt;백준 1018번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1018&quot;&gt;1018번: 체스판 다시 칠하기&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;오랫만에 풀어보는 시뮬레이션 문제였다.&lt;/p&gt;

&lt;p&gt;사실 별건 없어서, 엄청 큰 체스판에 대해 옆으로, 아래로 한칸씩 옮겨가면서 왼쪽 위 코너가 흰색인 체스판과 검은색인 체스판에 대해 맞춰보며 다시 칠하는 횟수가 최소인 경우의 최소값을 찾으면 되는 문제다.&lt;/p&gt;

&lt;p&gt;그냥 단순히 반복문 돌리면서 비교하면 답 나옴.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 01/04/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

char board1[8][8] = {
        {'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
        {'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
        {'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
        {'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
        {'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
        {'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
        {'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
        {'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'}
};

char board2[8][8] = {
        {'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
        {'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
        {'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
        {'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
        {'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
        {'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
        {'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
        {'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'}
};

char map[50][50];

int main(){
    int N, M;

    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;

    for(int i=0; i&amp;lt;N; i++){
        string row;
        cin &amp;gt;&amp;gt; row;

        for(int j=0; j&amp;lt;M; j++){
            map[i][j] = row[j];
        }
    }

    char checkMap[8][8];
    vector&amp;lt;int&amp;gt; candidates;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;M; j++){
            if(i + 7 &amp;lt; N &amp;amp;&amp;amp; j + 7 &amp;lt; M){
                for(int k=0; k&amp;lt;8; k++){
                    for(int l=0; l&amp;lt;8; l++){
                        checkMap[k][l] = map[k+i][l+j];
                    }
                }

                int result1 = 0, result2 = 0;
                for(int k=0; k&amp;lt;8; k++){
                    for(int l=0; l&amp;lt;8; l++){
                        if(checkMap[k][l] != board1[k][l]){
                            result1++;
                        }
                        if(checkMap[k][l] != board2[k][l]){
                            result2++;
                        }
                    }
                }

                candidates.push_back(result1);
                candidates.push_back(result2);
            }
        }
    }

    sort(candidates.begin(), candidates.end());

    cout &amp;lt;&amp;lt; candidates[0] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Simulation" /><category term="Brute Force" /><summary type="html">백준 1018번 Link: 1018번: 체스판 다시 칠하기</summary></entry><entry><title type="html">9465</title><link href="keithlee94.github.io/algorithm/9465/" rel="alternate" type="text/html" title="9465" /><published>2019-03-30T00:00:00+09:00</published><updated>2019-03-30T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/9465</id><content type="html" xml:base="keithlee94.github.io/algorithm/9465/">&lt;h1 id=&quot;백준-9465번&quot;&gt;백준 9465번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/9465&quot;&gt;9465번: 스티커&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;무난한 DP 문제였다.&lt;/p&gt;

&lt;p&gt;예전에 풀어봤던 RGB 거리 문제처럼 바로 앞에서 선택한 인덱스를 제외한 나머지 인덱스의 DP값들에 스티커 점수를 더해가며 DP 배열을 채우면 되는 문제다.&lt;/p&gt;

&lt;p&gt;확실히 이젠 DP에 대해서 감이 좀 생긴 느낌이 든다.&lt;/p&gt;

&lt;p&gt;보다보니 비슷한 문제였다는게 보이네 슬슬ㅎㅎㅎ&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 30/03/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int T;
int stickers[2][100001] = {0, };
int DP[100001][3] = {0, };

int main(){
    cin &amp;gt;&amp;gt; T;

    for(int test=0; test&amp;lt;T; test++){
        int N;

        cin &amp;gt;&amp;gt; N;

        bzero(stickers, sizeof(stickers));
        bzero(DP, sizeof(DP));

        for(int i=0; i&amp;lt;2; i++){
            for(int j=1; j&amp;lt;=N; j++){
                cin &amp;gt;&amp;gt; stickers[i][j];
            }
        }

        for(int i=1; i&amp;lt;=N; i++){
            DP[i][0] = max(max(DP[i-1][0], DP[i-1][1]), DP[i-1][2]);
            DP[i][1] = max(DP[i-1][0], DP[i-1][2]) + stickers[0][i];
            DP[i][2] = max(DP[i-1][0], DP[i-1][1]) + stickers[1][i];
        }

        cout &amp;lt;&amp;lt; max(max(DP[N][0], DP[N][1]), DP[N][2]) &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 9465번 Link: 9465번: 스티커</summary></entry><entry><title type="html">11726</title><link href="keithlee94.github.io/algorithm/11726/" rel="alternate" type="text/html" title="11726" /><published>2019-03-30T00:00:00+09:00</published><updated>2019-03-30T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/11726</id><content type="html" xml:base="keithlee94.github.io/algorithm/11726/">&lt;h1 id=&quot;백준-11726번&quot;&gt;백준 11726번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/11726&quot;&gt;11726번: 2×n 타일링&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;풀이가 짧은 시간안에 명쾌하게 나온 DP 문제다.&lt;/p&gt;

&lt;p&gt;가로 2, 세로 1짜리 타일을 회전시키거나 회전시키지 않는 식으로 붙여가면 되는 문제.&lt;/p&gt;

&lt;p&gt;처음에는 아무 생각없이 시도했다가 틀렸는데, 다음 타일을 반드시 현재 타일셋의 맨 오른쪽에다가 붙인다는 생각으로 푸니 바로 풀렸다.&lt;/p&gt;

&lt;p&gt;이점만 조심하면 무난했던 DP 문제였다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 30/03/2019.
//

#include &amp;lt;iostream&amp;gt;

using namespace std;

int main(){
    int N;

    long long DP[1001][2] = {0, };

    DP[1][0] = 1;
    DP[1][1] = 0;
    DP[2][0] = 1;
    DP[2][1] = 1;

    cin &amp;gt;&amp;gt; N;

    for(int i=3; i&amp;lt;=N; i++){
        DP[i][0] = (DP[i-1][0] + DP[i-1][1]) % 10007;
        DP[i][1] = DP[i-1][0] % 10007;
    }

    cout &amp;lt;&amp;lt; (DP[N][0] + DP[N][1]) % 10007 &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 11726번 Link: 11726번: 2×n 타일링</summary></entry></feed>