<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="keithlee94.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="keithlee94.github.io/" rel="alternate" type="text/html" /><updated>2019-03-02T20:34:08+09:00</updated><id>keithlee94.github.io/feed.xml</id><title type="html">KeithLog</title><subtitle>SSAFY 교육내용, 알고리즘 문제풀이 정리하여 업로드할 블로그</subtitle><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><entry><title type="html">2352</title><link href="keithlee94.github.io/algorithm/2352/" rel="alternate" type="text/html" title="2352" /><published>2019-03-02T00:00:00+09:00</published><updated>2019-03-02T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2352</id><content type="html" xml:base="keithlee94.github.io/algorithm/2352/">&lt;h1 id=&quot;백준-2352번&quot;&gt;백준 2352번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2352&quot;&gt;2352번: 반도체 설계&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;역시 DP문제.&lt;/p&gt;

&lt;p&gt;아주 오랫만에 자바로 문제를 풀었다.&lt;/p&gt;

&lt;p&gt;사실 C++로 풀긴 했는데, 누군가의 제보에 의하면 같은 알고리즘으로 풀었을때 C++로는 시간초과가 나고, 자바로는 제시간안에 풀린다는 말이 있어 자바로 바꿔서 풀었다.&lt;/p&gt;

&lt;p&gt;가장 긴 증가수열의 길이를 구하면 풀리는 문제다.&lt;/p&gt;

&lt;p&gt;내가 짠 알고리즘은 다음과 같다.&lt;/p&gt;

&lt;p&gt;1) DP 배열을 0으로 초기화한다.&lt;/p&gt;

&lt;p&gt;2) 입력을 받는다.&lt;/p&gt;

&lt;p&gt;3) i번째 인덱스에 입력받은 값이 들어간다고 가정할 때, 0부터 i-1까지의 j에 대해 port[j]가 port[i]보다 작을 때의 모든 DP값들 중 최대값을 찾는다.&lt;/p&gt;

&lt;p&gt;4) DP[i]는 3에서 구한 최대값 + 1 이다.&lt;/p&gt;

&lt;p&gt;5) DP 배열의 최대값이 구하고자 하는 답이다.&lt;/p&gt;

&lt;p&gt;위와 같은 알고리즘대로 풀어봤더니 자바로는 제시간에 풀렸다.&lt;/p&gt;

&lt;p&gt;예전에 배우기로는 여기다 이진검색까지 추가하면 더 빠르게 풀린다는 것을 배웠는데, 아직 제대로 이해하지 못해서 할수 있는 최선으로 이 알고리즘대로 풀었다.&lt;/p&gt;

&lt;p&gt;이진검색도 같이 사용해서 C++로도 풀어낼 수 있도록 공부해보고 다시한번 풀어봐야겠다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;시간-터지는-c-코드&quot;&gt;시간 터지는 C++ 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 02/03/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int N;
int DP[40001];
int port[40001];

int main(){
    cin &amp;gt;&amp;gt; N;

    port[0] = 0;
    DP[0] = 0;

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; port[i];

        int max = 0;

        for(int j=0; j&amp;lt;i; j++){
            if(port[j] &amp;lt; port[i] &amp;amp;&amp;amp; DP[j] &amp;gt; max){
                max = DP[j];
            }
        }

        DP[i] += max + 1;
    }

    int result = 0;
    for(int i=1; i&amp;lt;=N; i++){
        result = result &amp;lt; DP[i] ? DP[i] : result;
    }

    for(int i=0; i&amp;lt;=N; i++){
        cout &amp;lt;&amp;lt; DP[i] &amp;lt;&amp;lt; ' ';
    }
    cout &amp;lt;&amp;lt; '\n';

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;자바로는-돌아가는-정답-코드&quot;&gt;자바로는 돌아가는 정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Created&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Keith_Lee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;03&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2019.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Baekjoon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Main_2352&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;40001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;40001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++){&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;            &lt;span class=&quot;nf&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;        &lt;span class=&quot;nf&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;nf&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><category term="Greedy" /><category term="LIS" /><summary type="html">백준 2352번 Link: 2352번: 반도체 설계</summary></entry><entry><title type="html">11058</title><link href="keithlee94.github.io/algorithm/11058/" rel="alternate" type="text/html" title="11058" /><published>2019-02-28T00:00:00+09:00</published><updated>2019-02-28T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/11058</id><content type="html" xml:base="keithlee94.github.io/algorithm/11058/">&lt;h1 id=&quot;백준-11058번&quot;&gt;백준 11058번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/11058&quot;&gt;11058번: 크리보드&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;이번에도 DP 문제.&lt;/p&gt;

&lt;p&gt;예전에 풀었어야 했는데 그땐 DP에 대해 너무 자신이 없어서 쫄아서 패스했던 기억이 난다.&lt;/p&gt;

&lt;p&gt;이번에 DP를 제대로 공부하는 김에 풀어봤는데, 생각보다 금방 점화식을 찾아냈다.&lt;/p&gt;

&lt;p&gt;물론 여러번 시도해보긴 했지만, 생각했던 점화식이 맞았다.&lt;/p&gt;

&lt;p&gt;점화식에 대해 설명하자면 다음과 같다.&lt;/p&gt;

&lt;p&gt;현재의 DP 인덱스가 i라고 가정하자.&lt;/p&gt;

&lt;p&gt;우선 A만 누르는 경우는 직전 DP값에다 1을 더한 값이다.&lt;/p&gt;

&lt;p&gt;이는 곧 DP[i] = DP[i-1] + 1과 같다.&lt;/p&gt;

&lt;p&gt;이 다음부터가 꽤 복잡한데, 경우는 다음과 같다.&lt;/p&gt;

&lt;p&gt;1) 현재 기준 3번 전 DP에서 Ctrl + A를 눌러 그때 입력된 A들을 모두 선택하고, 2번 전 DP에서 Ctrl + C를 눌러 선택된 것을 복사한 다음 1번 전 DP에서 Ctrl + V를 눌러 복사된 내용을 붙여넣는 경우&lt;/p&gt;

&lt;p&gt;이는 곧 DP[i-3]에다가 DP[i-3]을 한번 더 쓰는 것과 같다.&lt;/p&gt;

&lt;p&gt;따라서 DP[i] = 2 * DP[i-3] 이다.&lt;/p&gt;

&lt;p&gt;2) 현재 기준 4번 전 DP에서 Ctrl + A를 눌러 그때 입력된 A들을 모두 선택하고, 3번 전 DP에서 Ctrl + C를 눌러 선택된 것을 복사한 다음 2번 전, 1번 전 DP에서 Ctrl + V를 눌러 복사된 내용을 붙여넣는 경우&lt;/p&gt;

&lt;p&gt;이는 곧 DP[i-4]를 3번 쓰는 것과 같으므로, DP[i] = 3 * DP[i-4] 이다.&lt;/p&gt;

&lt;p&gt;이 과정을 DP[0] * (i-1)까지 반복한다.&lt;/p&gt;

&lt;p&gt;이 모든 경우의 수들의 최대값이 현재 DP값이 된다.&lt;/p&gt;

&lt;p&gt;정답을 얻기 위해 예전 정답을 쌓아 나간다는 생각을 어거지로라도 하다 보니 점화식이 조금은 보이는 것 같다.&lt;/p&gt;

&lt;p&gt;이런식으로 DP를 정복할 수 있을것 같다는 자신감을 좀 갖게 해준 문제였다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 26/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int N;
long long DP[101];

long long max(vector&amp;lt;long long&amp;gt; v){
    long long result = -1;

    for(int i=0; i&amp;lt;v.size(); i++){
        if(v[i] &amp;gt; result){
            result = v[i];
        }
    }

    return result;
}

int main(){
    cin &amp;gt;&amp;gt; N;

    bzero(DP, sizeof(DP));

    DP[0] = 0;
    DP[1] = 1;
    DP[2] = 2;
    DP[3] = 3;
    DP[4] = 4;
    DP[5] = 5;
    DP[6] = 6;

    for(int i=7; i&amp;lt;=N; i++){
        vector&amp;lt;long long&amp;gt; temp;

        for(int j=3; j&amp;lt;=i; j++){
            temp.push_back(DP[i-j]*(j-1));
        }

        DP[i] = max(temp);
    }

    cout &amp;lt;&amp;lt; DP[N] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 11058번 Link: 11058번: 크리보드</summary></entry><entry><title type="html">1890</title><link href="keithlee94.github.io/algorithm/1890/" rel="alternate" type="text/html" title="1890" /><published>2019-02-26T00:00:00+09:00</published><updated>2019-02-26T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1890</id><content type="html" xml:base="keithlee94.github.io/algorithm/1890/">&lt;h1 id=&quot;백준-1890번&quot;&gt;백준 1890번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1890&quot;&gt;1890번: 점프&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;오늘도 DP문제.&lt;/p&gt;

&lt;p&gt;옆에서 친구가 풀던거 같이 한번 풀어봤는데, 조금 고전했다.&lt;/p&gt;

&lt;p&gt;처음에는 BFS로 풀어보려고 했는데 문제 자체가 BFS로 풀기에는 조건이 적당하지 않아서 무한루프로 끝났다.&lt;/p&gt;

&lt;p&gt;다른 방법으로 풀 수 있는지 찾아보던 중 어떻게든 규칙을 찾아서 DP로 풀어야겠다는 생각을 했고, 고민끝에 규칙을 찾아 샘플 케이스를 돌려보니 맞았다.&lt;/p&gt;

&lt;p&gt;구현하는데 인덱스가 헷갈려서 살짝 애먹긴 했지만 무난히 맞았다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 26/02/2019.
//

#include &amp;lt;iostream&amp;gt;

using namespace std;

int N;

int map[101][101] = {-1, };
long long DP[101][101] = {0, };

int main(){
    cin &amp;gt;&amp;gt; N;

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=N; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    DP[1][1] = 1;

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=N; j++){
            if(i == j &amp;amp;&amp;amp; i == 0){
                continue;
            }

            for(int k=0; k&amp;lt;j; k++){
                if(k + map[i][k] == j){
                    DP[i][j] += DP[i][k];
                }
            }

            for(int k=0; k&amp;lt;i; k++){
                if(k + map[k][j] == i){
                    DP[i][j] += DP[k][j];
                }
            }
        }
    }

//    for(int i=1; i&amp;lt;=N; i++){
//        for(int j=1; j&amp;lt;=N; j++){
//            cout &amp;lt;&amp;lt; DP[i][j] &amp;lt;&amp;lt; ' ';
//        }
//        cout &amp;lt;&amp;lt; '\n';
//    }

    cout &amp;lt;&amp;lt; DP[N][N] &amp;lt;&amp;lt; '\n';
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 1890번 Link: 1890번: 점프</summary></entry><entry><title type="html">11060</title><link href="keithlee94.github.io/algorithm/11060/" rel="alternate" type="text/html" title="11060" /><published>2019-02-26T00:00:00+09:00</published><updated>2019-02-26T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/11060</id><content type="html" xml:base="keithlee94.github.io/algorithm/11060/">&lt;h1 id=&quot;백준-11060번&quot;&gt;백준 11060번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/11060&quot;&gt;11060번: 점프 점프&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;역시 DP문제다.&lt;/p&gt;

&lt;p&gt;옆에서 친구가 풀던 문제여서 한번 풀어봤는데, 앞에서 풀었던 문제에서 찾아낸 규칙과 유사한 규칙으로 풀린다는 점을 알아냈다.&lt;/p&gt;

&lt;p&gt;될까 해서 돌려보니 역시 성공.&lt;/p&gt;

&lt;p&gt;이번에도 코드는 정말 짧다.&lt;/p&gt;

&lt;p&gt;하루에 DP를 2문제나 풀어내다니 내 자신이 살짝 놀랍다.&lt;/p&gt;

&lt;p&gt;이런식으로 DP에 대한 두려움을 좀 없앨 수 있으면 좋겠다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 26/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int N;

int map[1001];
int DP[1001];

int min(vector&amp;lt;int&amp;gt; v){
    int result = 99999;

    for(int i=0; i&amp;lt;v.size(); i++){
        if(result &amp;gt; v[i]){
            result = v[i];
        }
    }

    return result;
}

int main(){
    bzero(DP, sizeof(DP));
    bzero(map, sizeof(map));
    cin &amp;gt;&amp;gt; N;

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; map[i];
    }

    for(int i=2; i&amp;lt;=N; i++){
        vector&amp;lt;int&amp;gt; temp;

        for(int j=1; j&amp;lt;i; j++){
            if(j + map[j] &amp;gt;= i){
                temp.push_back(DP[j] + 1);
            }
        }

        DP[i] = min(temp);
    }

    if(DP[N] == 99999){
        DP[N] = -1;
    }

    cout &amp;lt;&amp;lt; DP[N] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 11060번 Link: 11060번: 점프 점프</summary></entry><entry><title type="html">1309</title><link href="keithlee94.github.io/algorithm/1309/" rel="alternate" type="text/html" title="1309" /><published>2019-02-25T00:00:00+09:00</published><updated>2019-02-25T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1309</id><content type="html" xml:base="keithlee94.github.io/algorithm/1309/">&lt;h1 id=&quot;백준-1309번&quot;&gt;백준 1309번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1309&quot;&gt;1309번: 동물원&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;오늘은 DP를 배워서 이제 한동안 DP문제에 매달릴 예정이다.&lt;/p&gt;

&lt;p&gt;그 중에서도 아주 간단한 문제를 하나 풀었다.&lt;/p&gt;

&lt;p&gt;정말 기본적인 문제라고 할 수 있는데, 몇개 케이스 따져보며 규칙 찾으면 바로 풀리는 문제다.&lt;/p&gt;

&lt;p&gt;역시 DP문제답게 규칙만 찾으면 구현은 간단히 끝난다.&lt;/p&gt;

&lt;p&gt;이번 기회에 DP에 대해 확실히 정복하고 갈 작정이다.&lt;/p&gt;

&lt;p&gt;여전히 갈길이 멀지만, 화이팅.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;///
// Created by Keith_Lee on 25/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int N;

long long zoo(int n){
    long long DP[n+1];
    bzero(DP, sizeof(DP));

    DP[0] = 0;
    DP[1] = 3;
    DP[2] = 7;

    for(int i=3; i&amp;lt;=n; i++){
        DP[i] = (2 * DP[i-1] + DP[i-2]) % 9901;
    }

    return DP[n];
}

int main(){
    cin &amp;gt;&amp;gt; N;

    cout &amp;lt;&amp;lt; zoo(N) &amp;lt;&amp;lt; '\n';
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 1309번 Link: 1309번: 동물원</summary></entry><entry><title type="html">2250</title><link href="keithlee94.github.io/algorithm/2250/" rel="alternate" type="text/html" title="2250" /><published>2019-02-22T00:00:00+09:00</published><updated>2019-02-22T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2250</id><content type="html" xml:base="keithlee94.github.io/algorithm/2250/">&lt;h1 id=&quot;백준-2250번&quot;&gt;백준 2250번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2250&quot;&gt;2250번: 트리의 높이와 너비&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;이번엔 DFS 문제다.&lt;/p&gt;

&lt;p&gt;문제 보고나서 트리 그리는 규칙 이해하는데만 한참 걸린것 같다.&lt;/p&gt;

&lt;p&gt;아무튼 이해하고 나서 트리를 직접 그려가면서 규칙을 찾아봤는데,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;우선 루트부터 찾은 다음 시작&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;루트 기준으로 왼쪽 방향으로 DFS시 만나는 가장 마지막 노드가 트리의 가장 왼쪽 노드&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;루트 기준으로 오른쪽 방향으로 DFS시 만나는 가장 마지막 노드가 트리의 가장 오른쪽 노드&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;루트 왼쪽 자식에서 오른쪽으로 DFS시 만나는 가장 마지막 노드가 루트 바로 왼쪽 노드&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;루트 오른쪽 자식에서 왼쪽으로 DFS시 만나는 가장 마지막 노드가 루트 바로 오른쪽 노드&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 5가지 규칙을 찾았다.&lt;/p&gt;

&lt;p&gt;이 규칙대로 트리를 만들고 문제를 풀어보려 했는데, 생각처럼 되지 않았다.&lt;/p&gt;

&lt;p&gt;이 5가지 말고 내가 놓치고 있는 부분이 무엇인지 계속 생각해봤는데, 한가지 큰 부분을 놓치고 있었다.&lt;/p&gt;

&lt;p&gt;이 트리를 그리는 규칙이 트리를 inorder 방식으로 탐색하는 순서와 같다는 점.&lt;/p&gt;

&lt;p&gt;이 규칙 찾는데 하루는 더 걸린것 같다.&lt;/p&gt;

&lt;p&gt;찾고 나니 푸는데 걸리는 시간은 순식간이었다.&lt;/p&gt;

&lt;p&gt;트리의 각 노드들의 레벨만 구하면 되니까.&lt;/p&gt;

&lt;p&gt;이 문제 알고리즘 분류가 DFS, 트리였는데 BFS를 넣어야 되지 않나 하는 생각도 들었다.&lt;/p&gt;

&lt;p&gt;레벨 찾는데 사용한 알고리즘이 BFS였기 때문.&lt;/p&gt;

&lt;p&gt;풀고 나니 나에게 실망스러웠는데, 그새 inorder, preorder, postorder 방식으로 트리 탐색하는 알고리즘을 까먹었다는 점 때문이다.&lt;/p&gt;

&lt;p&gt;평소에 잘 알고 있었다면 트리 그리는 규칙 보자마자 아 이거 루트 찾아서 inorder로 탐색하면 끝나는 문제구나 했을텐데…&lt;/p&gt;

&lt;p&gt;아무튼 늦게라도 떠올랐다는것 자체는 신기할 따름이다.&lt;/p&gt;

&lt;p&gt;아직 갈길이 멀다는 생각밖에 안든다…&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 21/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct Node{
    int num = -1;
    int left = 0;
    int right = 0;
    int parent = -1;
    int level = -1;
    int location = 0;
};

int N;
int lastLevel = 0; // 트리 최대 레벨
int place = 1;

Node nodeTree[10001]; // 입력따라 트리 저장할 공간
bool visit[10001] = {false, };

void inOrder(int start){
    if(!visit[nodeTree[start].left]){
        inOrder(nodeTree[start].left);
    }

    nodeTree[start].location = place++;
    visit[start] = true;

    if(!visit[nodeTree[start].right]){
        inOrder(nodeTree[start].right);
    }
}

void BFS(Node start){ // 각 노드들의 레벨을 찾는다.
    int level = 1;
    queue&amp;lt;Node&amp;gt; Queue;
    vector&amp;lt;Node&amp;gt; nodes;

    Queue.push(start);

    while(!Queue.empty()){
        nodes.clear();

        while(!Queue.empty()){
            Node temp = Queue.front();
            Queue.pop();
            nodes.push_back(temp);
        }

        for(int i=0; i&amp;lt;nodes.size(); i++){
            Node current = nodes[i];
            nodeTree[current.num].level = level;

            if(current.left != -1){
                Queue.push(nodeTree[current.left]);
            }
            if(current.right != -1){
                Queue.push(nodeTree[current.right]);
            }
        }

        level++;
    }
}

int main(){
    visit[0] = true;
    cin &amp;gt;&amp;gt; N;

    int nodeNum;
    int leftChild;
    int rightChild;

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; nodeNum &amp;gt;&amp;gt; leftChild &amp;gt;&amp;gt; rightChild;

        nodeTree[nodeNum].num = nodeNum;
        if(leftChild == -1){
            nodeTree[nodeNum].left = 0;
        }
        else{
            nodeTree[nodeNum].left = leftChild;
            nodeTree[leftChild].parent = nodeNum;
        }

        if(rightChild == -1){
            nodeTree[nodeNum].right = 0;
        }
        else{
            nodeTree[nodeNum].right = rightChild;
            nodeTree[rightChild].parent = nodeNum;
        }
    }

    int root = 0;

    for(int i=1; i&amp;lt;=N; i++){
        if(nodeTree[i].parent == -1){
            root = nodeTree[i].num;
            break;
        }
    }

    BFS(nodeTree[root]); // 각 노드의 레벨을 지정한다.

    inOrder(root);

    for(int i=1; i&amp;lt;=N; i++){
        if(lastLevel &amp;lt; nodeTree[i].level){
            lastLevel = nodeTree[i].level;
        }
    }

    int maxWidth = 0;
    int maxLevel = 0;

    vector&amp;lt;int&amp;gt; levels;
    for(int i=1; i&amp;lt;=lastLevel; i++){
        levels.clear();

        for(int j=1; j&amp;lt;=N; j++){
            if(nodeTree[j].level == i){
                levels.push_back(nodeTree[j].location);
            }
        }

        sort(levels.begin(), levels.end());

        int width = levels[levels.size()-1] - levels[0] + 1;

        if(maxWidth &amp;lt; width){
            maxLevel = i;
            maxWidth = width;
        }
    }

    cout &amp;lt;&amp;lt; maxLevel &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; maxWidth &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DFS" /><category term="Tree" /><category term="BFS" /><summary type="html">백준 2250번 Link: 2250번: 트리의 높이와 너비</summary></entry><entry><title type="html">1946</title><link href="keithlee94.github.io/algorithm/1946/" rel="alternate" type="text/html" title="1946" /><published>2019-02-19T00:00:00+09:00</published><updated>2019-02-19T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1946</id><content type="html" xml:base="keithlee94.github.io/algorithm/1946/">&lt;h1 id=&quot;백준-1946번&quot;&gt;백준 1946번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1946&quot;&gt;1946번: 신입 사원&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;오늘도 Greedy문제.&lt;/p&gt;

&lt;p&gt;문제 이해하는데 시간이 좀 오래걸렸다.&lt;/p&gt;

&lt;p&gt;이해하고 나서 풀어보려는데 처음에는 두 등수의 평균을 구한 다음 평균이 높은 절반끼리 비교하는 방식으로 구현했는데, 일단 시간초과가 났다.&lt;/p&gt;

&lt;p&gt;방문 여부를 표시하고 조건에 안맞으면 반복문 중간에서 나가는 방식으로 보완했는데, 이렇게 푸니까 이젠 답이 틀리더라.&lt;/p&gt;

&lt;p&gt;그 다음엔 각각의 등수가 1인 경우들은 반드시 포함시키고, 이 둘에 대해 비교하며 카운트를 늘려가는 방식으로 풀어봤는데, 역시 틀렸다.&lt;/p&gt;

&lt;p&gt;한참 고민하며 반례 찾으러 질문게시판에 들어가봤는데, 반례 찾다가 다른사람의 아이디어를 보고 힌트를 얻어 풀 수 있었다.&lt;/p&gt;

&lt;p&gt;핵심은 한가지 등수로 오름차순 정렬을 하는 것.&lt;/p&gt;

&lt;p&gt;이렇게 하면 두가지 등수 중 한가지 등수만 비교하면 풀린다.&lt;/p&gt;

&lt;p&gt;나머지 한 등수에 대해 정답에 포함시킨 바로 앞 등수보다 크면 포함시키지 않고, 반대의 경우 작은 등수로 바꿔주고 카운트를 하나 늘린 후 이를 반복하는 방식으로 풀 수 있었다.&lt;/p&gt;

&lt;p&gt;아이디어를 짜내보려고 노력한 것까지는 좋았던 것 같으나 핵심을 찾는데에는 도달하지 못했다.&lt;/p&gt;

&lt;p&gt;심지어 한가지 등수로 오름차순 정렬하는것까지는 했는데 그 다음을 생각해내지 못했다는 점이 아쉬웠다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 19/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct candidates{
    int doc, interview;
};

bool compare(candidates &amp;amp;a, candidates &amp;amp;b){
    if(a.doc &amp;gt; b.doc){
        return false;
    }
    return true;
}

int main(){
    int T;

    cin &amp;gt;&amp;gt; T;

    for(int test=0; test&amp;lt;T; test++){
        int N;

        cin &amp;gt;&amp;gt; N;

        vector&amp;lt;candidates&amp;gt; applicants;

        for(int i=0; i&amp;lt;N; i++){
            int doc, interview;

            cin &amp;gt;&amp;gt; doc &amp;gt;&amp;gt; interview;

            applicants.push_back({doc, interview});
        }

        sort(applicants.begin(), applicants.end(), compare);

        int count = 1;

        int standard = applicants[0].interview;

        for(int i=1; i&amp;lt;applicants.size(); i++){
            if(standard &amp;gt; applicants[i].interview){
                standard = applicants[i].interview;
                count++;
            }
        }

        cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Greedy" /><summary type="html">백준 1946번 Link: 1946번: 신입 사원</summary></entry><entry><title type="html">1931</title><link href="keithlee94.github.io/algorithm/1931/" rel="alternate" type="text/html" title="1931" /><published>2019-02-18T00:00:00+09:00</published><updated>2019-02-18T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1931</id><content type="html" xml:base="keithlee94.github.io/algorithm/1931/">&lt;h1 id=&quot;백준-1931번&quot;&gt;백준 1931번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1931&quot;&gt;1931번: 회의실배정&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;Greedy 알고리즘의 대표격인 문제다.&lt;/p&gt;

&lt;p&gt;예전에 한번 풀어봤던것 같긴 한데 그때도 틀렸다.&lt;/p&gt;

&lt;p&gt;마음 다잡고 다시한번 풀어봤는데, 답이 맞는것 같으면서도 계속 틀렸다고 나오더라.&lt;/p&gt;

&lt;p&gt;어떤 부분에서 문제가 있나 해서 질문게시판 돌아다니면서 반례들을 찾아봤는데, 크게 2가지 문제가 있었다.&lt;/p&gt;

&lt;p&gt;첫번째는 끝나는 시간이 같은 경우 시작하는 시간이 빠른 회의가 먼저 오도록 정렬되어야 한다는 점.&lt;/p&gt;

&lt;p&gt;두번째는 배정 가능한 회의에 포함시킬때 그 회의를 포함하였음을 표시하여 중복으로 포함시켜선 안된다는 점.&lt;/p&gt;

&lt;p&gt;첫번째 문제는 정렬 함수를 좀 바꿔서 해결했다.&lt;/p&gt;

&lt;p&gt;두번째 문제는 방문 여부를 어떻게 표시할지 고민하다 1부터 2147483647까지의 bool형태의 배열을 만들까 해봤다.&lt;/p&gt;

&lt;p&gt;용량이 용량이라 그런지 컴파일 자체가 안되더라.&lt;/p&gt;

&lt;p&gt;어떻게할지 고민하다가 구조체에 방문 여부도 포함하도록 바꿔서 제출해보니 바로 맞았다.&lt;/p&gt;

&lt;p&gt;Greedy나 BFS나 DFS나 방문여부 표시해주는게 참 중요한 것 같다.&lt;/p&gt;

&lt;p&gt;몇년전부터 못풀던 문제였는데 오늘에서라도 풀어서 기분은 좋다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 18/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

struct meeting{
    int start, end;
    bool visit;
};

int N;

bool compare(meeting a, meeting b){
    if(a.end &amp;lt; b.end){
        return true;
    }
    else if(a.end == b.end){
        if(a.start &amp;lt; b.start){
            return true;
        }
    }
    return false;
}

int main(){
    cin &amp;gt;&amp;gt; N;

    vector&amp;lt;meeting&amp;gt; meetings;

    int start, end;

    for(int i=0; i&amp;lt;N; i++){
        cin &amp;gt;&amp;gt; start &amp;gt;&amp;gt; end;

        meetings.push_back({start, end, false});
    }

    sort(meetings.begin(), meetings.end(), compare);

    vector&amp;lt;meeting&amp;gt; available;
    available.push_back(meetings[0]);
    meetings[0].visit = true;

    for(int i=0; i&amp;lt;meetings.size(); i++){
        int currentEnd = available[available.size()-1].end;

        if(meetings[i].start &amp;gt;= currentEnd &amp;amp;&amp;amp; !meetings[i].visit){
            available.push_back(meetings[i]);
        }
    }

    cout &amp;lt;&amp;lt; available.size() &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Greedy" /><summary type="html">백준 1931번 Link: 1931번: 회의실배정</summary></entry><entry><title type="html">16235</title><link href="keithlee94.github.io/algorithm/16235/" rel="alternate" type="text/html" title="16235" /><published>2019-02-17T00:00:00+09:00</published><updated>2019-02-17T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/16235</id><content type="html" xml:base="keithlee94.github.io/algorithm/16235/">&lt;h1 id=&quot;백준-16235번&quot;&gt;백준 16235번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/16235&quot;&gt;16235번: 나무 재테크&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;작년 삼성 기출문제.&lt;/p&gt;

&lt;p&gt;IM쪽 기출문제였는데, 여기 시험보고 온 친구들이 전부 못풀어서 멘탈 터져서 온게 기억이 난다.&lt;/p&gt;

&lt;p&gt;풀기 시작한게 목요일이었는데, 목요일에는 별 생각없는 노가다로 풀어봤는데 테스트케이스 3개정도 맞히고 나머지 못맞혀서 왜그럴지 고민해봤다.&lt;/p&gt;

&lt;p&gt;그렇게 고민해보다 금요일에는 큐를 써서 한 레벨에 대해 전부 뽑아내고 1년을 진행하는 방식으로 해봤다.&lt;/p&gt;

&lt;p&gt;그래도 안풀려서 다시 고민했는데, 토요일엔 놀다가 일요일 와서야 풀었다.&lt;/p&gt;

&lt;p&gt;매우 단순한 방법으로 해결했는데, 내가 짠 코드대로면 봄에 죽은 나무가 벡터에서는 살아있기 때문에 죽은 나무의 나이를 -1로 바꾸고, 가을에 번식하는 조건에 나이가 0보다 클때로 한정함으로써 풀 수 있었다.&lt;/p&gt;

&lt;p&gt;시뮬레이션 문제인것 같은데, 내가 시험볼때 풀어봤던 큐브 문제에 비해서는 훨씬 깔끔하게 답을 구할 수 있었던 문제인것 같다.&lt;/p&gt;

&lt;p&gt;뭐 그때의 나였다면 이런 문제 던져줘도 못풀었을것 같긴 하다만…&lt;/p&gt;

&lt;p&gt;어쨌든 곧 시험볼때까지 실력을 꾸준히 키워야겠다는 생각이 든다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 14/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct Tree{
    int x, y, age;
};

int N, M, K;

int map[11][11] = {0, };
int winterAdd[11][11] = {0, };
int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};

queue&amp;lt;Tree&amp;gt; Queue;

int compare(const Tree &amp;amp;t1, const Tree &amp;amp;t2){
    if(t1.age &amp;lt; t2.age){
        return true;
    }
    return false;
}

int BFS(){
    for(int i=0; i&amp;lt;K; i++){
        vector&amp;lt;Tree&amp;gt; lives;
        vector&amp;lt;Tree&amp;gt; deads;

        while(!Queue.empty()){
            lives.push_back(Queue.front());
            Queue.pop();
        }

        sort(lives.begin(), lives.end(), compare);

        for(int j=0; j&amp;lt;lives.size(); j++) {
            if (map[lives[j].x][lives[j].y] &amp;gt;= lives[j].age) { // 봄
                map[lives[j].x][lives[j].y] -= lives[j].age;
                Queue.push({lives[j].x, lives[j].y, lives[j].age + 1});
                lives[j].age++;
            }
            else {
                deads.push_back({lives[j].x, lives[j].y, lives[j].age});
                lives[j].age = -1;
            }

            if(lives[j].age &amp;gt; 0 &amp;amp;&amp;amp; lives[j].age % 5 == 0){ // 가을
                for(int k=0; k&amp;lt;8; k++){
                    int nextX = lives[j].x + dx[k];
                    int nextY = lives[j].y + dy[k];

                    if(nextX &amp;gt; 0 &amp;amp;&amp;amp; nextX &amp;lt;= N &amp;amp;&amp;amp; nextY &amp;gt; 0 &amp;amp;&amp;amp; nextY &amp;lt;= N){
                        Queue.push({nextX, nextY, 1});
                    }
                }
            }
        }

        for(int k=0; k&amp;lt;deads.size(); k++){ // 여름
            map[deads[k].x][deads[k].y] += deads[k].age / 2;
        }

        for(int k=1; k&amp;lt;=N; k++){ // 겨울
            for(int l=1; l&amp;lt;=N; l++){
                map[k][l] += winterAdd[k][l];
            }
        }
    }

    return Queue.size();
}

int main(){
    for(int i=0; i&amp;lt;=10; i++){
        for(int j=0; j&amp;lt;=10; j++){
            map[i][j] = 5;
        }
    }

    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M &amp;gt;&amp;gt; K;

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=N; j++){
            cin &amp;gt;&amp;gt; winterAdd[i][j];
        }
    }

    int x, y, z;

    for(int i=0; i&amp;lt;M; i++){
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; z;

        Queue.push({x, y, z});
    }

    cout &amp;lt;&amp;lt; BFS() &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Simulation" /><category term="Brute Force" /><summary type="html">백준 16235번 Link: 16235번: 나무 재테크</summary></entry><entry><title type="html">9019</title><link href="keithlee94.github.io/algorithm/9019/" rel="alternate" type="text/html" title="9019" /><published>2019-02-13T00:00:00+09:00</published><updated>2019-02-13T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/9019</id><content type="html" xml:base="keithlee94.github.io/algorithm/9019/">&lt;h1 id=&quot;백준-9019번&quot;&gt;백준 9019번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/9019&quot;&gt;9019번: DSLR&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;예전에 풀어보다가 실패해서 그대로 접어뒀던 문제.&lt;/p&gt;

&lt;p&gt;알고리즘 스터디에서 BFS문제집을 만들었는데 만드는 김에 한번 다시 풀어볼 생각으로 넣었다.&lt;/p&gt;

&lt;p&gt;그리고 오늘 다시 풀어서 드디어 맞혔다.&lt;/p&gt;

&lt;p&gt;우선 그전에 짰던 코드는 정말 터무니없는 코드였던 것 같다.&lt;/p&gt;

&lt;p&gt;아예 새로운 마음으로 짰는데, 처음에 돌려봤을땐 메모리 초과가 났다.&lt;/p&gt;

&lt;p&gt;메모리 초과가 날만한 여지들을 전부 없애보려고 큐를 전역변수로 만들어도 보고 큐를 싹 비워도 봤는데 메모리 초과가 잡히지 않더라.&lt;/p&gt;

&lt;p&gt;질문게시판을 좀 찾아보던 중 나랑 비슷한 처지인 사람이 글을 올린걸 봤는데, 중복방문을 안하면 메모리 초과 문제를 해결할 수 있을 것이라는 답변을 보았다.&lt;/p&gt;

&lt;p&gt;그런데 그대로 실천해보니 이번엔 답이 틀렸다.&lt;/p&gt;

&lt;p&gt;무슨 문제일까 해서 모든 경우를 다 찍어봤는데, C++의 모듈러 연산과 내가 아는 모듈러 연산은 다르다는 점이 문제였다.&lt;/p&gt;

&lt;p&gt;-1을 10000으로 모듈러 연산을 한다고 생각해보자.&lt;/p&gt;

&lt;p&gt;모듈러 연산의 피연산자가 음수이므로 답은 9999가 되어야 한다.&lt;/p&gt;

&lt;p&gt;그런데 코드로 옮겨 보니, 9999가 아니라 -1이 그대로 나오더라.&lt;/p&gt;

&lt;p&gt;사실 문제 조건에도 -1이 나올 경우 9999로 만들라는 조건이 있었는데, 음수에 대한 모듈러 연산 한번이면 다 해결될줄 알았다.&lt;/p&gt;

&lt;p&gt;이 부분까지 잡아내고 돌려보니 바로 맞았다.&lt;/p&gt;

&lt;p&gt;내가 아는 상식과 컴퓨터의 연산 방식이 다르다는 점을 알게 된 문제였다.&lt;/p&gt;

&lt;p&gt;또, 난 보통 BFS문제를 풀때 방문 여부를 체크해주는 것을 자주 까먹는편인데 시간도 시간이지만 메모리상으로도 문제가 발생할 수 있다는 점을 알게 되었다.&lt;/p&gt;

&lt;p&gt;앞으로 BFS문제를 풀때는 방문 여부 체크하는 부분을 빼먹지 말아야겠다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 13/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int T;
int A, B;
string result;

bool visit[10000] = {false, };
char delta[4] = {'D', 'S', 'L', 'R'};

queue&amp;lt;pair&amp;lt;int, string&amp;gt;&amp;gt; Queue;

void BFS(){
    Queue.push(make_pair(A, &quot;&quot;));
    visit[A] = true;

    while(!Queue.empty()){
        int current = Queue.front().first;
        string currentAnswer = Queue.front().second;
        Queue.pop();

        if(current == B){
            result = currentAnswer;
            break;
        }

        for(int i=0; i&amp;lt;4; i++){
            int next = 0;
            string temp = &quot;&quot;;
            if(delta[i] == 'D'){
                next = (current * 2) % 10000;
            }
            else if(delta[i] == 'S'){
                if(current - 1 &amp;gt;= 0){
                    next = (current - 1) % 10000;
                }
                else{
                    next = 9999;
                }
            }
            else if(delta[i] == 'L'){
                next += (current % 1000) * 10;
                next += current / 1000;
            }
            else if(delta[i] == 'R'){
                next += current / 10;
                next += (current % 10) * 1000;
            }

            if(!visit[next]){
                visit[next] = true;
                temp += delta[i];
                Queue.push(make_pair(next, currentAnswer + temp));
            }
        }
    }
}

int main(){
    cin &amp;gt;&amp;gt; T;

    for(int test=0; test&amp;lt;T; test++){
        result = &quot;&quot;;
        bzero(visit, sizeof(visit));

        cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B;

        BFS();

        while(!Queue.empty()){
            Queue.pop();
        }

        cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Brute Force" /><category term="BFS" /><summary type="html">백준 9019번 Link: 9019번: DSLR</summary></entry></feed>