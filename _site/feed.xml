<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="keithlee94.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="keithlee94.github.io/" rel="alternate" type="text/html" /><updated>2019-02-12T23:59:18+09:00</updated><id>keithlee94.github.io/feed.xml</id><title type="html">KeithLog</title><subtitle>SSAFY 교육내용, 알고리즘 문제풀이 정리하여 업로드할 블로그</subtitle><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><entry><title type="html">14500</title><link href="keithlee94.github.io/algorithm/14500/" rel="alternate" type="text/html" title="14500" /><published>2019-02-12T00:00:00+09:00</published><updated>2019-02-12T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/14500</id><content type="html" xml:base="keithlee94.github.io/algorithm/14500/">&lt;h1 id=&quot;백준-14500번&quot;&gt;백준 14500번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/14500&quot;&gt;14500번: 테트로미노&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;최대 500*500의 지도 위에 블럭을 놓을 수 있는 모든 경우를 고려하여 블럭이 놓인 부분에 위치한 숫자 합의 최대값을 찾는 문제.&lt;/p&gt;

&lt;p&gt;우선 블럭을 회전시키거나 대칭시켜보며 나올 수 있는 모든 경우를 생각해보았다.&lt;/p&gt;

&lt;p&gt;다 해보니 꽤 많았는데, 19가지였다.&lt;/p&gt;

&lt;p&gt;500*500짜리 지도에서 최악의 경우 500 * 500 * 19 = 4750000가지 경우를 전부 고려해봐야 하는데 이게 시간초과 안나고 가능할까? 라는 생각이 먼저 들었다.&lt;/p&gt;

&lt;p&gt;처음에는 19가지 도형이 전부 들어갈 수 있는 최소한의 넓이인 4*4짜리 map을 따로 만들어 이걸로 맞춰볼 생각을 해봤는데, 이 안에서 나올 수 있는 19가지 도형의 위치 경우의 수를 구해보니 113가지가 되더라.&lt;/p&gt;

&lt;p&gt;이건 아니다 싶어 결국 switch문 안에 19가지 경우를 전부 명시해서 넣고 3중 for문으로 돌렸다.&lt;/p&gt;

&lt;p&gt;조건문이 19가지나 되다 보니 중간에 헷갈려서 조건 잘못쓴 경우도 있었고 계산식 잘못 넣은 경우도 있었다.&lt;/p&gt;

&lt;p&gt;어찌어찌해서 다 잡아내고 돌려봤는데, 시간초과날줄 알았는데 잘 돌아가서 정답으로 나오더라.&lt;/p&gt;

&lt;p&gt;DFS나 BFS처럼 알려진 방법 말고 이런 무식한 방법으로 풀리는 문제도 있구나 하는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;아마 시뮬레이션 문제를 풀게 된다면 이런 문제가 아닐까라는 생각도 들었고.&lt;/p&gt;

&lt;p&gt;여튼 그리 깊게 생각하지 않아도 풀 수 있는 문제였다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 12/02/2019.
//

#include &amp;lt;iostream&amp;gt;

using namespace std;

int N, M;
int map[500][500] = {0, };
int result = 0;

int max(int a, int b){
    return a &amp;lt; b ? b : a;
}

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;M; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;M; j++){
            for(int shape=0; shape&amp;lt;19; shape++) {
                int sum = 0;

                switch (shape) {
                    case 0:
                        if(j+3 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i][j+3];
                        }
                        break;
                    case 1:
                        if(i+3 &amp;lt; N){
                            sum += map[i][j] + map[i+1][j] + map[i+2][j] + map[i+3][j];
                        }
                        break;
                    case 2:
                        if(i+1 &amp;lt; N &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i+1][j] + map[i][j+1] + map[i+1][j+1];
                        }
                        break;
                    case 3:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i+1][j] + map[i+2][j] + map[i+2][j+1];
                        }
                        break;
                    case 4:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j-1 &amp;gt;= 0){
                            sum += map[i][j] + map[i+1][j] + map[i+2][j] + map[i+2][j-1];
                        }
                        break;
                    case 5:
                        if(i+1 &amp;lt; N &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i+1][j];
                        }
                        break;
                    case 6:
                        if(i+1 &amp;lt; N &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i+1][j+2];
                        }
                        break;
                    case 7:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i+1][j+1] + map[i+2][j+1];
                        }
                        break;
                    case 8:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i+1][j] + map[i+2][j];
                        }
                        break;
                    case 9:
                        if(i-1 &amp;gt;= 0 &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i-1][j+2];
                        }
                        break;
                    case 10:
                        if(i+1 &amp;lt; N &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i+1][j] + map[i+1][j+1] + map[i+1][j+2];
                        }
                        break;
                    case 11:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i+1][j] + map[i+1][j+1] + map[i+2][j+1];
                        }
                        break;
                    case 12:
                        if(i-1 &amp;gt;= 0 &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i-1][j+1] + map[i-1][j+2];
                        }
                        break;
                    case 13:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j-1 &amp;gt;= 0){
                            sum += map[i][j] + map[i+1][j] + map[i+1][j-1] + map[i+2][j-1];
                        }
                        break;
                    case 14:
                        if(i+1 &amp;lt; N &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i+1][j+1] + map[i+1][j+2];
                        }
                        break;
                    case 15:
                        if(i+1 &amp;lt; N &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i+1][j+1];
                        }
                        break;
                    case 16:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; i-1 &amp;gt;= 0 &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i+1][j+1] + map[i-1][j+1];
                        }
                        break;
                    case 17:
                        if(i-1 &amp;gt;= 0 &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i-1][j+1] + map[i][j+2];
                        }
                        break;
                    case 18:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i+1][j] + map[i+2][j] + map[i+1][j+1];
                        }
                        break;
                }

                result = max(sum, result);
            }
        }
    }

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Brute Force" /><summary type="html">백준 14500번 Link: 14500번: 테트로미노</summary></entry><entry><title type="html">2309</title><link href="keithlee94.github.io/algorithm/2309/" rel="alternate" type="text/html" title="2309" /><published>2019-02-11T00:00:00+09:00</published><updated>2019-02-11T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2309</id><content type="html" xml:base="keithlee94.github.io/algorithm/2309/">&lt;h1 id=&quot;백준-2309번&quot;&gt;백준 2309번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2309&quot;&gt;2309번: 일곱 난쟁이&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;평범하게 모든 경우를 따져가며 조건 맞으면 출력해주는 DFS 문제였다.&lt;/p&gt;

&lt;p&gt;9개 중 7개를 뽑아 합이 100이 될때 리턴해주면 되는 문제다.&lt;/p&gt;

&lt;p&gt;요즘 DFS를 활용한 완전탐색 문제를 많이 접하는 것 같다.&lt;/p&gt;

&lt;p&gt;이건 그중에서도 기초적인 문제인듯 하다.&lt;/p&gt;

&lt;p&gt;분명 방학 시작 전까지는 이런 쉬운 문제도 쩔쩔매며 어떻게 풀지 고민했을 것 같은데, 어느새 아 이거 DFS로 조합 구해서 풀면 되는 문제네 하고 떠오를 수준이 되었다는 점이 마냥 신기하다.&lt;/p&gt;

&lt;p&gt;이런식으로 DP도 정복하는 것이 목표이다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 11/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int littles[9] = {0, };
bool visit[9] = {false, };
vector&amp;lt;int&amp;gt; intermediate;

void DFS(int index, int count){
    if(index == 9){
        if(count == 7){
            int sum = 0;

            for(int i=0; i&amp;lt;9; i++){
                if(visit[i]){
                    sum += littles[i];
                }
            }

            if(sum == 100){
                for(int i=0; i&amp;lt;9; i++){
                    if(visit[i]){
                        intermediate.push_back(littles[i]);
                    }
                }
            }
        }

        return;
    }

    visit[index] = true;
    DFS(index+1, count+1);
    visit[index] = false;
    DFS(index+1, count);
}

int main(){
    for(int i=0; i&amp;lt;9; i++){
        cin &amp;gt;&amp;gt; littles[i];
    }

    DFS(0, 0);

    vector&amp;lt;int&amp;gt; result;

    for(int i=0; i&amp;lt;7; i++){
        result.push_back(intermediate[i]);
    }

    sort(result.begin(), result.end());

    for(int i=0; i&amp;lt;result.size(); i++){
        cout &amp;lt;&amp;lt; result[i] &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Brute Force" /><category term="DFS" /><summary type="html">백준 2309번 Link: 2309번: 일곱 난쟁이</summary></entry><entry><title type="html">9663</title><link href="keithlee94.github.io/algorithm/9663/" rel="alternate" type="text/html" title="9663" /><published>2019-02-10T00:00:00+09:00</published><updated>2019-02-10T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/9663</id><content type="html" xml:base="keithlee94.github.io/algorithm/9663/">&lt;h1 id=&quot;백준-9663번&quot;&gt;백준 9663번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/9663&quot;&gt;9663번: N-Queen&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;많이들 알고있는 그 n-queen problem 문제다.&lt;/p&gt;

&lt;p&gt;백트래킹 알고리즘의 교과서같은 문제로, 그냥 DFS 다돌리면 시간 부족해서 안풀릴 문제다.&lt;/p&gt;

&lt;p&gt;짜다가 위키에 있는 소스코드를 봤는데, 내것보단 이게 훨씬 나아보여서 이걸 보고 이해하는 방향으로 했다.&lt;/p&gt;

&lt;p&gt;내가 생각했던 것과의 가장 큰 차이점은 체스판을 1차원 배열로만 표현했다는 점.&lt;/p&gt;

&lt;p&gt;1차원 배열로만 표현한 덕분에 2차원 배열을 순회하는 데 필요한 2중 for문을 단순 1중 for문으로 끝낼 수 있다는 시간적 이점이 있다.&lt;/p&gt;

&lt;p&gt;대각선으로 다른 퀸이 있는지 검사하는 방법을 제일 이해하기 힘들었는데, 우선 지금까지 놓여진 퀸들에 대해 for문을 통해 검사한다.&lt;/p&gt;

&lt;p&gt;이 for문의 iter 값은 곧 i번째 행 j번째 열에 퀸이 있는지를 표현하는 것이더라.&lt;/p&gt;

&lt;p&gt;abs(count - j) == abs(i - map[j])는 count번째 행 i열의 대각 2방향(위쪽, 아래쪽 모두)에 퀸이 있는지 없는지 검사하는 내용이다.&lt;/p&gt;

&lt;p&gt;이 if문에 걸리지 않았다면 퀸을 놓을 수 있는 것이므로 결과값을 1 증가시킨다.&lt;/p&gt;

&lt;p&gt;만약 걸렸다면 즉시 for문을 나가고 바깥쪽 for문을 통해 다음 놓을 수 있는 자리를 찾는다.&lt;/p&gt;

&lt;p&gt;이런식으로 반복하며 답을 찾는 문제다.&lt;/p&gt;

&lt;p&gt;어제만해도 DFS문제에 대해 자신감이 좀 생겼는데 이 문제는 또 다른것 같다.&lt;/p&gt;

&lt;p&gt;체스판을 1차원 배열로 표현하고 대각선방향 검사하는 코드만 봐도 아직 많이 모자라다는 걸 알 수 있었다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 10/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

using namespace std;

int N;
int map[14];
int result = 0;

void DFS(int count){
    if(count == N){
        result++;
        return;
    }

    for(int i=0; i&amp;lt;N; i++){
        bool available = true;

        for(int j=0; j&amp;lt;count; j++){ // 지금까지 놓아진 퀸들을 검사한다.
            if(map[j] == i || abs(count - j) == abs(i - map[j])){
                // map[j] == i: 새로운 퀸을 놓으려는 줄에 이미 다른 퀸이 있다.
                // abs(count - j) == abs(i - map[j]): 새로운 퀸을 놓으려는 위치의 대각선 방향에 이미 다른 퀸이 있다.
                available = false;
                break;
            }
        }

        if(available){
            map[count] = i;
            // count열 i행에 퀸을 배치한다.
            DFS(count+1);
        }
    }
}

int main(){
    cin &amp;gt;&amp;gt; N;

    DFS(0);

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Back Tracking" /><summary type="html">백준 9663번 Link: 9663번: N-Queen</summary></entry><entry><title type="html">12100</title><link href="keithlee94.github.io/algorithm/12100/" rel="alternate" type="text/html" title="12100" /><published>2019-02-09T00:00:00+09:00</published><updated>2019-02-09T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/12100</id><content type="html" xml:base="keithlee94.github.io/algorithm/12100/">&lt;h1 id=&quot;백준-12100번&quot;&gt;백준 12100번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/12100&quot;&gt;12100번: 2048 (Easy)&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;일단 내 힘만으로 풀었다는 것부터 적고간다ㅋㅋㅋㅋ&lt;/p&gt;

&lt;p&gt;DFS를 통해 모든 경우를 고려해봐야 하는 문제였다.&lt;/p&gt;

&lt;p&gt;우선 DFS를 구현하기 전에 map을 어떤 식으로 밀고 같은 수를 합치면 되는지를 먼저 고민해봤다.&lt;/p&gt;

&lt;p&gt;여러가지 방법을 생각해보던 중 벡터를 활용해서 옮겨야 하는 수들을 전부 집어넣고 옮긴 다음 옮겨진 수들을 합치는 방법을 생각해 봤다.&lt;/p&gt;

&lt;p&gt;그런데 이 방법에는 큰 문제가 있는데, 옮기고 합친 다음 다시 옮겨야 한다는 점이었다.&lt;/p&gt;

&lt;p&gt;이를 보완하기 위해 벡터에 옮겨야 하는 수들을 전부 넣고 map을 0으로 바꾼 다음, 그 수들을 비교해서 두 숫자가 같은 숫자이면 합치고 뒤의 숫자를 0으로 바꾼다.&lt;/p&gt;

&lt;p&gt;이렇게 벡터의 내용을 바꿔준 다음, 별도로 큐를 정의하여 벡터를 한번 순회하며 0이 아닌 수를 만나면 큐에 넣는다.&lt;/p&gt;

&lt;p&gt;마지막으로 옮기는 방향에 맞춰 큐의 내용대로 map을 바꿔주는 방법으로 구현하였다.&lt;/p&gt;

&lt;p&gt;메모리상으로는 비효율적이겠지만, 중요한건 시간이니 넘어가자…&lt;/p&gt;

&lt;p&gt;이렇게 옮기는 함수를 구현한 다음, DFS를 구현하였다.&lt;/p&gt;

&lt;p&gt;이 과정에서 많이 고민했는데, 처음에는 DFS의 인자로 DFS 횟수와 map을 주는 방법으로 구현하였다.&lt;/p&gt;

&lt;p&gt;이런식으로 하니 분명 모든 경우의 수를 따지긴 하지만 제출해보니 틀렸는데, 바로 map이 제대로 바뀌지 않는 것이 문제였다.&lt;/p&gt;

&lt;p&gt;처음에는 DFS가 제대로 돌지 않는게 아닌가 싶어서 string으로 모든 경우를 다 출력해봤다. 확인 결과 모든 경우 따지는건 맞더라.&lt;/p&gt;

&lt;p&gt;여기다 map도 같이 찍어보니 map이 제대로 안바뀌는 문제가 있다는 것을 찾아냈다.&lt;/p&gt;

&lt;p&gt;이걸 어떻게 해야 해결할 수 있나 한참 고민하던 중, string으로 찍어본 결과를 이용해보자는 생각을 하게 되었다.&lt;/p&gt;

&lt;p&gt;string에 찍힌 대로 DFS의 종료 조건에서 map을 바꾸는 방법을 생각해 냈고, 이대로 구현해보니 시간초과가 났다.&lt;/p&gt;

&lt;p&gt;DFS 돌때마다 20*20짜리 배열을 계속 돈다고 생각해보면 시간초과 나는게 당연했다.&lt;/p&gt;

&lt;p&gt;이 문제를 해결하기 위해 포인터를 사용했는데, 우선 20*20짜리 배열을 map과 같은 내용을 갖도록 초기화해준 다음 2차원 배열 포인터로 이 배열을 가리키도록 한다.&lt;/p&gt;

&lt;p&gt;이 2차원 배열 포인터를 map 바꿔주는 함수의 인자로 전달하여 map을 5번 바꿔준 다음, 앞에서 만든 20*20짜리 배열의 내용을 갱신해준다. 또 갱신 과정에서 최대값도 같이 갱신해준다.&lt;/p&gt;

&lt;p&gt;이런식으로 구현하여 제출하니 드디어 맞았다고 나왔다.&lt;/p&gt;

&lt;p&gt;DFS로 모든 경우를 다 따져보기만 하면 풀리는 문제였다. 다만 그 경우를 따지기 위한 전처리가 상당히 까다로웠던 문제.&lt;/p&gt;

&lt;p&gt;이제 DFS로 푸는 방법을 좀 이해한 것 같다.&lt;/p&gt;

&lt;p&gt;문제 풀면서 막히는 부분에 대해 어느 부분에서 막히는지 직접 찾아내고 해결했다는 점에서 매우 뿌듯하다.&lt;/p&gt;

&lt;p&gt;앞으로도 이렇게 내 힘만으로 풀어내는 문제들이 많이 있길!!&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 08/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

int N;
int result = 0;
int map[20][20] = {0, };

string progress = &quot;MMMMM&quot;;

int (*push(char direction, int (*tempMap)[20]))[20]{ // 이동시킨 후 바뀐 map 리턴.
    // 상
    if(direction == 'U'){
        for(int i=0; i&amp;lt;N; i++){
            vector&amp;lt;int&amp;gt; toMove; // 위로 이동시킬 숫자들
            queue&amp;lt;int&amp;gt; merge; // 이동 후 같은 숫자일때 합치고 저장

            for(int j=0; j&amp;lt;N; j++){
                if(tempMap[j][i] != 0){ // 위로 이동시킬 숫자가 있으면
                    toMove.push_back(tempMap[j][i]); // 벡터에 넣고
                    tempMap[j][i] = 0; // 숫자 자리를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){
                if(j+1 &amp;lt; toMove.size() &amp;amp;&amp;amp; toMove[j] == toMove[j+1]){ // 벡터 내에서 같은 숫자가 연속될 경우
                    toMove[j] *= 2; // 합친다
                    toMove[j+1] = 0; // 뒷 숫자를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){ // 벡터를 돌면서
                if(toMove[j] != 0){ // 원소가 0이 아니면
                    merge.push(toMove[j]); // 큐에 넣는다.
                }
            }

            int index = 0;

            while(!merge.empty()){ // 큐를 돌면서
                tempMap[index][i] = merge.front(); // 바뀐 숫자를 맵에 반영한다.
                merge.pop();
                index++;
            }
        }
    }

    // 하
    if(direction == 'D'){
        for(int i=0; i&amp;lt;N; i++){
            vector&amp;lt;int&amp;gt; toMove; // 아래로 이동시킬 숫자들
            queue&amp;lt;int&amp;gt; merge; // 이동 후 같은 숫자일때 합치고 저장

            for(int j=N-1; j&amp;gt;=0; j--){ // 아래쪽부터 돌거임
                if(tempMap[j][i] != 0){ // 아래로 이동시킬 숫자가 있으면
                    toMove.push_back(tempMap[j][i]); // 벡터에 넣고
                    tempMap[j][i] = 0; // 숫자 자리를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){
                if(j+1 &amp;lt; toMove.size() &amp;amp;&amp;amp; toMove[j] == toMove[j+1]){ // 벡터 내에서 같은 숫자가 연속될 경우
                    toMove[j] *= 2; // 합친다
                    toMove[j+1] = 0; // 뒷 숫자를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){ // 벡터를 돌면서
                if(toMove[j] != 0){ // 원소가 0이 아니면
                    merge.push(toMove[j]); // 큐에 넣는다.
                }
            }

            int index = 0;

            while(!merge.empty()){ // 큐를 돌면서
                tempMap[N-1-index][i] = merge.front(); // 바뀐 숫자를 맵에 반영한다.
                merge.pop();
                index++;
            }
        }
    }

    // 좌
    if(direction == 'L'){
        for(int i=0; i&amp;lt;N; i++){
            vector&amp;lt;int&amp;gt; toMove; // 왼쪽으로 이동시킬 숫자들
            queue&amp;lt;int&amp;gt; merge; // 이동 후 같은 숫자일때 합치고 저장

            for(int j=0; j&amp;lt;N; j++){
                if(tempMap[i][j] != 0){ // 왼쪽으로 이동시킬 숫자가 있으면
                    toMove.push_back(tempMap[i][j]); // 벡터에 넣고
                    tempMap[i][j] = 0; // 숫자 자리를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){
                if(j+1 &amp;lt; toMove.size() &amp;amp;&amp;amp; toMove[j] == toMove[j+1]){ // 벡터 내에서 같은 숫자가 연속될 경우
                    toMove[j] *= 2; // 합친다
                    toMove[j+1] = 0; // 뒷 숫자를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){ // 벡터를 돌면서
                if(toMove[j] != 0){ // 원소가 0이 아니면
                    merge.push(toMove[j]); // 큐에 넣는다.
                }
            }

            int index = 0;

            while(!merge.empty()){ // 큐를 돌면서
                tempMap[i][index] = merge.front(); // 바뀐 숫자를 맵에 반영한다.
                merge.pop();
                index++;
            }
        }
    }

    // 우
    if(direction == 'R'){
        for(int i=0; i&amp;lt;N; i++){
            vector&amp;lt;int&amp;gt; toMove; // 오른쪽으로 이동시킬 숫자들
            queue&amp;lt;int&amp;gt; merge; // 이동 후 같은 숫자일때 합치고 저장

            for(int j=N-1; j&amp;gt;=0; j--){ // 오른쪽부터 돌거임
                if(tempMap[i][j] != 0){ // 오른쪽으로 이동시킬 숫자가 있으면
                    toMove.push_back(tempMap[i][j]); // 벡터에 넣고
                    tempMap[i][j] = 0; // 숫자 자리를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){
                if(j+1 &amp;lt; toMove.size() &amp;amp;&amp;amp; toMove[j] == toMove[j+1]){ // 벡터 내에서 같은 숫자가 연속될 경우
                    toMove[j] *= 2; // 합친다
                    toMove[j+1] = 0; // 뒷 숫자를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){ // 벡터를 돌면서
                if(toMove[j] != 0){ // 원소가 0이 아니면
                    merge.push(toMove[j]); // 큐에 넣는다.
                }
            }

            int index = 0;

            while(!merge.empty()){ // 큐를 돌면서
                tempMap[i][N-1-index] = merge.front(); // 바뀐 숫자를 맵에 반영한다.
                merge.pop();
                index++;
            }
        }
    }

    return tempMap;
}

void DFS(int count){
    if(count == 5){
        int newMap[20][20] = {0, };
        int (*temp)[20] = newMap;

        for(int i=0; i&amp;lt;N; i++){
            for(int j=0; j&amp;lt;N; j++){
                newMap[i][j] = map[i][j];
            }
        }

        for(int i=0; i&amp;lt;progress.length(); i++){
            temp = push(progress[i], temp);
        }

        for(int i=0; i&amp;lt;N; i++){
            for(int j=0; j&amp;lt;N; j++){
                newMap[i][j] = temp[i][j];
                if(newMap[i][j] &amp;gt; result){
                    result = newMap[i][j];
                }
            }
        }

        return;
    }

    for(int i=1; i&amp;lt;=4; i++){
        if(i == 1){
            progress[count] = 'U';
        }
        else if(i == 2){
            progress[count] = 'D';
        }
        else if(i == 3){
            progress[count] = 'L';
        }
        else if(i == 4){
            progress[count] = 'R';
        }
        DFS(count+1);
    }
}

int main(){
    cin &amp;gt;&amp;gt; N;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;N; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    DFS(0);

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Brute Force" /><category term="DFS" /><summary type="html">백준 12100번 Link: 12100번: 2048 (Easy)</summary></entry><entry><title type="html">2251</title><link href="keithlee94.github.io/algorithm/2251/" rel="alternate" type="text/html" title="2251" /><published>2019-02-07T00:00:00+09:00</published><updated>2019-02-07T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2251</id><content type="html" xml:base="keithlee94.github.io/algorithm/2251/">&lt;h1 id=&quot;백준-2251번&quot;&gt;백준 2251번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2251&quot;&gt;2251번: 물통&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;연휴 시작한 다음날 어떻게 풀지 고민하다 방법만 생각해두고 풀진 않았던 문제.&lt;/p&gt;

&lt;p&gt;생각했던 풀이대로 풀어봤는데 우선 틀리고 시작했다.&lt;/p&gt;

&lt;p&gt;알고리즘 분류는 BFS로 되어 있는데 굳이 BFS를 써야하나…?? 라는 생각이 좀 들었다.&lt;/p&gt;

&lt;p&gt;아무튼 어거지로라도 BFS로 맞춰서 풀어보니 풀렸다.&lt;/p&gt;

&lt;p&gt;통상 아는 BFS와는 좀 다른데, 우선 3개의 물통의 양을 전부 한번에 저장해야 한다는 점이 달랐고 길찾는 BFS는 for문 돌려서 4방향정도 생각해보는게 끝인데 이건 6가지 경우를 전부 하나씩 고려해야 한다는 점이 조금 달랐다.&lt;/p&gt;

&lt;p&gt;BFS를 이렇게도 쓸수 있구나 하는 생각이 들게 된 문제.&lt;/p&gt;

&lt;p&gt;한가지 더 특기하자면 구조체를 직접 정의하고 활용한 첫 문제인 것 같다.&lt;/p&gt;

&lt;p&gt;예전에 한번 3가지였나 4가지 값을 큐에 넣고 썼던 적이 있던것 같은데 그때는 make_pair를 여러번 써서 무식하게 해결했던 것 같다.&lt;/p&gt;

&lt;p&gt;구조체에 익숙해지면 훨씬 우아한 방법으로 해결 가능할듯 하다.&lt;/p&gt;

&lt;p&gt;연휴 내내 놀았으니 이제 다시 또 꾸준히 풀어볼 작정이다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;어림도-없던-코드&quot;&gt;어림도 없던 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 07/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

int main(){
    int A, B, C;

    cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B &amp;gt;&amp;gt; C;

    bool basket[201];

    vector&amp;lt;int&amp;gt; possible;

    if(C &amp;gt; 0){
        if(!basket[C]) {
            possible.push_back(C);
            basket[C] = true;
        }
    }

    if(C - (C-A) &amp;gt;= 0){
        if(!basket[C-A] &amp;amp;&amp;amp; C-A &amp;gt;= 0) {
            possible.push_back(C - A);
            basket[C-A] = true;
        }
    }

    if(C - (C-B) &amp;gt;= 0){
        if(!basket[C-B] &amp;amp;&amp;amp; C-B &amp;gt;= 0){
            possible.push_back(C-B);
            basket[C-B] = true;
        }
    }

    if(C - A &amp;gt;= 0){
        if(!basket[A]){
            possible.push_back(A);
            basket[A] = true;
        }
    }

    if(C - B &amp;gt;= 0){
        if(!basket[B]){
            possible.push_back(B);
            basket[B] = true;
        }
    }

    sort(possible.begin(), possible.end());

    for(int i=0; i&amp;lt;possible.size(); i++){
        cout &amp;lt;&amp;lt; possible[i] &amp;lt;&amp;lt; ' ';
    }
    cout &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 07/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

struct water{
    int a, b, c;
};

int A, B, C;
bool visit[201][201];
bool result[201];

void BFS(){
    queue&amp;lt;water&amp;gt; Queue;
    Queue.push({0, 0, C});

    while(!Queue.empty()){
        water current = Queue.front();
        Queue.pop();

        if(visit[current.a][current.b]){
            continue;
        }

        visit[current.a][current.b] = true;

        if(current.a == 0){
            result[current.c] = true;
        }

        if(current.a + current.b &amp;gt; B) { // A -&amp;gt; B / A + B가 B보다 크면 B는 가득, A는 A + B - B의 용량만큼 찬다.
            Queue.push({current.a + current.b - B, B, current.c});
        }
        else{ // A + B가 B보다 작으므로 A의 물을 전부 B로 붓는다.
            Queue.push({0, current.a + current.b, current.c});
        }

        if(current.a + current.b &amp;gt; A){ // B -&amp;gt; A
            Queue.push({A, current.a + current.b - A, current.c});
        }
        else{
            Queue.push({current.a + current.b, 0, current.c});
        }

        if(current.a + current.c &amp;gt; C){ // A -&amp;gt; C
            Queue.push({current.a + current.c - C, current.b, C});
        }
        else{
            Queue.push({0, current.b, current.a + current.c});
        }

        if(current.a + current.c &amp;gt; A){ // C -&amp;gt; A
            Queue.push({A, current.b, current.a + current.c - A});
        }
        else{
            Queue.push({current.a + current.c, current.b, 0});
        }

        if(current.b + current.c &amp;gt; C){ // B -&amp;gt; C
            Queue.push({current.a, current.b + current.c - C, C});
        }
        else{
            Queue.push({current.a, 0, current.b + current.c});
        }

        if(current.b + current.c &amp;gt; B){ // C -&amp;gt; B
            Queue.push({current.a, B, current.b + current.c - B});
        }
        else{
            Queue.push({current.a, current.b + current.c, 0});
        }
    }
}

int main(){
    cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B &amp;gt;&amp;gt; C;

    BFS();

    for(int i=0; i&amp;lt;201; i++){
        if(result[i]){
            cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; ' ';
        }
    }
    cout &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="BFS" /><summary type="html">백준 2251번 Link: 2251번: 물통</summary></entry><entry><title type="html">1062</title><link href="keithlee94.github.io/algorithm/1062/" rel="alternate" type="text/html" title="1062" /><published>2019-01-30T00:00:00+09:00</published><updated>2019-01-30T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1062</id><content type="html" xml:base="keithlee94.github.io/algorithm/1062/">&lt;h1 id=&quot;백준-1062번&quot;&gt;백준 1062번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1062&quot;&gt;1062번: 가르침&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;29일부터 풀기 시작해서 30일에서 31일 넘어가는 새벽에야 겨우 해결했던 문제.&lt;/p&gt;

&lt;p&gt;내 답이 맞는것 같아 계속 고민하다 결국 답을 보고 해결했다.&lt;/p&gt;

&lt;p&gt;답을 찾아보고서야 예전에 DFS를 통해 조합을 구하는 방법을 써서 문제를 풀때 어떤식으로 코드를 짰는지 떠오르더라.&lt;/p&gt;

&lt;p&gt;정신승리를 좀 하자면, 시간초과가 났긴 했지만 어쨌든 답을 구할 수 있는 방법들을 최대한 생각해보고 여러 방법들을 비교해봤다는 점.&lt;/p&gt;

&lt;p&gt;이러는 과정에서 시간초과를 수십번 본 것 같은데, 어떤 부분에서 시간초과가 일어나는지는 짚어냈다.&lt;/p&gt;

&lt;p&gt;문제는 그 부분을 고치니 답이 틀렸다는 것.&lt;/p&gt;

&lt;p&gt;이렇게 여러번 고민해봐도 도저히 안풀려서 답을 찾아보게 되었다.&lt;/p&gt;

&lt;p&gt;답을 보고 나니 뭔가 매우 허무한 느낌이 들었다. 그동안 뭘 짜고 있었나 싶기도 하고.&lt;/p&gt;

&lt;p&gt;답을 찾아내기 위해 삽질했던 시간들이 있었기 때문에 정답을 보고서도 이 부분은 나도 구현했는데 왜 틀렸을까 하는 생각이 들게 하였고 이 부분은 이래서 이렇게 짰구나 하는 생각도 들 수 있었던것 같다.&lt;/p&gt;

&lt;p&gt;요며칠 단순한 BFS문제를 풀면서 이런식으로 DFS를 통해 조합을 구하고 백트래킹해야 풀리는 문제 푸는 연습을 해야겠다고 생각했는데, 이 문제가 전형적인 그런 문제였다.&lt;/p&gt;

&lt;p&gt;시간 지나고 푸는 방법 까먹을때쯤 한번 더 풀어봐야겠다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;삽질했던-코드&quot;&gt;삽질했던 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int result = 0;
int N, K;
int candidates[26] = {0, };
int words[50][26] = {0, };

int max(int a, int b){
    return a &amp;gt; b ? a : b;
}

void searchTeach(int count, int index, int toTeach[26], int limit){
    int tempResult = 0;

    int temp[26];
    for(int i=0; i&amp;lt;26; i++){
        temp[i] = toTeach[i];
    }

    if(candidates[index] == 1){
        temp[index] = 1;
    }

    if(count == limit){
        for(int i=0; i&amp;lt;N; i++){
            bool invalid = false;

            for(int j=0; j&amp;lt;26; j++){
                if(toTeach[j] - words[i][j] &amp;lt; 0){
                    invalid = true;
                    break;
                }
            }

            if(!invalid){
                tempResult++;
            }
        }

        result = max(result, tempResult);
        return;
    }

    int next = 0;
    for(int i=index+1; i&amp;lt;26; i++){
        if(candidates[i] == 1){
            next = i;
            break;
        }
    }

    searchTeach(count+1, next, temp, limit);
    searchTeach(count+1, next, toTeach, limit);
}

void toTeach(){
    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;26; j++){
            if(candidates[j] != 1){
                candidates[j] = words[i][j];
            }
        }
    }
}

int main(){
    string word;

    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K;

    for(int i=0; i&amp;lt;N; i++){
        cin &amp;gt;&amp;gt; word;

        if(K &amp;gt;= 5){
            string temp = word.substr(4, word.length()-8);
            for(int j=0; j&amp;lt;temp.length(); j++){
                int current = temp[j] - 'a';
                if(current != 0 &amp;amp;&amp;amp; current != 2 &amp;amp;&amp;amp; current != 8 &amp;amp;&amp;amp; current != 13 &amp;amp;&amp;amp; current != 19){
                    words[i][current] = 1;
                }
            }
        }
    }

    if(K &amp;lt; 5){
        result = 0;
    }
    else{
        toTeach();

        int input[26] = {0, };

        for(int i=0; i&amp;lt;26; i++){
            if(candidates[i] == 1){
                searchTeach(0, i, input, K-5);
                candidates[i]--;
            }
        }

        if(K == 5){
            searchTeach(0, 0, input, K-5);
        }
    }

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 30/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int result = 0;
int N, K;

string words[50];
bool visit[26];

int max(int a, int b){
    return a &amp;gt; b ? a : b;
}

void searchTeach(int index, int count){
    if(count == K-5){
        int tempResult = 0;

        for(int i=0; i&amp;lt;N; i++){
            bool invalid = false;

            for(int j=0; j&amp;lt;words[i].length(); j++){
                if(!visit[words[i][j] - 'a']){
                    invalid = true;
                    break;
                }

            }

            if(!invalid){
                tempResult++;
            }
        }

        result = max(result, tempResult);
        return;
    }

    for(int i=index; i&amp;lt;26; i++){
        if(!visit[i]){
            visit[i] = true;
            searchTeach(i, count+1);
            visit[i] = false;
        }
    }

}

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K;

    for(int i=0; i&amp;lt;N; i++){
        cin &amp;gt;&amp;gt; words[i];

        words[i] = words[i].substr(4, words[i].length()-8);
    }

    if(K &amp;lt; 5){
        result = 0;
    }
    else if(K == 26){
        result = N;
    }
    else{
        visit['a' - 'a'] = true;
        visit['n' - 'a'] = true;
        visit['t' - 'a'] = true;
        visit['c' - 'a'] = true;
        visit['i' - 'a'] = true;

        searchTeach(0, 0);
    }

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Brute Force" /><category term="Backtracking" /><summary type="html">백준 1062번 Link: 1062번: 가르침</summary></entry><entry><title type="html">7th week summary</title><link href="keithlee94.github.io/java/7th-Week-Summary/" rel="alternate" type="text/html" title="7th week summary" /><published>2019-01-28T00:00:00+09:00</published><updated>2019-01-28T00:00:00+09:00</updated><id>keithlee94.github.io/java/7th%20Week%20Summary</id><content type="html" xml:base="keithlee94.github.io/java/7th-Week-Summary/">&lt;h1 id=&quot;알고리즘-스터디-내용-정리&quot;&gt;알고리즘 스터디 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;백트래킹-bfs의-차이&quot;&gt;백트래킹, BFS의 차이&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;BFS: 모든 경로를 추적해본다.&lt;/li&gt;
  &lt;li&gt;백트래킹: 추적하는 경로가 해결책이 될 수 없으면 더이상 그 경로를 따라가지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;priority-queue&quot;&gt;Priority Queue&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;큐에 삽입할때 우선순위를 적용하여 재배치한다.&lt;/li&gt;
  &lt;li&gt;우선순위가 높은 것이 먼저 pop됨.&lt;/li&gt;
  &lt;li&gt;배열, 리스트, Heap으로 구현 가능 - Heap이 가장 적합.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;연결-리스트-배열&quot;&gt;연결 리스트, 배열&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;배열
    &lt;ul&gt;
      &lt;li&gt;순차 데이터에 적합&lt;/li&gt;
      &lt;li&gt;데이터 접근 속도가 빠르다.&lt;/li&gt;
      &lt;li&gt;단점: 배열 중간에 삽입/삭제시 shift 필요 - 시간 오래걸림, 크기 변경 불가.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;연결리스트
    &lt;ul&gt;
      &lt;li&gt;비순차적 데이터에 적합&lt;/li&gt;
      &lt;li&gt;삽입, 삭제가 쉽다.&lt;/li&gt;
      &lt;li&gt;단점: 필요없는 데이터(front, end 등)가 있음, 데이터 접근속도가 느림.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;연결-리스트-종류&quot;&gt;연결 리스트 종류&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;List: 순서 있음, 중복 허용.
    &lt;ul&gt;
      &lt;li&gt;ArrayList
        &lt;ul&gt;
          &lt;li&gt;배열과 유사&lt;/li&gt;
          &lt;li&gt;크기 변경 가능&lt;/li&gt;
          &lt;li&gt;배열 다음으로 접근속도가 빠르다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;LinkedList
        &lt;ul&gt;
          &lt;li&gt;노드 사용&lt;/li&gt;
          &lt;li&gt;비순차적 삽입, 삭제 가능&lt;/li&gt;
          &lt;li&gt;접근속도가 느리다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Set: 순서 없음, 중복 불가.
    &lt;ul&gt;
      &lt;li&gt;중복 삽입시 새로운 데이터를 저장하지 않음.&lt;/li&gt;
      &lt;li&gt;HashSet
        &lt;ul&gt;
          &lt;li&gt;hashing기법을 통해 중복 확인(O(1))&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TreeSet
        &lt;ul&gt;
          &lt;li&gt;Binary Search Tree를 사용하여 중복 확인(O(logN))&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Map: 순서 없음, 중복 불가. (키, 값) 쌍으로 데이터 저장.
    &lt;ul&gt;
      &lt;li&gt;중복 삽입시 기존의 데이터를 새 데이터로 덮어씀.&lt;/li&gt;
      &lt;li&gt;키 = 중복 불가, 값 = 중복 가능.&lt;/li&gt;
      &lt;li&gt;HashMap
        &lt;ul&gt;
          &lt;li&gt;hashing기법을 통해 중복 확인(O(1))&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TreeMap
        &lt;ul&gt;
          &lt;li&gt;Binary Search Tree를 사용하여 중복 확인(O(logN))&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;TreeMap, TreeSet의 장점: 미리 정렬이 되어 있는 형태 =&amp;gt; 정렬이 많이 필요하거나 자주 사용될 경우 유용하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java-스터디-내용-정리&quot;&gt;Java 스터디 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;예외처리-방법&quot;&gt;예외처리 방법&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;try ~ catch: 예외 발생 위치에서 바로 처리
    &lt;ul&gt;
      &lt;li&gt;try ~ catch ~ finally: 예외 발생 여부와 관계없이 finally는 항상 실행된다.(optional)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;throws: 발생한 예외를 호출자로 위임하여 처리
    &lt;ul&gt;
      &lt;li&gt;메소드 선언시 사용.&lt;/li&gt;
      &lt;li&gt;throw: 실제 Exception 발생시 사용.&lt;/li&gt;
      &lt;li&gt;throws가 붙은 메소드는 반드시 예외처리 내용을 포함해야 한다.(try ~ catch나 if ~ else 등으로 구현)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;exception&quot;&gt;Exception&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;상속관계 존재: 여러 Exception을 catch하고자 할 경우 부모타입 하나만 명시하여 여러 Exception들을 한번에 잡을 수 있다.&lt;/li&gt;
  &lt;li&gt;세분화 방법: 범위가 좁은 Exception -&amp;gt; 넓은 Exception 순으로 코드 작성.&lt;/li&gt;
  &lt;li&gt;하나의 클래스이다 =&amp;gt; 사용자가 별도로 정의할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;정의 방법: 클래스 선언시 extends Exception을 붙인다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상속관계에서 부모와 자식이 다른 종류의 Exception throw 가능
    &lt;ul&gt;
      &lt;li&gt;자식이 throw하는 Exception은 부모가 throw하는 Exception보다 범위가 좁거나 같아야 한다.(더 넓은 범위로 정의 불가)&lt;/li&gt;
      &lt;li&gt;부모는 Exception을 throw하고 자식은 throw하지 않는 방식도 구현 가능.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;stream&quot;&gt;Stream&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;InputStream: 데이터를 받아들인다.&lt;/li&gt;
  &lt;li&gt;OutputStream: 데이터를 보낸다.&lt;/li&gt;
  &lt;li&gt;기본적으로 바이트 단위로 데이터 전송.&lt;/li&gt;
  &lt;li&gt;문자 처리: 바이트로 처리하기 어려우므로 InputStreamReader, OutputStreamWriter를 활용하여 처리한다.&lt;/li&gt;
  &lt;li&gt;사용 종료후 반드시 close해줘야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;데이터-전송단위별-stream-종류&quot;&gt;데이터 전송단위별 Stream 종류&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;byteStream: 1바이트에 코드값을 담아 전송하는 스트림. (InputStream/OutputStream)&lt;/li&gt;
  &lt;li&gt;characterStream: 2바이트에 코드값을 담아 전송하는 스트림. (InputStreamReader/OutputStreamWriter)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;데이터-연결여부에-따른-stream-종류&quot;&gt;데이터 연결여부에 따른 Stream 종류&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;NodeStream: 데이터와 직접 연결되어 있는 스트림.&lt;/li&gt;
  &lt;li&gt;ProcessStream(FilterStream): NodeStream에서 데이터를 받아 가공하는 스트림.(일종의 필터 역할)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;scanner-bufferedreader-속도-차이-원인&quot;&gt;Scanner, BufferedReader 속도 차이 원인&lt;/h1&gt;
&lt;p&gt;Scanner는 1바이트씩 읽어오는 InputStream이고 BufferedReader는 2바이트씩 읽어오는 InputStreamReader이기 때문에 BufferedReader가 속도가 더 빠르다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;serialization&quot;&gt;Serialization&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;객체를 스트림을 통해 이동시키려면 직렬화(Serialization) 조건을 만족시켜야 한다.&lt;/li&gt;
  &lt;li&gt;어떻게: 전송할 객체의 클래스가 Serializable 클래스를 implements 하면 된다. (객체를 배열로 만들어 전송하는 것)&lt;/li&gt;
  &lt;li&gt;역 직렬화: 직렬화된 배열을 객체로 복원하는 작업.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;thread&quot;&gt;Thread&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Process의 작은 실행 단위.&lt;/li&gt;
  &lt;li&gt;단독으로 존재할 수 없다: Process 내에 포함된다.&lt;/li&gt;
  &lt;li&gt;Thread 없이는 프로세스가 동작하지 않는다: 프로세스의 일꾼 역할.&lt;/li&gt;
  &lt;li&gt;Multi thread
    &lt;ul&gt;
      &lt;li&gt;프로그램 하나를 실행시켰을때 여러명의 일꾼이 일하는 것과 같다.&lt;/li&gt;
      &lt;li&gt;동시에 여러 작업을 나눠서 실행 가능.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;CPU의 활용률을 높일 수 있다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;응답성 향상&lt;/strong&gt;: 작업 시간, 요구 성능에 따라 작업을 분리하여 병렬로 수행 가능.&lt;/li&gt;
      &lt;li&gt;프로세스 자원 공유: 효율성 향상(메모리 절약)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;Context Switching 비용 발생&lt;/li&gt;
      &lt;li&gt;Thread 제어의 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;thread-life-cycle&quot;&gt;Thread Life Cycle&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;New
    &lt;ul&gt;
      &lt;li&gt;Thread 객체가 생성된 상태.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Runnable
    &lt;ul&gt;
      &lt;li&gt;New 상태의 Thread에 대해 start() 메소드가 호출되면 Runnable 상태로 전환된다.&lt;/li&gt;
      &lt;li&gt;start() 메소드 호출: 필수로 실행되어야 하는 과정.&lt;/li&gt;
      &lt;li&gt;Race Condition: Runnable 상태의 Thread들 중 어떤 것이 먼저 실행될지 알 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Running
    &lt;ul&gt;
      &lt;li&gt;JVM이 Thread의 run() 메소드를 호출하면 Thread 동작.&lt;/li&gt;
      &lt;li&gt;Thread의 sleep(), wait(), join() 메소드 호출시 Thread가 Waiting Pool로 이동하여 대기 상태로 전환된다.(Thread 동작 일시 정지)
        &lt;ul&gt;
          &lt;li&gt;Runnable 상태로 전환되는 조건
            &lt;ol&gt;
              &lt;li&gt;대기상태의 Thread의 sleep(), join() 시간이 종료되었을 경우&lt;/li&gt;
              &lt;li&gt;wait()에 대한 notify() 메소드가 호출된 경우&lt;/li&gt;
              &lt;li&gt;interrupt() 메소드가 호출된 경우&lt;/li&gt;
              &lt;li&gt;I/O가 종료된 경우&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;동작중인 Thread에서 yield() 메소드 호출시 동작을 멈추고 Runnable 상태로 전환되어 다시 race condition에 들어간다.&lt;/li&gt;
  &lt;li&gt;Terminate
    &lt;ul&gt;
      &lt;li&gt;Thread의 run() 메소드가 종료되면 Terminate 상태로 전환됨.&lt;/li&gt;
      &lt;li&gt;한번 소멸한 Thread는 더이상 동작하지 않는다.
        &lt;ul&gt;
          &lt;li&gt;다시 동작시키려면 Thread를 다시 생성하여 다시 동작시켜야 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;thread-구현&quot;&gt;Thread 구현&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Runnable interface를 implements 하거나 extends 하면 된다. (이미 상속중인 다른 클래스가 있으면 implements하면 됨.)
    &lt;ul&gt;
      &lt;li&gt;Runnable을 implements한 경우
        &lt;ul&gt;
          &lt;li&gt;객체는 Thread가 아니다: Runnable 객체이다.&lt;/li&gt;
          &lt;li&gt;Thread가 수행해야 하는 작업을 run() 메소드에 정의해야 한다.&lt;/li&gt;
          &lt;li&gt;여러 Thread가 하나의 Runnable 객체를 실행할수도 있고, 각자 다른 Runnable 객체를 실행할수도 있다. (하나의 Runnable 객체일 경우 자원 공유됨)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Thread.run(): callback 메소드(사용자에 의해 직접 호출되지 않지만 특정 조건을 만족하면 자동으로 실행되는 메소드)
    &lt;ul&gt;
      &lt;li&gt;Thread의 run() 메소드를 호출하여 실행하면: main Thread가 실행하는 것.&lt;/li&gt;
      &lt;li&gt;Thread의 start() 메소드를 호출하여 자동 실행되면: run()이 정의된 클래스의 Thread가 실행하는 것.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;thread-구조&quot;&gt;Thread 구조&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/23356503/51823142-dec73180-2321-11e9-88f8-eb20c5b72bd0.png&quot; alt=&quot;Thread 구조&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Runnable 객체를 직접 implements 하거나 Runnable 객체를 implements하는 Thread 클래스를 상속받는 두가지 형태 모두 가능.&lt;/li&gt;
  &lt;li&gt;Thread.run(): 아무 내용 없는 메소드(추상메소드나 다름없다.)
    &lt;ul&gt;
      &lt;li&gt;Thread를 상속한 클래스에서 반드시 오버라이딩해야 한다.&lt;/li&gt;
      &lt;li&gt;Thread 클래스를 추상클래스로 만들 수 없어 이런 형태로 만들어짐.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Thread 객체를 생성하려면 target 객체(Runnable 객체)를 넣어줄 것.
    &lt;ul&gt;
      &lt;li&gt;따로 안넣어주면 Thread.run()이 실행되어 아무 결과도 안나옴.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;thread-동기화-문제&quot;&gt;Thread 동기화 문제&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;데이터가 여러 Thread들에 의해 공유되어 발생.&lt;/li&gt;
  &lt;li&gt;예
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  int count = 0;
  Thread t1, t2, t3;

  public void run(){ // t1, t2, t3가 모두 같은 메소드 사용.
      go();
  }

  /*
  * 작업 과정
  * 1. 현재 count값 읽기
  * 2. 연산
  * 3. 새로운 값 저장.
  */
  public void go(){
      count++;
      System.out.println(count);
  }

  =&amp;gt; 각 thread의 접근 순서에 따라 다른 결과가 나온다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;해결: 공유하는 메소드에 synchronized 키워드를 붙인다.
    &lt;ul&gt;
      &lt;li&gt;public synchronized void go() {…}&lt;/li&gt;
      &lt;li&gt;한번에 한 Thread만 자원에 접근할 수 있으므로 순차실행 형태가 된다. (일종의 lock을 거는 것) - 꼭 필요한 부분에만 사용할것.&lt;/li&gt;
      &lt;li&gt;method뿐 아닌 객체에도 사용 가능. (run() 메소드에는 사용할 수 없다: run()은 오버라이딩된 메소드이므로)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;thread의-method&quot;&gt;Thread의 method&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;join(): 다른 Thread가 종료될때까지 join()을 호출하는 Thread가 대기한다.&lt;/li&gt;
  &lt;li&gt;notify(): Thread와 Thread간에 신호를 줄 때 사용 (깨울 메소드가 없으면 아무 동작도 안함)&lt;/li&gt;
  &lt;li&gt;wait(): 다른 Thread가 notify()를 호출하기 전까지 대기.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;wait(), notify()는 synchronized 영역에서만 사용 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java-소켓-통신&quot;&gt;Java 소켓 통신&lt;/h1&gt;
&lt;h2 id=&quot;server&quot;&gt;Server&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;ServerSocket(port번호) 생성&lt;/li&gt;
  &lt;li&gt;ServerSocket.accept() 호출
    &lt;ul&gt;
      &lt;li&gt;클라이언트가 접속할대까지 기다리고, 클라이언트가 접속하면 클라이언트 소켓을 받아온다.&lt;/li&gt;
      &lt;li&gt;block되는 특징: 요구 조건(클라이언트의 접속)을 만족하지 않으면 이후 내용을 실행하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;도착한 클라이언트 소켓으로부터 입출력 스트림을 얻어낸다.&lt;/li&gt;
  &lt;li&gt;스트림으로 메시지 전송&lt;/li&gt;
  &lt;li&gt;ServerSocket 닫기(close() 호출)&lt;/li&gt;
  &lt;li&gt;스트림 닫기&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;client&quot;&gt;Client&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Socket(서버 ip주소, 서버 port번호) 생성: 소켓 객체가 만들어지는 순간 서버에 접속된다.&lt;/li&gt;
  &lt;li&gt;생성한 Socket으로부터 입출력 스트림을 얻어낸다.&lt;/li&gt;
  &lt;li&gt;스트림으로 메시지 전송&lt;/li&gt;
  &lt;li&gt;Socket 닫기(close() 호출)&lt;/li&gt;
  &lt;li&gt;스트림 닫기&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Java" /><summary type="html">알고리즘 스터디 내용 정리</summary></entry><entry><title type="html">2644</title><link href="keithlee94.github.io/algorithm/2644/" rel="alternate" type="text/html" title="2644" /><published>2019-01-28T00:00:00+09:00</published><updated>2019-01-28T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2644</id><content type="html" xml:base="keithlee94.github.io/algorithm/2644/">&lt;h1 id=&quot;백준-2644번&quot;&gt;백준 2644번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2644&quot;&gt;2644번: 촌수계산&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;역시나 BFS문제.&lt;/p&gt;

&lt;p&gt;저번에 풀었던 토마토 문제처럼, 이 문제도 트리 내에서 출발지와 목적지를 설정하여 목적지까지 도달하는데 거치는 트리 레벨을 세면 되는 문제였다.&lt;/p&gt;

&lt;p&gt;주의해야할 점은 방향이 없는 그래프 문제였다는 점.&lt;/p&gt;

&lt;p&gt;이외에는 다소 평이했던 문제였다…&lt;/p&gt;

&lt;p&gt;라고 하기에는 막판에 뻘짓을 좀 했다.&lt;/p&gt;

&lt;p&gt;도달할 수 없는 경우 -1로 처리하는 부분에서 살짝 헤맸던 것 빼고는 할만한 문제였다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 28/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int map[101][101] = {0, };
bool visit[101][101] = {false, };

int n;

int BFS(int start, int end){
    int result = 0;

    queue&amp;lt;int&amp;gt; Queue;
    Queue.push(start);

    while(!Queue.empty()){
        vector&amp;lt;int&amp;gt; available;

        while(!Queue.empty()) {
            available.push_back(Queue.front());
            Queue.pop();
        }

        for(int i=0; i&amp;lt;available.size(); i++) {
            int current = available[i];

            for (int j = 1; j &amp;lt;= n; j++) {
                if (map[current][j] == 1 &amp;amp;&amp;amp; !visit[current][j]) {
                    visit[current][j] = true;
                    visit[j][current] = true;
                    Queue.push(j);
                }
            }
        }

        result++;

        for(int i=1; i&amp;lt;=n; i++){
            if(visit[end][i] &amp;amp;&amp;amp; visit[i][end]){
                return result;
            }
        }

    }
}

int main(){
    cin &amp;gt;&amp;gt; n;

    int start, end;
    cin &amp;gt;&amp;gt; start &amp;gt;&amp;gt; end;

    int m;
    cin &amp;gt;&amp;gt; m;

    for(int i=0; i&amp;lt;m; i++){
        int x, y;
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;

        map[x][y] = 1;
        map[y][x] = 1;
    }

    int result = BFS(start, end);

    bool find = false;
    for(int i=1; i&amp;lt;=n; i++){
        if(visit[end][i] &amp;amp;&amp;amp; visit[i][end]){
            find = true;
        }
    }

    if(!find){
        result = -1;
    }

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="BFS" /><summary type="html">백준 2644번 Link: 2644번: 촌수계산</summary></entry><entry><title type="html">10026</title><link href="keithlee94.github.io/algorithm/10026/" rel="alternate" type="text/html" title="10026" /><published>2019-01-28T00:00:00+09:00</published><updated>2019-01-28T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/10026</id><content type="html" xml:base="keithlee94.github.io/algorithm/10026/">&lt;h1 id=&quot;백준-10026번&quot;&gt;백준 10026번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/10026&quot;&gt;10026번: 적록색약&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;이번에도 BFS 문제.&lt;/p&gt;

&lt;p&gt;각각의 색깔명에 대해 전체 map이 몇개의 영역으로 나눠지는지 구하는 문제였다.&lt;/p&gt;

&lt;p&gt;한가지 특이했던 점은 적록색맹이라는 상황을 줌으로써 R값과 G값을 같은 값으로 보고 풀어야 하는 부분이 존재했다는 점.&lt;/p&gt;

&lt;p&gt;적록색맹이 아닌 사람과 적록색맹인 사람의 경우를 따로 나눠 구해야 한다.&lt;/p&gt;

&lt;p&gt;처음에는 map을 아예 새로 만들까 했었는데, 조건문에서 R과 G에 대한 조건을 or로 묶으니 굳이 안그래도 해결됐다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 28/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;string.h&amp;gt;

using namespace std;

int N;
char map[101][101];
bool visit[101][101];

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

int normalResult = 0;
int redGreenResult = 0;

void BFS_normal(int startX, int startY){
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;

    Queue.push(make_pair(startX, startY));
    visit[startX][startY] = true;

    while(!Queue.empty()){
        int currentX = Queue.front().first;
        int currentY = Queue.front().second;
        Queue.pop();

        for(int i=0; i&amp;lt;4; i++){
            int nextX = currentX + dx[i];
            int nextY = currentY + dy[i];

            if(nextX &amp;gt;= 1 &amp;amp;&amp;amp; nextX &amp;lt;= N &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt;= N){
                if(map[startX][startY] == 'R'){
                    if(map[nextX][nextY] == 'R' &amp;amp;&amp;amp; !visit[nextX][nextY]){
                        visit[nextX][nextY] = true;
                        Queue.push(make_pair(nextX, nextY));
                    }
                }
                else if(map[startX][startY] == 'G'){
                    if(map[nextX][nextY] == 'G' &amp;amp;&amp;amp; !visit[nextX][nextY]){
                        visit[nextX][nextY] = true;
                        Queue.push(make_pair(nextX, nextY));
                    }
                }
                else if(map[startX][startY] == 'B'){
                    if(map[nextX][nextY] == 'B' &amp;amp;&amp;amp; !visit[nextX][nextY]){
                        visit[nextX][nextY] = true;
                        Queue.push(make_pair(nextX, nextY));
                    }
                }
            }
        }
    }

    normalResult++;
}

void BFS_redGreen(int startX, int startY){
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;

    Queue.push(make_pair(startX, startY));
    visit[startX][startY] = true;

    while(!Queue.empty()){
        int currentX = Queue.front().first;
        int currentY = Queue.front().second;
        Queue.pop();

        for(int i=0; i&amp;lt;4; i++){
            int nextX = currentX + dx[i];
            int nextY = currentY + dy[i];

            if(nextX &amp;gt;= 1 &amp;amp;&amp;amp; nextX &amp;lt;= N &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt;= N){
                if(map[startX][startY] == 'R' || map[startX][startY] == 'G'){
                    if((map[nextX][nextY] == 'R' || map[nextX][nextY] == 'G') &amp;amp;&amp;amp; !visit[nextX][nextY]){
                        visit[nextX][nextY] = true;
                        Queue.push(make_pair(nextX, nextY));
                    }
                }
                else if(map[startX][startY] == 'B'){
                    if(map[nextX][nextY] == 'B' &amp;amp;&amp;amp; !visit[nextX][nextY]){
                        visit[nextX][nextY] = true;
                        Queue.push(make_pair(nextX, nextY));
                    }
                }
            }
        }
    }

    redGreenResult++;
}

int main(){
    cin &amp;gt;&amp;gt; N;

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=N; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=N; j++){
            if(!visit[i][j]){
                BFS_normal(i, j);
            }
        }
    }

    bzero(visit, sizeof(visit));

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=N; j++){
            if(!visit[i][j]){
                BFS_redGreen(i, j);
            }
        }
    }

    cout &amp;lt;&amp;lt; normalResult &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; redGreenResult &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="BFS" /><summary type="html">백준 10026번 Link: 10026번: 적록색약</summary></entry><entry><title type="html">7569</title><link href="keithlee94.github.io/algorithm/7569/" rel="alternate" type="text/html" title="7569" /><published>2019-01-24T00:00:00+09:00</published><updated>2019-01-24T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/7569</id><content type="html" xml:base="keithlee94.github.io/algorithm/7569/">&lt;h1 id=&quot;백준-7569번&quot;&gt;백준 7569번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/7576&quot;&gt;7569번: 토마토&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;이번에도 BFS문제다.&lt;/p&gt;

&lt;p&gt;저번에 컨디션 아주 별로였던날 한번 보고 어떻게풀지 감이 안와서 포기하고 삼성 기출문제 풀었었는데, 오늘은 마음잡고 제대로 들여다봤다.&lt;/p&gt;

&lt;p&gt;백준에는 똑같은 이름의 조금 간단한 문제가 하나 있는데, 이 문제는 그 문제에서 3차원 공간에 대해 생각해보는 요소가 추가된 문제다.&lt;/p&gt;

&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/7576&quot;&gt;7576번: 토마토&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;풀이 방법은 이 문제를 푸는 방법과 크게 다를게 없다.&lt;/p&gt;

&lt;p&gt;그저께 풀었던 문제도 그랬는데, 이 문제나 저 문제도 BFS를 통해 트리를 탐색한다고 생각해볼때 몇개의 레벨을 탐색했는지 세면 되는 문제다.&lt;/p&gt;

&lt;p&gt;우선 input값이 1인 것들을 visit했다고 표시한 다음 큐에 넣는다.&lt;/p&gt;

&lt;p&gt;그리고 BFS를 진행하는데, 우선 트리의 레벨을 세기 위해 큐의 모든 요소들을 벡터에 따로 빼놓고 벡터의 요소들에 대한 BFS를 진행한다.&lt;/p&gt;

&lt;p&gt;주의해야 할 점은 3차원적 요소도 고려해야 하는 만큼, 기존 4방향에 더해 위 상자, 아래 상자도 고려하며 구현해야 한다.&lt;/p&gt;

&lt;p&gt;이외에는 기존 BFS와 다를 게 없다.&lt;/p&gt;

&lt;p&gt;while문을 한번 끝낼때마다 결과값을 1씩 더해주는 식으로 완전탐색을 진행하면 답이 나온다.&lt;/p&gt;

&lt;p&gt;나같은 경우에는 결과값의 초기값을 0으로 설정해뒀기 때문에 최종 결과 출력 전에 구한 결과값에서 1을 뺀 값이 맞는 값이다.&lt;/p&gt;

&lt;p&gt;BFS가 끝난 후, map에 0이 남아있는지 세보고 결과값을 설정해준 다음 출력해주니 바로 풀렸다.&lt;/p&gt;

&lt;p&gt;3차원 배열을 써야 풀릴것 같긴 했는데 시간초과나 메모리초과로 실패하지 않을까 고민하면서 구현했다.&lt;/p&gt;

&lt;p&gt;실제로 돌려보니 메모리는 꽤 많이 사용하면서도 시간초과 없이 풀리는걸 보니 아주 무식하게 3차원 배열을 전부 탐색하며 푸는 문제가 맞았던 것 같다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 24/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int map[100][100][100] = {0, };
bool visit[100][100][100] = {false, };

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
int dz[2] = {-1, 1};

// 가로, 세로, 높이
int M, N, H;
int result = 0;

queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; Queue;

void BFS(){
    while(!Queue.empty()){
        vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; starts;

        while(!Queue.empty()){
            starts.push_back(make_pair(Queue.front().first, make_pair(Queue.front().second.first, Queue.front().second.second)));
            Queue.pop();
        }

        for(int v=0; v&amp;lt;starts.size(); v++){
            int startZ = starts[v].first;
            int startX = starts[v].second.first;
            int startY = starts[v].second.second;

            for(int i=0; i&amp;lt;4; i++){
                int nextX = startX + dx[i];
                int nextY = startY + dy[i];

                if(nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt; N &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt; M){
                    if(!visit[startZ][nextX][nextY] &amp;amp;&amp;amp; map[startZ][nextX][nextY] == 0){
                        visit[startZ][nextX][nextY] = true;
                        map[startZ][nextX][nextY] = 1;
                        Queue.push(make_pair(startZ, make_pair(nextX, nextY)));
                    }
                }
            }

            for(int i=0; i&amp;lt;2; i++){
                int nextZ = startZ + dz[i];

                if(nextZ &amp;gt;= 0 &amp;amp;&amp;amp; nextZ &amp;lt; H){
                    if(!visit[nextZ][startX][startY] &amp;amp;&amp;amp; map[nextZ][startX][startY] == 0){
                        visit[nextZ][startX][startY] = true;
                        map[nextZ][startX][startY] = 1;
                        Queue.push(make_pair(nextZ, make_pair(startX, startY)));
                    }
                }
            }
        }

        result++;

    }

}

int main(){
    cin &amp;gt;&amp;gt; M &amp;gt;&amp;gt; N &amp;gt;&amp;gt; H;

    // (층, (가로, 세로)) 쌍으로 저장한다.
    vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; coordinates;

    for(int i=0; i&amp;lt;H; i++){
        for(int j=0; j&amp;lt;N; j++){
            for(int k=0; k&amp;lt;M; k++){
                cin &amp;gt;&amp;gt; map[i][j][k];
                if(map[i][j][k] == 1){
                    visit[i][j][k] = true;
                    Queue.push(make_pair(i, make_pair(j, k)));
                }
            }
        }
    }

    BFS();

    for(int i=0; i&amp;lt;H; i++){
        for(int j=0; j&amp;lt;N; j++){
            for(int k=0; k&amp;lt;M; k++){
                if(map[i][j][k] == 0){
                    result = -1;
                    break;
                }
            }
        }
    }

    if(result != -1){
        cout &amp;lt;&amp;lt; result-1 &amp;lt;&amp;lt; '\n';
    }
    else{
        cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="BFS" /><summary type="html">백준 7569번 Link: 7569번: 토마토</summary></entry></feed>