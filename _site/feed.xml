<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="keithlee94.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="keithlee94.github.io/" rel="alternate" type="text/html" /><updated>2019-01-28T19:08:25+09:00</updated><id>keithlee94.github.io/feed.xml</id><title type="html">KeithLog</title><subtitle>SSAFY 교육내용, 알고리즘 문제풀이 정리하여 업로드할 블로그</subtitle><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><entry><title type="html">7th week summary</title><link href="keithlee94.github.io/java/7th-Week-Summary/" rel="alternate" type="text/html" title="7th week summary" /><published>2019-01-28T00:00:00+09:00</published><updated>2019-01-28T00:00:00+09:00</updated><id>keithlee94.github.io/java/7th%20Week%20Summary</id><content type="html" xml:base="keithlee94.github.io/java/7th-Week-Summary/">&lt;h1 id=&quot;알고리즘-스터디-내용-정리&quot;&gt;알고리즘 스터디 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;백트래킹-bfs의-차이&quot;&gt;백트래킹, BFS의 차이&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;BFS: 모든 경로를 추적해본다.&lt;/li&gt;
  &lt;li&gt;백트래킹: 추적하는 경로가 해결책이 될 수 없으면 더이상 그 경로를 따라가지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;priority-queue&quot;&gt;Priority Queue&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;큐에 삽입할때 우선순위를 적용하여 재배치한다.&lt;/li&gt;
  &lt;li&gt;우선순위가 높은 것이 먼저 pop됨.&lt;/li&gt;
  &lt;li&gt;배열, 리스트, Heap으로 구현 가능 - Heap이 가장 적합.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;연결-리스트-배열&quot;&gt;연결 리스트, 배열&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;배열
    &lt;ul&gt;
      &lt;li&gt;순차 데이터에 적합&lt;/li&gt;
      &lt;li&gt;데이터 접근 속도가 빠르다.&lt;/li&gt;
      &lt;li&gt;단점: 배열 중간에 삽입/삭제시 shift 필요 - 시간 오래걸림, 크기 변경 불가.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;연결리스트
    &lt;ul&gt;
      &lt;li&gt;비순차적 데이터에 적합&lt;/li&gt;
      &lt;li&gt;삽입, 삭제가 쉽다.&lt;/li&gt;
      &lt;li&gt;단점: 필요없는 데이터(front, end 등)가 있음, 데이터 접근속도가 느림.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;연결-리스트-종류&quot;&gt;연결 리스트 종류&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;List: 순서 있음, 중복 허용.
    &lt;ul&gt;
      &lt;li&gt;ArrayList
        &lt;ul&gt;
          &lt;li&gt;배열과 유사&lt;/li&gt;
          &lt;li&gt;크기 변경 가능&lt;/li&gt;
          &lt;li&gt;배열 다음으로 접근속도가 빠르다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;LinkedList
        &lt;ul&gt;
          &lt;li&gt;노드 사용&lt;/li&gt;
          &lt;li&gt;비순차적 삽입, 삭제 가능&lt;/li&gt;
          &lt;li&gt;접근속도가 느리다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Set: 순서 없음, 중복 불가.
    &lt;ul&gt;
      &lt;li&gt;중복 삽입시 새로운 데이터를 저장하지 않음.&lt;/li&gt;
      &lt;li&gt;HashSet
        &lt;ul&gt;
          &lt;li&gt;hashing기법을 통해 중복 확인(O(1))&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TreeSet
        &lt;ul&gt;
          &lt;li&gt;Binary Search Tree를 사용하여 중복 확인(O(logN))&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Map: 순서 없음, 중복 불가. (키, 값) 쌍으로 데이터 저장.
    &lt;ul&gt;
      &lt;li&gt;중복 삽입시 기존의 데이터를 새 데이터로 덮어씀.&lt;/li&gt;
      &lt;li&gt;키 = 중복 불가, 값 = 중복 가능.&lt;/li&gt;
      &lt;li&gt;HashMap
        &lt;ul&gt;
          &lt;li&gt;hashing기법을 통해 중복 확인(O(1))&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TreeMap
        &lt;ul&gt;
          &lt;li&gt;Binary Search Tree를 사용하여 중복 확인(O(logN))&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;TreeMap, TreeSet의 장점: 미리 정렬이 되어 있는 형태 =&amp;gt; 정렬이 많이 필요하거나 자주 사용될 경우 유용하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java-스터디-내용-정리&quot;&gt;Java 스터디 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;예외처리-방법&quot;&gt;예외처리 방법&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;try ~ catch: 예외 발생 위치에서 바로 처리
    &lt;ul&gt;
      &lt;li&gt;try ~ catch ~ finally: 예외 발생 여부와 관계없이 finally는 항상 실행된다.(optional)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;throws: 발생한 예외를 호출자로 위임하여 처리
    &lt;ul&gt;
      &lt;li&gt;메소드 선언시 사용.&lt;/li&gt;
      &lt;li&gt;throw: 실제 Exception 발생시 사용.&lt;/li&gt;
      &lt;li&gt;throws가 붙은 메소드는 반드시 예외처리 내용을 포함해야 한다.(try ~ catch나 if ~ else 등으로 구현)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;exception&quot;&gt;Exception&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;상속관계 존재: 여러 Exception을 catch하고자 할 경우 부모타입 하나만 명시하여 여러 Exception들을 한번에 잡을 수 있다.&lt;/li&gt;
  &lt;li&gt;세분화 방법: 범위가 좁은 Exception -&amp;gt; 넓은 Exception 순으로 코드 작성.&lt;/li&gt;
  &lt;li&gt;하나의 클래스이다 =&amp;gt; 사용자가 별도로 정의할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;정의 방법: 클래스 선언시 extends Exception을 붙인다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상속관계에서 부모와 자식이 다른 종류의 Exception throw 가능
    &lt;ul&gt;
      &lt;li&gt;자식이 throw하는 Exception은 부모가 throw하는 Exception보다 범위가 좁거나 같아야 한다.(더 넓은 범위로 정의 불가)&lt;/li&gt;
      &lt;li&gt;부모는 Exception을 throw하고 자식은 throw하지 않는 방식도 구현 가능.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;stream&quot;&gt;Stream&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;InputStream: 데이터를 받아들인다.&lt;/li&gt;
  &lt;li&gt;OutputStream: 데이터를 보낸다.&lt;/li&gt;
  &lt;li&gt;기본적으로 바이트 단위로 데이터 전송.&lt;/li&gt;
  &lt;li&gt;문자 처리: 바이트로 처리하기 어려우므로 InputStreamReader, OutputStreamWriter를 활용하여 처리한다.&lt;/li&gt;
  &lt;li&gt;사용 종료후 반드시 close해줘야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;데이터-전송단위별-stream-종류&quot;&gt;데이터 전송단위별 Stream 종류&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;byteStream: 1바이트에 코드값을 담아 전송하는 스트림. (InputStream/OutputStream)&lt;/li&gt;
  &lt;li&gt;characterStream: 2바이트에 코드값을 담아 전송하는 스트림. (InputStreamReader/OutputStreamWriter)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;데이터-연결여부에-따른-stream-종류&quot;&gt;데이터 연결여부에 따른 Stream 종류&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;NodeStream: 데이터와 직접 연결되어 있는 스트림.&lt;/li&gt;
  &lt;li&gt;ProcessStream(FilterStream): NodeStream에서 데이터를 받아 가공하는 스트림.(일종의 필터 역할)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;scanner-bufferedreader-속도-차이-원인&quot;&gt;Scanner, BufferedReader 속도 차이 원인&lt;/h1&gt;
&lt;p&gt;Scanner는 1바이트씩 읽어오는 InputStream이고 BufferedReader는 2바이트씩 읽어오는 InputStreamReader이기 때문에 BufferedReader가 속도가 더 빠르다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;serialization&quot;&gt;Serialization&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;객체를 스트림을 통해 이동시키려면 직렬화(Serialization) 조건을 만족시켜야 한다.&lt;/li&gt;
  &lt;li&gt;어떻게: 전송할 객체의 클래스가 Serializable 클래스를 implements 하면 된다. (객체를 배열로 만들어 전송하는 것)&lt;/li&gt;
  &lt;li&gt;역 직렬화: 직렬화된 배열을 객체로 복원하는 작업.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;thread&quot;&gt;Thread&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Process의 작은 실행 단위.&lt;/li&gt;
  &lt;li&gt;단독으로 존재할 수 없다: Process 내에 포함된다.&lt;/li&gt;
  &lt;li&gt;Thread 없이는 프로세스가 동작하지 않는다: 프로세스의 일꾼 역할.&lt;/li&gt;
  &lt;li&gt;Multi thread
    &lt;ul&gt;
      &lt;li&gt;프로그램 하나를 실행시켰을때 여러명의 일꾼이 일하는 것과 같다.&lt;/li&gt;
      &lt;li&gt;동시에 여러 작업을 나눠서 실행 가능.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;CPU의 활용률을 높일 수 있다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;응답성 향상&lt;/strong&gt;: 작업 시간, 요구 성능에 따라 작업을 분리하여 병렬로 수행 가능.&lt;/li&gt;
      &lt;li&gt;프로세스 자원 공유: 효율성 향상(메모리 절약)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;Context Switching 비용 발생&lt;/li&gt;
      &lt;li&gt;Thread 제어의 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;thread-life-cycle&quot;&gt;Thread Life Cycle&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;New
    &lt;ul&gt;
      &lt;li&gt;Thread 객체가 생성된 상태.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Runnable
    &lt;ul&gt;
      &lt;li&gt;New 상태의 Thread에 대해 start() 메소드가 호출되면 Runnable 상태로 전환된다.&lt;/li&gt;
      &lt;li&gt;start() 메소드 호출: 필수로 실행되어야 하는 과정.&lt;/li&gt;
      &lt;li&gt;Race Condition: Runnable 상태의 Thread들 중 어떤 것이 먼저 실행될지 알 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Running
    &lt;ul&gt;
      &lt;li&gt;JVM이 Thread의 run() 메소드를 호출하면 Thread 동작.&lt;/li&gt;
      &lt;li&gt;Thread의 sleep(), wait(), join() 메소드 호출시 Thread가 Waiting Pool로 이동하여 대기 상태로 전환된다.(Thread 동작 일시 정지)
        &lt;ul&gt;
          &lt;li&gt;Runnable 상태로 전환되는 조건
            &lt;ol&gt;
              &lt;li&gt;대기상태의 Thread의 sleep(), join() 시간이 종료되었을 경우&lt;/li&gt;
              &lt;li&gt;wait()에 대한 notify() 메소드가 호출된 경우&lt;/li&gt;
              &lt;li&gt;interrupt() 메소드가 호출된 경우&lt;/li&gt;
              &lt;li&gt;I/O가 종료된 경우&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;동작중인 Thread에서 yield() 메소드 호출시 동작을 멈추고 Runnable 상태로 전환되어 다시 race condition에 들어간다.&lt;/li&gt;
  &lt;li&gt;Terminate
    &lt;ul&gt;
      &lt;li&gt;Thread의 run() 메소드가 종료되면 Terminate 상태로 전환됨.&lt;/li&gt;
      &lt;li&gt;한번 소멸한 Thread는 더이상 동작하지 않는다.
        &lt;ul&gt;
          &lt;li&gt;다시 동작시키려면 Thread를 다시 생성하여 다시 동작시켜야 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;thread-구현&quot;&gt;Thread 구현&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Runnable interface를 implements 하거나 extends 하면 된다. (이미 상속중인 다른 클래스가 있으면 implements하면 됨.)
    &lt;ul&gt;
      &lt;li&gt;Runnable을 implements한 경우
        &lt;ul&gt;
          &lt;li&gt;객체는 Thread가 아니다: Runnable 객체이다.&lt;/li&gt;
          &lt;li&gt;Thread가 수행해야 하는 작업을 run() 메소드에 정의해야 한다.&lt;/li&gt;
          &lt;li&gt;여러 Thread가 하나의 Runnable 객체를 실행할수도 있고, 각자 다른 Runnable 객체를 실행할수도 있다. (하나의 Runnable 객체일 경우 자원 공유됨)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Thread.run(): callback 메소드(사용자에 의해 직접 호출되지 않지만 특정 조건을 만족하면 자동으로 실행되는 메소드)
    &lt;ul&gt;
      &lt;li&gt;Thread의 run() 메소드를 호출하여 실행하면: main Thread가 실행하는 것.&lt;/li&gt;
      &lt;li&gt;Thread의 start() 메소드를 호출하여 자동 실행되면: run()이 정의된 클래스의 Thread가 실행하는 것.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;thread-구조&quot;&gt;Thread 구조&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/23356503/51823142-dec73180-2321-11e9-88f8-eb20c5b72bd0.png&quot; alt=&quot;Thread 구조&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Runnable 객체를 직접 implements 하거나 Runnable 객체를 implements하는 Thread 클래스를 상속받는 두가지 형태 모두 가능.&lt;/li&gt;
  &lt;li&gt;Thread.run(): 아무 내용 없는 메소드(추상메소드나 다름없다.)
    &lt;ul&gt;
      &lt;li&gt;Thread를 상속한 클래스에서 반드시 오버라이딩해야 한다.&lt;/li&gt;
      &lt;li&gt;Thread 클래스를 추상클래스로 만들 수 없어 이런 형태로 만들어짐.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Thread 객체를 생성하려면 target 객체(Runnable 객체)를 넣어줄 것.
    &lt;ul&gt;
      &lt;li&gt;따로 안넣어주면 Thread.run()이 실행되어 아무 결과도 안나옴.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;thread-동기화-문제&quot;&gt;Thread 동기화 문제&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;데이터가 여러 Thread들에 의해 공유되어 발생.&lt;/li&gt;
  &lt;li&gt;예
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  int count = 0;
  Thread t1, t2, t3;

  public void run(){ // t1, t2, t3가 모두 같은 메소드 사용.
      go();
  }

  /*
  * 작업 과정
  * 1. 현재 count값 읽기
  * 2. 연산
  * 3. 새로운 값 저장.
  */
  public void go(){
      count++;
      System.out.println(count);
  }

  =&amp;gt; 각 thread의 접근 순서에 따라 다른 결과가 나온다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;해결: 공유하는 메소드에 synchronized 키워드를 붙인다.
    &lt;ul&gt;
      &lt;li&gt;public synchronized void go() {…}&lt;/li&gt;
      &lt;li&gt;한번에 한 Thread만 자원에 접근할 수 있으므로 순차실행 형태가 된다. (일종의 lock을 거는 것) - 꼭 필요한 부분에만 사용할것.&lt;/li&gt;
      &lt;li&gt;method뿐 아닌 객체에도 사용 가능. (run() 메소드에는 사용할 수 없다: run()은 오버라이딩된 메소드이므로)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;thread의-method&quot;&gt;Thread의 method&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;join(): 다른 Thread가 종료될때까지 join()을 호출하는 Thread가 대기한다.&lt;/li&gt;
  &lt;li&gt;notify(): Thread와 Thread간에 신호를 줄 때 사용 (깨울 메소드가 없으면 아무 동작도 안함)&lt;/li&gt;
  &lt;li&gt;wait(): 다른 Thread가 notify()를 호출하기 전까지 대기.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;wait(), notify()는 synchronized 영역에서만 사용 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java-소켓-통신&quot;&gt;Java 소켓 통신&lt;/h1&gt;
&lt;h2 id=&quot;server&quot;&gt;Server&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;ServerSocket(port번호) 생성&lt;/li&gt;
  &lt;li&gt;ServerSocket.accept() 호출
    &lt;ul&gt;
      &lt;li&gt;클라이언트가 접속할대까지 기다리고, 클라이언트가 접속하면 클라이언트 소켓을 받아온다.&lt;/li&gt;
      &lt;li&gt;block되는 특징: 요구 조건(클라이언트의 접속)을 만족하지 않으면 이후 내용을 실행하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;도착한 클라이언트 소켓으로부터 입출력 스트림을 얻어낸다.&lt;/li&gt;
  &lt;li&gt;스트림으로 메시지 전송&lt;/li&gt;
  &lt;li&gt;ServerSocket 닫기(close() 호출)&lt;/li&gt;
  &lt;li&gt;스트림 닫기&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;client&quot;&gt;Client&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Socket(서버 ip주소, 서버 port번호) 생성: 소켓 객체가 만들어지는 순간 서버에 접속된다.&lt;/li&gt;
  &lt;li&gt;생성한 Socket으로부터 입출력 스트림을 얻어낸다.&lt;/li&gt;
  &lt;li&gt;스트림으로 메시지 전송&lt;/li&gt;
  &lt;li&gt;Socket 닫기(close() 호출)&lt;/li&gt;
  &lt;li&gt;스트림 닫기&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Java" /><summary type="html">알고리즘 스터디 내용 정리</summary></entry><entry><title type="html">10026</title><link href="keithlee94.github.io/algorithm/10026/" rel="alternate" type="text/html" title="10026" /><published>2019-01-28T00:00:00+09:00</published><updated>2019-01-28T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/10026</id><content type="html" xml:base="keithlee94.github.io/algorithm/10026/">&lt;h1 id=&quot;백준-10026번&quot;&gt;백준 10026번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/10026&quot;&gt;10026번: 적록색약&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;이번에도 BFS 문제.&lt;/p&gt;

&lt;p&gt;각각의 색깔명에 대해 전체 map이 몇개의 영역으로 나눠지는지 구하는 문제였다.&lt;/p&gt;

&lt;p&gt;한가지 특이했던 점은 적록색맹이라는 상황을 줌으로써 R값과 G값을 같은 값으로 보고 풀어야 하는 부분이 존재했다는 점.&lt;/p&gt;

&lt;p&gt;적록색맹이 아닌 사람과 적록색맹인 사람의 경우를 따로 나눠 구해야 한다.&lt;/p&gt;

&lt;p&gt;처음에는 map을 아예 새로 만들까 했었는데, 조건문에서 R과 G에 대한 조건을 or로 묶으니 굳이 안그래도 해결됐다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 28/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;string.h&amp;gt;

using namespace std;

int N;
char map[101][101];
bool visit[101][101];

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

int normalResult = 0;
int redGreenResult = 0;

void BFS_normal(int startX, int startY){
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;

    Queue.push(make_pair(startX, startY));
    visit[startX][startY] = true;

    while(!Queue.empty()){
        int currentX = Queue.front().first;
        int currentY = Queue.front().second;
        Queue.pop();

        for(int i=0; i&amp;lt;4; i++){
            int nextX = currentX + dx[i];
            int nextY = currentY + dy[i];

            if(nextX &amp;gt;= 1 &amp;amp;&amp;amp; nextX &amp;lt;= N &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt;= N){
                if(map[startX][startY] == 'R'){
                    if(map[nextX][nextY] == 'R' &amp;amp;&amp;amp; !visit[nextX][nextY]){
                        visit[nextX][nextY] = true;
                        Queue.push(make_pair(nextX, nextY));
                    }
                }
                else if(map[startX][startY] == 'G'){
                    if(map[nextX][nextY] == 'G' &amp;amp;&amp;amp; !visit[nextX][nextY]){
                        visit[nextX][nextY] = true;
                        Queue.push(make_pair(nextX, nextY));
                    }
                }
                else if(map[startX][startY] == 'B'){
                    if(map[nextX][nextY] == 'B' &amp;amp;&amp;amp; !visit[nextX][nextY]){
                        visit[nextX][nextY] = true;
                        Queue.push(make_pair(nextX, nextY));
                    }
                }
            }
        }
    }

    normalResult++;
}

void BFS_redGreen(int startX, int startY){
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;

    Queue.push(make_pair(startX, startY));
    visit[startX][startY] = true;

    while(!Queue.empty()){
        int currentX = Queue.front().first;
        int currentY = Queue.front().second;
        Queue.pop();

        for(int i=0; i&amp;lt;4; i++){
            int nextX = currentX + dx[i];
            int nextY = currentY + dy[i];

            if(nextX &amp;gt;= 1 &amp;amp;&amp;amp; nextX &amp;lt;= N &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt;= N){
                if(map[startX][startY] == 'R' || map[startX][startY] == 'G'){
                    if((map[nextX][nextY] == 'R' || map[nextX][nextY] == 'G') &amp;amp;&amp;amp; !visit[nextX][nextY]){
                        visit[nextX][nextY] = true;
                        Queue.push(make_pair(nextX, nextY));
                    }
                }
                else if(map[startX][startY] == 'B'){
                    if(map[nextX][nextY] == 'B' &amp;amp;&amp;amp; !visit[nextX][nextY]){
                        visit[nextX][nextY] = true;
                        Queue.push(make_pair(nextX, nextY));
                    }
                }
            }
        }
    }

    redGreenResult++;
}

int main(){
    cin &amp;gt;&amp;gt; N;

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=N; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=N; j++){
            if(!visit[i][j]){
                BFS_normal(i, j);
            }
        }
    }

    bzero(visit, sizeof(visit));

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=N; j++){
            if(!visit[i][j]){
                BFS_redGreen(i, j);
            }
        }
    }

    cout &amp;lt;&amp;lt; normalResult &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; redGreenResult &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="BFS" /><summary type="html">백준 10026번 Link: 10026번: 적록색약</summary></entry><entry><title type="html">2644</title><link href="keithlee94.github.io/algorithm/2644/" rel="alternate" type="text/html" title="2644" /><published>2019-01-28T00:00:00+09:00</published><updated>2019-01-28T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2644</id><content type="html" xml:base="keithlee94.github.io/algorithm/2644/">&lt;h1 id=&quot;백준-2644번&quot;&gt;백준 2644번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2644&quot;&gt;2644번: 촌수계산&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;역시나 BFS문제.&lt;/p&gt;

&lt;p&gt;저번에 풀었던 토마토 문제처럼, 이 문제도 트리 내에서 출발지와 목적지를 설정하여 목적지까지 도달하는데 거치는 트리 레벨을 세면 되는 문제였다.&lt;/p&gt;

&lt;p&gt;주의해야할 점은 방향이 없는 그래프 문제였다는 점.&lt;/p&gt;

&lt;p&gt;이외에는 다소 평이했던 문제였다…&lt;/p&gt;

&lt;p&gt;라고 하기에는 막판에 뻘짓을 좀 했다.&lt;/p&gt;

&lt;p&gt;도달할 수 없는 경우 -1로 처리하는 부분에서 살짝 헤맸던 것 빼고는 할만한 문제였다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 28/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int map[101][101] = {0, };
bool visit[101][101] = {false, };

int n;

int BFS(int start, int end){
    int result = 0;

    queue&amp;lt;int&amp;gt; Queue;
    Queue.push(start);

    while(!Queue.empty()){
        vector&amp;lt;int&amp;gt; available;

        while(!Queue.empty()) {
            available.push_back(Queue.front());
            Queue.pop();
        }

        for(int i=0; i&amp;lt;available.size(); i++) {
            int current = available[i];

            for (int j = 1; j &amp;lt;= n; j++) {
                if (map[current][j] == 1 &amp;amp;&amp;amp; !visit[current][j]) {
                    visit[current][j] = true;
                    visit[j][current] = true;
                    Queue.push(j);
                }
            }
        }

        result++;

        for(int i=1; i&amp;lt;=n; i++){
            if(visit[end][i] &amp;amp;&amp;amp; visit[i][end]){
                return result;
            }
        }

    }
}

int main(){
    cin &amp;gt;&amp;gt; n;

    int start, end;
    cin &amp;gt;&amp;gt; start &amp;gt;&amp;gt; end;

    int m;
    cin &amp;gt;&amp;gt; m;

    for(int i=0; i&amp;lt;m; i++){
        int x, y;
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;

        map[x][y] = 1;
        map[y][x] = 1;
    }

    int result = BFS(start, end);

    bool find = false;
    for(int i=1; i&amp;lt;=n; i++){
        if(visit[end][i] &amp;amp;&amp;amp; visit[i][end]){
            find = true;
        }
    }

    if(!find){
        result = -1;
    }

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="BFS" /><summary type="html">백준 2644번 Link: 2644번: 촌수계산</summary></entry><entry><title type="html">7569</title><link href="keithlee94.github.io/algorithm/7569/" rel="alternate" type="text/html" title="7569" /><published>2019-01-24T00:00:00+09:00</published><updated>2019-01-24T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/7569</id><content type="html" xml:base="keithlee94.github.io/algorithm/7569/">&lt;h1 id=&quot;백준-7569번&quot;&gt;백준 7569번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/7576&quot;&gt;7569번: 토마토&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;이번에도 BFS문제다.&lt;/p&gt;

&lt;p&gt;저번에 컨디션 아주 별로였던날 한번 보고 어떻게풀지 감이 안와서 포기하고 삼성 기출문제 풀었었는데, 오늘은 마음잡고 제대로 들여다봤다.&lt;/p&gt;

&lt;p&gt;백준에는 똑같은 이름의 조금 간단한 문제가 하나 있는데, 이 문제는 그 문제에서 3차원 공간에 대해 생각해보는 요소가 추가된 문제다.&lt;/p&gt;

&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/7576&quot;&gt;7576번: 토마토&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;풀이 방법은 이 문제를 푸는 방법과 크게 다를게 없다.&lt;/p&gt;

&lt;p&gt;그저께 풀었던 문제도 그랬는데, 이 문제나 저 문제도 BFS를 통해 트리를 탐색한다고 생각해볼때 몇개의 레벨을 탐색했는지 세면 되는 문제다.&lt;/p&gt;

&lt;p&gt;우선 input값이 1인 것들을 visit했다고 표시한 다음 큐에 넣는다.&lt;/p&gt;

&lt;p&gt;그리고 BFS를 진행하는데, 우선 트리의 레벨을 세기 위해 큐의 모든 요소들을 벡터에 따로 빼놓고 벡터의 요소들에 대한 BFS를 진행한다.&lt;/p&gt;

&lt;p&gt;주의해야 할 점은 3차원적 요소도 고려해야 하는 만큼, 기존 4방향에 더해 위 상자, 아래 상자도 고려하며 구현해야 한다.&lt;/p&gt;

&lt;p&gt;이외에는 기존 BFS와 다를 게 없다.&lt;/p&gt;

&lt;p&gt;while문을 한번 끝낼때마다 결과값을 1씩 더해주는 식으로 완전탐색을 진행하면 답이 나온다.&lt;/p&gt;

&lt;p&gt;나같은 경우에는 결과값의 초기값을 0으로 설정해뒀기 때문에 최종 결과 출력 전에 구한 결과값에서 1을 뺀 값이 맞는 값이다.&lt;/p&gt;

&lt;p&gt;BFS가 끝난 후, map에 0이 남아있는지 세보고 결과값을 설정해준 다음 출력해주니 바로 풀렸다.&lt;/p&gt;

&lt;p&gt;3차원 배열을 써야 풀릴것 같긴 했는데 시간초과나 메모리초과로 실패하지 않을까 고민하면서 구현했다.&lt;/p&gt;

&lt;p&gt;실제로 돌려보니 메모리는 꽤 많이 사용하면서도 시간초과 없이 풀리는걸 보니 아주 무식하게 3차원 배열을 전부 탐색하며 푸는 문제가 맞았던 것 같다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 24/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int map[100][100][100] = {0, };
bool visit[100][100][100] = {false, };

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
int dz[2] = {-1, 1};

// 가로, 세로, 높이
int M, N, H;
int result = 0;

queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; Queue;

void BFS(){
    while(!Queue.empty()){
        vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; starts;

        while(!Queue.empty()){
            starts.push_back(make_pair(Queue.front().first, make_pair(Queue.front().second.first, Queue.front().second.second)));
            Queue.pop();
        }

        for(int v=0; v&amp;lt;starts.size(); v++){
            int startZ = starts[v].first;
            int startX = starts[v].second.first;
            int startY = starts[v].second.second;

            for(int i=0; i&amp;lt;4; i++){
                int nextX = startX + dx[i];
                int nextY = startY + dy[i];

                if(nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt; N &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt; M){
                    if(!visit[startZ][nextX][nextY] &amp;amp;&amp;amp; map[startZ][nextX][nextY] == 0){
                        visit[startZ][nextX][nextY] = true;
                        map[startZ][nextX][nextY] = 1;
                        Queue.push(make_pair(startZ, make_pair(nextX, nextY)));
                    }
                }
            }

            for(int i=0; i&amp;lt;2; i++){
                int nextZ = startZ + dz[i];

                if(nextZ &amp;gt;= 0 &amp;amp;&amp;amp; nextZ &amp;lt; H){
                    if(!visit[nextZ][startX][startY] &amp;amp;&amp;amp; map[nextZ][startX][startY] == 0){
                        visit[nextZ][startX][startY] = true;
                        map[nextZ][startX][startY] = 1;
                        Queue.push(make_pair(nextZ, make_pair(startX, startY)));
                    }
                }
            }
        }

        result++;

    }

}

int main(){
    cin &amp;gt;&amp;gt; M &amp;gt;&amp;gt; N &amp;gt;&amp;gt; H;

    // (층, (가로, 세로)) 쌍으로 저장한다.
    vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; coordinates;

    for(int i=0; i&amp;lt;H; i++){
        for(int j=0; j&amp;lt;N; j++){
            for(int k=0; k&amp;lt;M; k++){
                cin &amp;gt;&amp;gt; map[i][j][k];
                if(map[i][j][k] == 1){
                    visit[i][j][k] = true;
                    Queue.push(make_pair(i, make_pair(j, k)));
                }
            }
        }
    }

    BFS();

    for(int i=0; i&amp;lt;H; i++){
        for(int j=0; j&amp;lt;N; j++){
            for(int k=0; k&amp;lt;M; k++){
                if(map[i][j][k] == 0){
                    result = -1;
                    break;
                }
            }
        }
    }

    if(result != -1){
        cout &amp;lt;&amp;lt; result-1 &amp;lt;&amp;lt; '\n';
    }
    else{
        cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="BFS" /><summary type="html">백준 7569번 Link: 7569번: 토마토</summary></entry><entry><title type="html">2583</title><link href="keithlee94.github.io/algorithm/2583/" rel="alternate" type="text/html" title="2583" /><published>2019-01-22T00:00:00+09:00</published><updated>2019-01-22T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2583</id><content type="html" xml:base="keithlee94.github.io/algorithm/2583/">&lt;h1 id=&quot;백준-2583번&quot;&gt;백준 2583번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2583&quot;&gt;2583번: 영역 구하기&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;기초적인 BFS 문제다.&lt;/p&gt;

&lt;p&gt;2차원 배열에 모눈종이를 표시하고, 표시되지 않은 부분들에 대해 BFS를 진행하며 각 영역의 크기와 총 영역 갯수를 구하는 문제.&lt;/p&gt;

&lt;p&gt;문제 보기에 좌표가 조금 다르게 표현되어 있어 이를 2차원 배열로 옮기는 과정에서 생각을 좀 했었다.&lt;/p&gt;

&lt;p&gt;좌표만 잘 옮기면 무난히 풀 수 있는 문제.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 22/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

int M, N, K;
int result = 0;

int map[100][100];
bool visit[100][100];

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

vector&amp;lt;int&amp;gt; areas;

void BFS(int startX, int startY){
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;
    Queue.push(make_pair(startX, startY));

    int area = 1;

    while(!Queue.empty()){
        int currentX = Queue.front().first;
        int currentY = Queue.front().second;
        Queue.pop();

        for(int i=0; i&amp;lt;4; i++){
            int nextX = currentX + dx[i];
            int nextY = currentY + dy[i];

            if(nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt; M &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt; N){
                if(!visit[nextX][nextY] &amp;amp;&amp;amp; map[nextX][nextY] == 0){
                    visit[nextX][nextY] = true;
                    Queue.push(make_pair(nextX, nextY));
                    area++;
                }
            }
        }
    }

    result++;
    areas.push_back(area);
}

int main(){
    cin &amp;gt;&amp;gt; M &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K;

    bzero(map, sizeof(map));

    for(int i=0; i&amp;lt;K; i++){
        int startX, startY, endX, endY;

        cin &amp;gt;&amp;gt; startX &amp;gt;&amp;gt; startY &amp;gt;&amp;gt; endX &amp;gt;&amp;gt; endY;

        for(int j=startY; j&amp;lt;endY; j++){
            for(int k=startX; k&amp;lt;endX; k++){
                map[j][k] = 1;
            }
        }
    }

    for(int i=0; i&amp;lt;M; i++){
        for(int j=0; j&amp;lt;N; j++){
            if(!visit[i][j] &amp;amp;&amp;amp; map[i][j] == 0){
                visit[i][j] = true;
                BFS(i, j);
            }
        }
    }

    sort(areas.begin(), areas.end());
    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';
    for(int i=0; i&amp;lt;areas.size(); i++){
        cout &amp;lt;&amp;lt; areas[i] &amp;lt;&amp;lt; ' ';
    }
    cout &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="BFS" /><summary type="html">백준 2583번 Link: 2583번: 영역 구하기</summary></entry><entry><title type="html">7562</title><link href="keithlee94.github.io/algorithm/7562/" rel="alternate" type="text/html" title="7562" /><published>2019-01-22T00:00:00+09:00</published><updated>2019-01-22T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/7562</id><content type="html" xml:base="keithlee94.github.io/algorithm/7562/">&lt;h1 id=&quot;백준-7562번&quot;&gt;백준 7562번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/7562&quot;&gt;7562번: 나이트의 이동&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;이번에도 BFS문제다.&lt;/p&gt;

&lt;p&gt;기본적인 BFS문제와 다른 점은 나이트의 이동 반경을 전부 표시하려면 8가지의 경우의 수가 나온다는 점인데 이 8가지를 전부 고려해보고 이동시켜야 한다.&lt;/p&gt;

&lt;p&gt;8가지 경우를 각 경우에 대해 다 찾아봐야 해서 시간초과 날줄 알았는데 정직하게 BFS 돌려도 시간내에 풀리는 문제였다.&lt;/p&gt;

&lt;p&gt;답을 구하려면 BFS를 진행하며 거친 트리의 레벨을 구하면 되는데, 이 과정에서 어떻게 구현할지 고민을 많이 했던 것 같다.&lt;/p&gt;

&lt;p&gt;보통 아는 BFS대로 하면 말도안되는 큰수가 나오더라.&lt;/p&gt;

&lt;p&gt;어떻게할지 고민해보다 예전에 풀었던 BFS 문제 중 큐에 있는 모든 원소를 pop해서 저장한 다음, 그 모든 원소에 대해 각각 BFS를 진행하는 문제를 풀어본 기억이 났다.&lt;/p&gt;

&lt;p&gt;그대로 적용해서 풀어보니 바로 풀렸다.&lt;/p&gt;

&lt;p&gt;그 문제 풀때는 풀이방법을 모르겠어서 답을 봤던것 같은데, 이번에는 내가 직접 방법을 떠올려 구현하고 풀었다는 점은 발전 요소.&lt;/p&gt;

&lt;p&gt;앞으로도 트리 레벨 구하는 유형은 이런식으로 풀면 될것 같다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 22/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string.h&amp;gt;

using namespace std;

int I;
int result = 0;

int map[300][300];
bool visit[300][300];

int dx[8] = {-2, -1, 1, 2, -2, -1, 1, 2};
int dy[8] = {-1, -2, -2, -1, 1, 2, 2, 1};

void BFS(int startX, int startY, int endX, int endY){
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;
    Queue.push(make_pair(startX, startY));
    visit[startX][startY] = true;

    while(!Queue.empty()){
        vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; currents;

        while(!Queue.empty()){
            int currentX = Queue.front().first;
            int currentY = Queue.front().second;
            Queue.pop();
            currents.push_back(make_pair(currentX, currentY));
        }

        for(int q=0; q&amp;lt;currents.size(); q++){
            int currentX = currents[q].first;
            int currentY = currents[q].second;

            if(currentX == endX &amp;amp;&amp;amp; currentY == endY){
                return;
            }

            for(int i=0; i&amp;lt;8; i++){
                int nextX = currentX + dx[i];
                int nextY = currentY + dy[i];

                if(nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt; I &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt; I) {
                    if(!visit[nextX][nextY]){
                        visit[nextX][nextY] = true;
                        Queue.push(make_pair(nextX, nextY));
                    }
                }
            }
        }

        result++;

    }
}

int main(){
    int tc;
    cin &amp;gt;&amp;gt; tc;

    for(int test=0; test&amp;lt;tc; test++){
        bzero(visit, sizeof(visit));
        result = 0;
        cin &amp;gt;&amp;gt; I;

        int startX, startY;
        cin &amp;gt;&amp;gt; startX &amp;gt;&amp;gt; startY;

        int endX, endY;
        cin &amp;gt;&amp;gt; endX &amp;gt;&amp;gt; endY;

        BFS(startX, startY, endX, endY);

        cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="BFS" /><summary type="html">백준 7562번 Link: 7562번: 나이트의 이동</summary></entry><entry><title type="html">11724</title><link href="keithlee94.github.io/algorithm/11724/" rel="alternate" type="text/html" title="11724" /><published>2019-01-21T00:00:00+09:00</published><updated>2019-01-21T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/11724</id><content type="html" xml:base="keithlee94.github.io/algorithm/11724/">&lt;h1 id=&quot;백준-11724번&quot;&gt;백준 11724번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/11724&quot;&gt;11724번: 연결 요소의 개수&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;기초적인 DFS, BFS 문제다.&lt;/p&gt;

&lt;p&gt;2차원 배열에 연경 요소들을 1로 표시하고, BFS나 DFS를 사용하여 탐색하면서 연결된 요소의 갯수를 구하는 문제.&lt;/p&gt;

&lt;p&gt;한가지 간과하기 쉬운 사실은, 이 그래프는 방향이 없는 그래프이기 때문에 연결시 쌍방향을 전부 1로 설정해줘야 한다는 점.&lt;/p&gt;

&lt;p&gt;처음에는 배열 인덱스때문에 두어번 틀렸다가 맞게 풀었더니 시간초과가 났다.&lt;/p&gt;

&lt;p&gt;BFS를 사용하여 시간 내에 풀기 위해서는 큐에서 정점을 뺄 때가 아닌 큐에 넣는 시점에 visit을 표시해야 한다는 것을 알게 되었다.&lt;/p&gt;

&lt;p&gt;오늘은 BFS, DFS 감찾는다고 생각하고 앞으로 집중적으로 어려운 문제도 풀어볼 예정이다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 21/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

int N, M;
int map[1001][1001] = {0, };
bool visit[1001] = {false, };

int result = 0;

void BFS(int start){
    queue&amp;lt;int&amp;gt; Queue;
    Queue.push(start);

    while(!Queue.empty()){
        int next = Queue.front();
        Queue.pop();

        for(int i=1; i&amp;lt;=N; i++){
            if(!visit[i] &amp;amp;&amp;amp; map[next][i] == 1){
                visit[i] = true;
                Queue.push(i);
            }
        }
    }

    result++;
}

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;

    for(int i=0; i&amp;lt;M; i++){
        int start, end;
        cin &amp;gt;&amp;gt; start &amp;gt;&amp;gt; end;
        map[start][end] = 1;
        map[end][start] = 1;
    }

    for(int i=1; i&amp;lt;=N; i++){
        if(!visit[i]){
            visit[i] = true;
            BFS(i);
        }
    }

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DFS" /><category term="BFS" /><summary type="html">백준 11724번 Link: 11724번: 연결 요소의 개수</summary></entry><entry><title type="html">6th week summary</title><link href="keithlee94.github.io/java/6th-Week-Summary/" rel="alternate" type="text/html" title="6th week summary" /><published>2019-01-19T00:00:00+09:00</published><updated>2019-01-19T00:00:00+09:00</updated><id>keithlee94.github.io/java/6th%20Week%20Summary</id><content type="html" xml:base="keithlee94.github.io/java/6th-Week-Summary/">&lt;h1 id=&quot;알고리즘-스터디-내용-정리&quot;&gt;알고리즘 스터디 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;자료구조&quot;&gt;자료구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;선형
    &lt;ul&gt;
      &lt;li&gt;이전, 이후 데이터가 1:1 관계이다.&lt;/li&gt;
      &lt;li&gt;특정 데이터의 다음에 올 데이터가 무엇인지 확실히 알 수 있다.(예: 배열, 연결리스트)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비선형
    &lt;ul&gt;
      &lt;li&gt;이전, 이후 데이터가 1:다 or 다:다 관계이다.&lt;/li&gt;
      &lt;li&gt;특정 데이터의 다음에 올 데이터가 무엇인지 확실하게 알 수 없다.&lt;/li&gt;
      &lt;li&gt;전체를 빠짐없이 순회하며 한번씩만 방문하는 것이 관건(예: 그래프)
        &lt;ul&gt;
          &lt;li&gt;그래프
            &lt;ul&gt;
              &lt;li&gt;트리: 사이클이 없어야 한다.&lt;/li&gt;
              &lt;li&gt;트리를 제외한 나머지: 사이클이 있을 수 있다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;검색&quot;&gt;검색&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;순차 검색
    &lt;ul&gt;
      &lt;li&gt;O(n) -&amp;gt; Best: O(1), Worst: O(n), Average: O(n/2) = O(n)&lt;/li&gt;
      &lt;li&gt;정렬 여부와 상관없이 사용 가능.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이진 검색
    &lt;ul&gt;
      &lt;li&gt;O(log n)&lt;/li&gt;
      &lt;li&gt;Divide &amp;amp; Conquer&lt;/li&gt;
      &lt;li&gt;자료가 정렬된 상태에서만 사용 가능.&lt;/li&gt;
      &lt;li&gt;데이터 양이 많을수록 유리함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정렬되지-않은-데이터-검색&quot;&gt;정렬되지 않은 데이터 검색&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;이진 검색
    &lt;ol&gt;
      &lt;li&gt;정렬&lt;/li&gt;
      &lt;li&gt;이진검색
        &lt;ul&gt;
          &lt;li&gt;O(n^2) + O(log n) = O(n^2) 소요.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;순차검색: O(n)&lt;/li&gt;
  &lt;li&gt;결론: 정렬 알고리즘에서 이미 순차검색보다 성능이 떨어지므로 정렬되지 않은 데이터에 대해서는 순차검색을 사용하는 것이 유리하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java-메모리-영역&quot;&gt;Java 메모리 영역&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Call Stack: 자동으로 초기화되지 않음.&lt;/li&gt;
  &lt;li&gt;Heap: 자동으로 초기화됨.&lt;/li&gt;
  &lt;li&gt;Method Area: 자동으로 초기화됨.&lt;/li&gt;
  &lt;li&gt;Constant Pool: Method Area에 포함됨. 상수를 재활용하기 위해 존재함.(여러개의 상수가 있어도 해싱하여 저장되므로 검색시간이 느려지는 일이 없다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;string-선언별-차이점&quot;&gt;String 선언별 차이점&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;String str1 = “abc”; =&amp;gt; Constant Pool에 생성된다.&lt;/li&gt;
  &lt;li&gt;String str2 = new String(“abc”); =&amp;gt; Heap에 생성된다.&lt;/li&gt;
  &lt;li&gt;String str3 = “abc”; =&amp;gt; str1과 같은 주소가 할당된다.&lt;/li&gt;
  &lt;li&gt;str1, str3처럼 기본형으로 만들 경우 Constant Pool에 저장되고, 둘의 값이 같을 경우 같은 주소가 할당된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;stringtokenizer&quot;&gt;StringTokenizer&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;문자열을 쪼갤때 사용한다.&lt;/li&gt;
  &lt;li&gt;정규식을 인자로 허용하지 않으므로 String.split()보다 속도가 빠르다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;stringbuilder-stringbuffer&quot;&gt;StringBuilder, StringBuffer&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;문자열 저장시 사용.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;objectequals&quot;&gt;Object.equals()&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 자식 클래스에서 사용할지 모르므로 == 연산자로 구현되어 있다.&lt;/li&gt;
  &lt;li&gt;내용 비교하려면: 자식 클래스에서 오버라이딩하여 사용해야 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;dp와-divide--conquer&quot;&gt;DP와 Divide &amp;amp; Conquer&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Divide &amp;amp; Conquer: 작은 문제를 해결하여 큰 문제를 해결하는 기법.&lt;/li&gt;
  &lt;li&gt;DP: Divide &amp;amp; Conquer + Memoization. 작은 문제를 해결하고 이를 따로 저장해둠으로써 똑같은 작은 문제를 다시 풀게 되어 발생하는 시간 낭비를 줄일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java-스터디-내용-정리&quot;&gt;Java 스터디 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;자주-오버라이딩하는-함수들&quot;&gt;자주 오버라이딩하는 함수들&lt;/h1&gt;
&lt;h2 id=&quot;1-tostring&quot;&gt;1. toString()&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 오버라이딩 했을 경우: System.out.println(객체); 실행시 객체의 클래스에서 재정의된 toString()이 실행됨.
- 오버라이딩 안했을 경우: System.out.println(객체); 실행시 주소값만 출력된다 - Object 클래스의 toString()은 객체의 주소값만 돌려주므로.
- 출력함수의 인자로 객체를 넣을 시 자동으로 toString()이 호출된다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-hashcode&quot;&gt;2. hashCode()&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 같은 객체인지 확인할 때 사용.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-equals&quot;&gt;3. equals()&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 두 객체의 내용물이 같은지 확인할 때 사용.
- Object.equals(): 단순 객체 주소 비교.
- String.equals(): Object.equals()를 오버라이딩하여 문자 하나씩 비교하여 일치하는지 확인.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;string-객체의-특징&quot;&gt;String 객체의 특징&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;String 클래스의 메소드들은 원본 데이터를 바꾸지 않는다.&lt;/li&gt;
  &lt;li&gt;String은 final 상수이므로 내용을 바꿀때마다 새로운 데이터가 heap에 쌓인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;사용-제한자&quot;&gt;사용 제한자&lt;/h1&gt;
&lt;h2 id=&quot;1-final&quot;&gt;1. final&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- class, method, variable에 붙일 수 있다.
- class앞에 붙으면: 상속 불가. 그 클래스 안의 모든 method, field는 내용을 변경할 수 없다.
- method앞에 붙으면: 오버라이딩 불가, 오버로딩은 가능.
- field앞에 붙으면: 값 수정 불가.(변수가 상수로 변한다.)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-static&quot;&gt;2. static&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- member변수, member메소드, block에 붙일 수 있다.
- static이 붙은 모든 것들은 main 메소드 실행 전에 Class Area에 한개씩만 생성된다.
    - 실행 전에 만들어진다.
    - 컴파일이 완료된 시점에 생성되므로 따로 객체를 만들 필요가 없다.
- static이 없는 모든 것들은 main 메소드 실행 후 Heap에 생성된다.
    - 실행 후에 만들어진다.
- static variable = class variable
- non-static variable = instance variable
- 다른 클래스에서도 사용 가능: class이름.변수이름 or class이름.메소드이름 으로 사용 가능.
- static block: main 메소드보다 우선순위가 높다.
    - main 메소드보다 먼저 실행된다.
    - static block간 우선순위는 코드 내 순서와 같다.
- static 메소드 내에서는 this, super 키워드를 사용할 수 없다.
    - 이유: this, super 키워드는 객체가 있을때만 사용 가능하다.
    - static 메소드는 객체가 생성되기 전에 실행되므로 this, super 키워드를 사용할 수 없다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-abstract&quot;&gt;3. abstract&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- abstract: 추상적인, 구체적이지 않은, 완성되지 않은.
- abstract 클래스: 클래스 내에 abstract 메소드가 존재한다.
- abstract 메소드: 바디가 없는 미완성 메소드. abstract 클래스 내에만 정의 가능.(C의 prototype과 같다.)
- concrete 메소드: 바디가 있는 완성된 메소드. abstract 클래스 내에도 정의 가능.
- abstract 메소드가 있으면 객체 생성 불가능.
    - 미완성 메소드가 있다 = 미완성 클래스이다.
    - 자식 클래스에서 상속받아 완성시켜야 객체 생성이 가능하다.(자식 클래스가 오버라이딩해야 한다.)
- 장점: 상속관계로 묶여있으므로 여러 종류의 객체들을 부모 타입으로 묶어 하나의 자료구조에 넣고 handling할 수 있다.
- 용도
    - 타입을 물려주는 용도로 빈 껍데기만 미리 만들어놓는다.
    - 객체 생성을 막는 용도로도 사용 가능하다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;interface&quot;&gt;interface&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;추상 클래스와 유사하다.&lt;/li&gt;
  &lt;li&gt;시작 키워드가 class가 아닌 interface이다.(용도는 추상 클래스와 같이 타입을 물려주는 용도이다.)&lt;/li&gt;
  &lt;li&gt;상수와 추상 메소드들로만 구성되어 있다: concrete 메소드를 포함할 수 없다.&lt;/li&gt;
  &lt;li&gt;내부 메소드에 별도로 abstact를 붙일 필요가 없다: interface 자체가 미완성이므로 포함하는 모든 메소드들에 자동으로 public abstract 키워드가 붙는다.&lt;/li&gt;
  &lt;li&gt;내부 field에는 자동으로 static final 키워드가 붙는다: 값을 변경할 수 없다.&lt;/li&gt;
  &lt;li&gt;자식 클래스에서 상속시 extends가 아닌 implements 키워드를 사용해야 한다.&lt;/li&gt;
  &lt;li&gt;다중 상속 지원: implements 키워드를 통해 여러 클래스를 상속 가능하다.&lt;/li&gt;
  &lt;li&gt;extends와 달리 implements 클래스1, 클래스2, … 형태로 사용 가능.&lt;/li&gt;
  &lt;li&gt;예:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  class ICircle extends Boat implements IShape, Seoul
  =&amp;gt; iCircle의 타입이 될 수 있는 것: Boat, IShape, Seoul.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;의존성 감소: 고치는 부분을 줄일 수 있다 - 유지보수를 편하게 해준다.&lt;/li&gt;
  &lt;li&gt;interface와 interface 간에도 상속관계 성립 가능.&lt;/li&gt;
  &lt;li&gt;interface 예시
&lt;img src=&quot;https://user-images.githubusercontent.com/23356503/51424291-ffe79e00-1c0e-11e9-9061-3b57a81ae7ef.png&quot; alt=&quot;interface example&quot; /&gt;
  위 그림처럼 관계를 만든 다음
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  void pay(Thing x){
      ...
  }
  메소드를
  void pay(Valuable x){
      ...
  }
  으로 변경한다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;instanceof&quot;&gt;instanceof&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;상속관계가 없을 경우 사용 불가능한 연산자.&lt;/li&gt;
  &lt;li&gt;작은 타입 -&amp;gt; 큰 타입 순서로 사용해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;has-a-관계&quot;&gt;has-a 관계&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;서로 의존성을 갖게 되는 관계(Coupling) - 지양해야 함.&lt;/li&gt;
  &lt;li&gt;한 클래스가 다른 클래스를 인자로 가지고 있는 관계.&lt;/li&gt;
  &lt;li&gt;수정사항 발생시 두개의 클래스를 전부 수정해야 한다.&lt;/li&gt;
  &lt;li&gt;보완: interface를 사용하여 타입의 자유도를 높여 의존성을 낮출 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;collections&quot;&gt;Collections&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;여러개의 데이터를 저장.&lt;/li&gt;
  &lt;li&gt;저장 방식에 따라 List, Set, Map으로 나뉜다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;center&gt;구분&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;center&gt;List&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;center&gt;Set&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;center&gt;Map&lt;/center&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;중복&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;center&gt;허용&lt;/center&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;center&gt;허용 X&lt;/center&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;center&gt;허용 X&lt;/center&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;순서&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;center&gt;있음&lt;/center&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;center&gt;없음&lt;/center&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;center&gt;없음&lt;/center&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;1-list-기존-배열과-유사&quot;&gt;1. List: 기존 배열과 유사.&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- ArrayList
- Vector
    - 아무 인자 없이 생성시 10칸짜리 Vector가 생성되고, 용량이 부족하면 기존의 크기를 2배로 늘린 후 재배치.
    - Vector.capacity(): Vector 전체의 크기 리턴.
    - Vector.size(): Vector 내 component 갯수 리턴.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-set-집합과-같은-개념&quot;&gt;2. Set: 집합과 같은 개념.&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- HashSet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-map-key-value-쌍으로-데이터-저장-key값-중복-불가&quot;&gt;3. Map: (Key, Value) 쌍으로 데이터 저장, Key값 중복 불가.&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- HashMap
- HashTable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Iterator: 순서 없는 자료구조를 탐색하기 위해 사용함.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;generic-programming&quot;&gt;Generic Programming&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;HashMap&amp;lt;K, V&amp;gt; 와 같이 &amp;lt;…&amp;gt;의 형태를 이룬다.&lt;/li&gt;
  &lt;li&gt;&amp;lt;&amp;gt; 안에는 객체만 올 수 있다: 기본형을 사용하고싶을 경우 wrapper class로 바꿔 넣어야 한다.
    &lt;ul&gt;
      &lt;li&gt;예: int형 ArrayList - ArrayList&lt;Integer&gt;&lt;/Integer&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Generic을 사용할 경우 클래스 변동사항이 있으면 적용되는 시점이 미뤄진다: 객체 생성시 유연성이 생긴다.
    &lt;ul&gt;
      &lt;li&gt;통상 클래스들은 한번 컴파일하면 다시 컴파일하지 않는 이상 변경사항이 반영되지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클래스는 완성되었으나 타입이 정해지지 않은 형태이다.
    &lt;ul&gt;
      &lt;li&gt;설계 단계에서는 타입 미정.&lt;/li&gt;
      &lt;li&gt;객체 생성시 타입 확정.&lt;/li&gt;
      &lt;li&gt;결론: compile time에서는 타입이 결정되지 않은 상태, runtime에서 타입이 결정.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예시
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public class MyClass&amp;lt;X&amp;gt;{
      private X data;

      public X getData(){
          return data;
      }

      public void setData(X data){
          this.data = data;
      }

      public static void main(String[] args){
          MyClass&amp;lt;String&amp;gt; m1 = new MyClass&amp;lt;&amp;gt;();
          MyClass&amp;lt;Integer&amp;gt; m2 = new MyClass&amp;lt;&amp;gt;();
          MyClass&amp;lt;Circle&amp;gt; m3 = new MyClass&amp;lt;&amp;gt;();
      }
  }

  =&amp;gt; m1, m2, m3의 타입은 모두 MyClass로 같다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;singleton-pattern&quot;&gt;Singleton Pattern&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;디자인 패턴: 설계 패턴. 클래스를 설계하는 패턴을 의미.&lt;/li&gt;
  &lt;li&gt;어플리케이션 전체에서 객체를 한개만 생성하여 사용하는 패턴: 하나의 객체를 전체가 공유한다.&lt;/li&gt;
  &lt;li&gt;클래스명에 static이 붙는다: 오직 하나의 객체만 생성한다.&lt;/li&gt;
  &lt;li&gt;조건
    &lt;ol&gt;
      &lt;li&gt;field: private static이며 클래스 자신의 타입으로 선언되어야 한다.&lt;/li&gt;
      &lt;li&gt;생성자: private으로 설정.&lt;/li&gt;
      &lt;li&gt;객체를 생성하여 리턴하는 static 메소드가 반드시 있어야 한다.(통상 getInstance()라는 메소드 정의)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;외부에서 객체 생성에 영향을 주지 않도록 한다
    &lt;ul&gt;
      &lt;li&gt;생성자는 Default 생성자만 두는 경우가 대부분이다.&lt;/li&gt;
      &lt;li&gt;생성자, 생성 메소드 오버로딩하지 않음.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예시
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public class Speaker{
      private static Speaker speaker;
      private int volume;

      private Speaker(){
          volume = 5;
      }

      public static Speaker getInstance(){
          if(speaker == null){
              speaker = new Speaker();
          }

          return speaker;
      }

      public int getVolume(){
          return volume;
      }

      public void setVolume(int volume){
          this.volume = volume;
      }
  }

  public class SingletonTest{

      public static void main(String[] args){
          Speaker s1 = Speaker.getInstance();
          Speaker s2 = Speaker.getInstance();
          Speaker s3 = Speaker.getInstance();

          System.out.println(s1 == s2);
          System.out.prinltn(s2 == s3);

          s1.setVolume(10);
          System.out.println(s1.getVolume());
          System.out.println(s2.getVolume());
          System.out.println(s3.getVolume());
      }
  }

  실행 결과: s1, s2, s3의 주소값은 전부 같다.
  =&amp;gt; 전부 똑같은 하나의 객체만을 가리키고 있으므로, 한 객체에서 volume을 변경하면 모든 객체의 volume이 똑같이 바뀐다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;comparable-comparator&quot;&gt;Comparable, Comparator&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;객체의 정렬과 관련한 인터페이스.&lt;/li&gt;
  &lt;li&gt;Comparable: 클래스 내부에 객체의 정렬 기준을 만들어놓고자 할때 사용하는 인터페이스.(반드시 한개만 존재한다.)&lt;/li&gt;
  &lt;li&gt;Comparator: 클래스 외부에 특정 객체의 정렬 기준을 명시하는 인터페이스.(클래스 내부의 Comparable 이외의 정렬 기준이 필요할 경우 별도의 클래스를 만들어 정의한다. - 정렬 기준은 한 메소드 내에 한개만 정의 가능.)&lt;/li&gt;
  &lt;li&gt;sort()로 정렬 가능한 객체: Comparator나 Comparable 인터페이스를 implements 하고 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;class-종류&quot;&gt;Class 종류&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;VO
    &lt;ul&gt;
      &lt;li&gt;Value Object&lt;/li&gt;
      &lt;li&gt;값을 저장할 수 있는 객체.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DAO
    &lt;ul&gt;
      &lt;li&gt;Data Access Object&lt;/li&gt;
      &lt;li&gt;이미 만들어진 VO를 프로세싱하는 목적.&lt;/li&gt;
      &lt;li&gt;CRUD: Create, Read, Update, Delete 기능 수행.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CO
    &lt;ul&gt;
      &lt;li&gt;Client Object&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Java" /><summary type="html">알고리즘 스터디 내용 정리</summary></entry><entry><title type="html">16234</title><link href="keithlee94.github.io/algorithm/16234/" rel="alternate" type="text/html" title="16234" /><published>2019-01-17T00:00:00+09:00</published><updated>2019-01-17T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/16234</id><content type="html" xml:base="keithlee94.github.io/algorithm/16234/">&lt;h1 id=&quot;백준-16234번&quot;&gt;백준 16234번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/16234&quot;&gt;16234번: 인구 이동&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;작년 하반기 삼성 SW 역량테스트 문제다.&lt;/p&gt;

&lt;p&gt;시험장에서 문제 보고 뭔가싶어서 바로 넘기고 다른문제 올인하다 결국 둘다 못풀어서 광탈했던 악몽이 다시 떠오른다.&lt;/p&gt;

&lt;p&gt;아무 문제나 붙잡고 풀다가 다 안풀려서 어차피 한번은 풀어야될 문제라 결국 붙잡고 풀었다.&lt;/p&gt;

&lt;p&gt;예전부터 지인들이 니가 문제보고 쫄아서그렇지 별거 아닌문제다 라는 말을 했었는데 막상 풀어보니 틀린말은 아닌거같다.&lt;/p&gt;

&lt;p&gt;하지만 내가 저날 시험장에서 이문제를 제대로 읽고 이해했다고 해도 시간안에 푸는건 무리였을것 같다.&lt;/p&gt;

&lt;p&gt;BFS를 여러번 해야되는 문제다.&lt;/p&gt;

&lt;p&gt;map에서 수정할 부분이 어디인지 찾아내는 부분에서 BFS를 해야 하고, 수정할 부분을 찾은 다음 map을 수정하기 위한 BFS를 해야하는 문제.&lt;/p&gt;

&lt;p&gt;거기다 이 과정을 더이상 수정할 부분이 없을때까지 반복해야 한다.&lt;/p&gt;

&lt;p&gt;BFS문제라는 느낌은 확실히 들었다.&lt;/p&gt;

&lt;p&gt;처음에 문제 접했을땐 map에서 수정할 부분을 찾는 과정에 대해 BFS를 써야겠다는 생각이 안들었다.&lt;/p&gt;

&lt;p&gt;그래서 3중 for문을 사용해서 수정할 부분을 찾아 마킹했다.&lt;/p&gt;

&lt;p&gt;그 이후 map을 수정하는 부분에 대해서는 BFS로 구현하여 풀어보았다.&lt;/p&gt;

&lt;p&gt;풀어본 다음 테스트케이스들을 넣어보니, 단순히 3중 for문으로는 풀수 없는 문제라는 것을 깨달았다.&lt;/p&gt;

&lt;p&gt;마지막까지 가장 애먹였던 부분이 이부분인데, map에서 수정할 부분을 단순히 1로 마킹할 경우 영역간 경계가 있으나 이 경계를 무시하고 BFS를 진행하는 문제가 생긴다.&lt;/p&gt;

&lt;p&gt;BFS로 바꿔서 해보고도 마지막에 이부분을 놓쳐 한번 더 삽질하다 결국 풀었다.&lt;/p&gt;

&lt;p&gt;막상 풀고나니 별거 아닌건 맞는데, 시험장의 압박감과 이 시험볼 당시 알고리즘 공부도 어설프게 하고 간 나는 절대 못풀었을 것 같다는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;얻어가는 점은 몇번씩 실패하고도 남의 도움 안받고 내 힘만으로 풀어냈다는 점, BFS문제를 혼자 힘만으로 제대로 풀어냈다는 점이다.&lt;/p&gt;

&lt;p&gt;이런 점을 밑거름삼아 앞으로 있을 역량테스트에서도 포기하지 않고 끝까지 풀어내는 것이 목표이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;다시는 악몽 안꾸련다. 앞으로도 화이팅!!!&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 15/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory.h&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int N, L, R;
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

int map[50][50] = {0, };
int toChange[50][50] = {0, };
int visit[50][50] = {0, };

vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; changes(){
    vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; result;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;N; j++){
            if(toChange[i][j] != 0){
                result.push_back(make_pair(i, j));
            }
        }
    }

    return result;
}

void toChange_init(){
    int areaCount = 1;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;N; j++){
            queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;
            Queue.push(make_pair(i, j));

            while(!Queue.empty()){
                int currentX = Queue.front().first;
                int currentY = Queue.front().second;
                Queue.pop();

                for(int k=0; k&amp;lt;4; k++){
                    int nextX = currentX + dx[k];
                    int nextY = currentY + dy[k];

                    if(nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt; N &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt; N){
                        int gap = abs(map[currentX][currentY] - map[nextX][nextY]);
                        if(gap &amp;gt;= L &amp;amp;&amp;amp; gap &amp;lt;= R &amp;amp;&amp;amp; toChange[nextX][nextY] == 0){
                            toChange[nextX][nextY] = areaCount;
                            Queue.push(make_pair(nextX, nextY));
                        }
                    }
                }
            }

            areaCount++;
        }
    }
}

void BFS(int currentX, int currentY){
    vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; visited;

    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;
    Queue.push(make_pair(currentX, currentY));

    int changeCount = 0;
    int changeSum = 0;
    visit[currentX][currentY] = 1;

    while(!Queue.empty()){
        int startX = Queue.front().first;
        int startY = Queue.front().second;
        Queue.pop();

        changeCount++;
        changeSum += map[startX][startY];
        visited.push_back(make_pair(startX, startY));

        for(int i=0; i&amp;lt;4; i++){
            int nextX = startX + dx[i];
            int nextY = startY + dy[i];

            if(nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt; N &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt; N){
                if(visit[nextX][nextY] == 0 &amp;amp;&amp;amp; toChange[nextX][nextY] == toChange[startX][startY]){
                    Queue.push(make_pair(nextX, nextY));
                    visit[nextX][nextY] = 1;
                }
            }
        }
    }

    for(int i=0; i&amp;lt;visited.size(); i++){
        map[visited[i].first][visited[i].second] = changeSum / changeCount;
    }
}

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; L &amp;gt;&amp;gt; R;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;N; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    int count = 0;

    while(true) {
        memset(toChange, 0, sizeof(toChange));
        memset(visit, 0, sizeof(visit));

        toChange_init();

        vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; ones = changes();
        if (ones.size() == 0) {
            break;
        }

        for (int i = 0; i &amp;lt; ones.size(); i++) {
            if (visit[ones[i].first][ones[i].second] == 0) {
                BFS(ones[i].first, ones[i].second);
            }
        }

        count++;
    }

    cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DFS" /><category term="BFS" /><summary type="html">백준 16234번 Link: 16234번: 인구 이동</summary></entry><entry><title type="html">1520</title><link href="keithlee94.github.io/algorithm/1520/" rel="alternate" type="text/html" title="1520" /><published>2019-01-14T00:00:00+09:00</published><updated>2019-01-14T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1520</id><content type="html" xml:base="keithlee94.github.io/algorithm/1520/">&lt;h1 id=&quot;백준-1520번&quot;&gt;백준 1520번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1520&quot;&gt;1520번: 내리막 길&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;평범한 길찾는문제일줄 알고 우선 BFS부터 냅다 써서 풀었다.&lt;/p&gt;

&lt;p&gt;분명 틀린 답은 아니다. 그런데 문제의 의도는 BFS 대신 DFS를 사용하여 메모리를 절약하고, DFS에 DP를 적용하여 시간을 절약하는 것이 의도였다.&lt;/p&gt;

&lt;p&gt;DFS에 DP를 접목시키는 문제는 처음 보는것 같다.&lt;/p&gt;

&lt;p&gt;그 느린 DFS를 이렇게 보완할수도 있구나 하는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;이 문제를 풀면서 BFS와 DFS의 차이를 제대로 체감할 수 있었던 것 같다.&lt;/p&gt;

&lt;p&gt;BFS는 시간 내에 해를 찾을 수 있지만, 큐를 사용하는 만큼 더 많은 메모리 공간을 사용한다는 점이 특징.&lt;/p&gt;

&lt;p&gt;DFS는 메모리 공간은 절약할 수 있지만, 깊이가 깊어질수록 매우 많은 시간을 요구한다는 점이 특징이다.&lt;/p&gt;

&lt;p&gt;이러한 DFS의 깊이에 따른 문제를 보완하는 방법으로 DP를 사용하는 문제였다.&lt;/p&gt;

&lt;p&gt;둘을 어떻게 접목시킬지 방법이 안떠올라서 결국 답을 찾아보고서야 이해할 수 있었다.&lt;/p&gt;

&lt;p&gt;우선 DP 배열을 전부 -1로 초기화하고 시작한다.&lt;/p&gt;

&lt;p&gt;그 다음, DFS를 목적지부터 (0, 0)까지 가도록 거꾸로 실행한다.&lt;/p&gt;

&lt;p&gt;DFS에 들어가면 우선 DP 배열부터 살펴보게 되는데, DP[startX][startY]가 -1이 아니라는 것은 이미 저장된 값이 있으며, 이는 이미 탐색해서 구한 값이 있음을 의미하므로 그대로 리턴한다.&lt;/p&gt;

&lt;p&gt;만약 startX나 startY가 범위를 벗어나면 0을 리턴하고, (0, 0)에 도착하게 되면 1을 리턴한다.&lt;/p&gt;

&lt;p&gt;이 3가지 조건문에 걸리지 않았다는 것은 아직 탐색하지 않은 곳임을 의미하므로 탐색을 진행한다.&lt;/p&gt;

&lt;p&gt;가장 먼저 DP[startX][startY]를 0으로 설정한다.&lt;/p&gt;

&lt;p&gt;그 다음은 통상 아는 DFS를 진행하는데, 내려가는 방향으로만 갈 수 있고 우리는 DFS를 거꾸로 진행하고 있으므로 map[nextX][nextY]가 map[startX][startY]보다 클 경우에만 DFS를 진행한다.&lt;/p&gt;

&lt;p&gt;조금 다른점이 있다면 통상 아는 DFS였다면 DFS(nextX, nextY)만 부르고 끝났겠지만, 이 문제는 DP를 접목시켜야 하므로 DP[startX][startY]의 값에 DFS(nextX, nextY)를 더한 값을 설정한다.&lt;/p&gt;

&lt;p&gt;이때 연쇄적으로 재귀함수를 돌다 더 갈수 없으면 DP[startX][startY]를 리턴하고, 리턴되는 값을 계속 더해주는 것이다.&lt;/p&gt;

&lt;p&gt;같은 방법으로 4방향 모두 탐색하며 DFS를 완성한다.&lt;/p&gt;

&lt;p&gt;풀이방법을 외워둬야 할 것 같은 문제다.&lt;/p&gt;

&lt;p&gt;BFS와 DFS의 차이점, DFS와 DP의 연계를 모두 배울 수 있는 문제였다. 까먹을때쯤 꼭 다시풀어볼 문제.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;bfs로-풀다-틀린-코드&quot;&gt;BFS로 풀다 틀린 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 13/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

int N, M;

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

int map[501][501];

int BFS(int startX, int startY){
    int result = 0;
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;

    Queue.push(make_pair(startX, startY));

//    vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; visits;

    while(!Queue.empty()){
        int currentX = Queue.front().first;
        int currentY = Queue.front().second;
        Queue.pop();

//        visits.push_back(make_pair(currentX, currentY));

        if(currentX == N &amp;amp;&amp;amp; currentY == M){
//            for(int i=0; i&amp;lt;visits.size(); i++){
//                cout &amp;lt;&amp;lt; map[visits[i].first][visits[i].second] &amp;lt;&amp;lt; ' ';
//            }
//            cout &amp;lt;&amp;lt; '\n';
//            visits.clear();
            result++;
        }

        for(int i=0; i&amp;lt;4; i++){
            int nextX = currentX + dx[i];
            int nextY = currentY + dy[i];

            if(nextX &amp;gt; 0 &amp;amp;&amp;amp; nextX &amp;lt;= N &amp;amp;&amp;amp; nextY &amp;gt; 0 &amp;amp;&amp;amp; nextY &amp;lt;= N){
                if(map[currentX][currentY] &amp;gt; map[nextX][nextY]){
                    Queue.push(make_pair(nextX, nextY));
                }
            }
        }
    }

    return result;
}

int main(){
    cin &amp;gt;&amp;gt; M &amp;gt;&amp;gt; N;

    for(int i=1; i&amp;lt;=M; i++) {
        for (int j = 1; j &amp;lt;= N; j++) {
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    cout &amp;lt;&amp;lt; BFS(1, 1) &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 13/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory.h&amp;gt;

using namespace std;

int N, M;

int map[501][501];
int DP[501][501];

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

int DFS(int startX, int startY){
    if(DP[startX][startY] != -1){
        return DP[startX][startY];
    }
    if(startX &amp;lt; 0 || startX &amp;gt;= N || startY &amp;lt; 0 || startY &amp;gt;= M){
        return 0;
    }
    if(startX == 0 &amp;amp;&amp;amp; startY == 0){
        return 1;
    }

    DP[startX][startY] = 0;

    for(int i=0; i&amp;lt;4; i++){
        int nextX = startX + dx[i];
        int nextY = startY + dy[i];

        if(map[nextX][nextY] &amp;gt; map[startX][startY]){
            DP[startX][startY] += DFS(nextX, nextY);
        }
    }

    return DP[startX][startY];
}

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;M; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }
    memset(DP, -1, sizeof(DP));

    cout &amp;lt;&amp;lt; DFS(N-1, M-1) &amp;lt;&amp;lt; '\n';

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;M; j++){
            cout &amp;lt;&amp;lt; DP[i][j] &amp;lt;&amp;lt; ' ';
        }
        cout &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><category term="DFS" /><category term="BFS" /><summary type="html">백준 1520번 Link: 1520번: 내리막 길</summary></entry></feed>