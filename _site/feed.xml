<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="keithlee94.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="keithlee94.github.io/" rel="alternate" type="text/html" /><updated>2019-03-12T19:46:05+09:00</updated><id>keithlee94.github.io/feed.xml</id><title type="html">KeithLog</title><subtitle>SSAFY 교육내용, 알고리즘 문제풀이 정리하여 업로드할 블로그</subtitle><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><entry><title type="html">17070</title><link href="keithlee94.github.io/algorithm/17070/" rel="alternate" type="text/html" title="17070" /><published>2019-03-12T00:00:00+09:00</published><updated>2019-03-12T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/17070</id><content type="html" xml:base="keithlee94.github.io/algorithm/17070/">&lt;h1 id=&quot;백준-17070번&quot;&gt;백준 17070번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/17070&quot;&gt;17070번: 파이프 옮기기 1&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;오늘도 BFS 문제다.&lt;/p&gt;

&lt;p&gt;전형적인 BFS와는 다른 방식으로 풀어야 하는 문제였다.&lt;/p&gt;

&lt;p&gt;보통 BFS의 경우 1 * 1짜리 한칸만 고려해줘도 풀리는 문제들이 대다수인데 이 문제같은 경우 파이프의 앞, 뒤를 함께 고려해야 한다는 점이 큰 차이점이었다.&lt;/p&gt;

&lt;p&gt;이외에도 회전하는 조건이 꽤 까다롭다는 점이 차이점이었으며 반복 방문을 막기 위해 BFS에서 보통 사용하는 visit 배열을 쓰지 않아야 풀리는 문제라는 점도 차이점이다.&lt;/p&gt;

&lt;p&gt;그리고 이 문제의 경우 BFS로 풀면 88%에서 시간초과가 난다.&lt;/p&gt;

&lt;p&gt;혹시나 해서 DFS로 바꿔서 풀어보니 바로 풀렸다.&lt;/p&gt;

&lt;p&gt;DFS는 재귀호출이기 때문에 함수 호출에 걸리는 시간도 있으니 BFS보다 더 오래 걸릴것이라고 생각했는데 잘못 생각했던것 같다.&lt;/p&gt;

&lt;p&gt;조건이 꽤 많은데 이 조건들을 하나하나 반영하며 DFS로 풀면 바로 풀리는 문제였다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Baekjoon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Main_17070&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frontX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frontY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frontX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frontY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frontX&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frontX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frontY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frontY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[][]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DFS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pipe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentFrontX&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frontX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentFrontY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frontY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentDirection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentFrontX&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentFrontY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextFrontX&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentFrontX&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextFrontY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentFrontY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextDirection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentDirection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextDirection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentDirection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextDirection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextFrontX&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextFrontY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextFrontX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextFrontY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentFrontX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentFrontY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextFrontX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextFrontY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentFrontX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentFrontY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;DFS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextFrontX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextFrontY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextDirection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextFrontX&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextFrontY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextFrontX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextFrontY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentFrontX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentFrontY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;DFS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextFrontX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextFrontY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextDirection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Pipe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;DFS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nf&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="BFS" /><category term="DFS" /><summary type="html">백준 17070번 Link: 17070번: 파이프 옮기기 1</summary></entry><entry><title type="html">16988</title><link href="keithlee94.github.io/algorithm/16988/" rel="alternate" type="text/html" title="16988" /><published>2019-03-06T00:00:00+09:00</published><updated>2019-03-06T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/16988</id><content type="html" xml:base="keithlee94.github.io/algorithm/16988/">&lt;h1 id=&quot;백준-16988번&quot;&gt;백준 16988번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/16988&quot;&gt;16988번: Baaaaaaaaaduk2 (Easy)&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;아주 오랫만에 BFS 문제.&lt;/p&gt;

&lt;p&gt;삼성 역량테스트 대비한 특강에서 내준 문제였는데, 보자마자 예전에 풀었던 연구소 문제가 생각났다.&lt;/p&gt;

&lt;p&gt;거기까지는 좋았다. 거기까지는.&lt;/p&gt;

&lt;p&gt;여기까지 떠올리고 DFS를 활용하여 2개의 돌을 놓는 위치를 정하는데까지는 성공했는데, 이제 죽일 수 있는 돌이 몇개인지 세는게 가장 큰 문제였다.&lt;/p&gt;

&lt;p&gt;이거 해결해보려고 정말 많은 고민을 해봤고 시도해봤는데 전부 허사였다.&lt;/p&gt;

&lt;p&gt;결국 답을 물어봐가면서 풀긴 했는데, 풀고 나니 내가 생각했던 방법이랑 크게 차이는 없는것 같지만 내가 생각지도 못한 부분들이 여럿 보였다.&lt;/p&gt;

&lt;p&gt;난 map에서 2로 표기된 점들에 대해 BFS를 통해 주변에 0이 없어 더 나갈 곳이 있는지 없는지만 파악하는 방법을 생각했는데, 더 나갈 수 없다는 걸 파악하는건 좋지만 가장 중요한 갯수 세는건 못한다.&lt;/p&gt;

&lt;p&gt;주변에 이 문제를 BFS로 푼 사람이 있어 물어봐가면서 풀었는데, 방법은 다음과 같다.&lt;/p&gt;

&lt;p&gt;1) DFS를 통해 2개의 착수점을 찾는다.&lt;/p&gt;

&lt;p&gt;2) 2개의 점을 찾았으면, 전역변수로 설정된 visit 배열을 초기화한다.&lt;/p&gt;

&lt;p&gt;3) map의 각 점들에 대해 값이 2이고 방문하지 않았다면 그 점을 방문했다고 표시하고, 그 점에 대해 BFS를 실행한다.&lt;/p&gt;

&lt;p&gt;4) 현재 찾은 착수점에 돌을 놓은 상태로 map을 갱신한다. (memcpy 함수 사용)&lt;/p&gt;

&lt;p&gt;5) BFS에 들어가면, 우선 현재 탐색하고 있는 점은 방문한 점이므로 count 값을 1 늘린다.&lt;/p&gt;

&lt;p&gt;6) for문을 순회하며 다음 BFS로 탐색할 점을 찾는다. 이때, 다음 지점이 방문하지 않은 지점이며 map의 다음 방문 지점 값이 2일 때에만 진행한다. 또, 현재 죽은 돌의 갯수를 세기 위해 count 값을 1 늘린다.&lt;/p&gt;

&lt;p&gt;7) 만약 다음 지점의 map 값이 0이라면 이는 돌들이 완벽하게 포위된 상태가 아님을 의미한다. 전역변수로 설정된 finish 값을 true로 바꿔준다.&lt;/p&gt;

&lt;p&gt;8) BFS를 완료한 후, finish 값이 true라면 탐색한 돌과 그 주변 돌들은 죽은 것이 아니므로, 0을 리턴한다. 반대의 경우 BFS를 통해 늘려준 count 값을 리턴한다.&lt;/p&gt;

&lt;p&gt;9) map 값이 2이며 방문하지 않은 모든 점들에 대해 탐색을 진행해야 하므로, 현재까지의 BFS 결과를 따로 누적한다. 나머지 점들에 대해서 반복한다.&lt;/p&gt;

&lt;p&gt;10) 모든 방문이 끝났다면 현재까지 누적된 BFS 결과와 이전 최대값을 비교해 최대값을 갱신한다.&lt;/p&gt;

&lt;p&gt;11) 이 과정을 모든 착수 가능한 경우에 대해 반복한다.&lt;/p&gt;

&lt;p&gt;이런 과정을 통해 최대값을 구하는 방법이다.&lt;/p&gt;

&lt;p&gt;BFS를 사용하는것까지는 떠올렸는데 디테일하게 BFS를 통해 합까지 구하는 방법을 생각하지 못한 점이 매우 아쉬웠다.&lt;/p&gt;

&lt;p&gt;또 처음에 돌릴때는 memcpy 대신 이중 for문 돌며 map값을 설정해줬는데 그러니 시간초과나더라.&lt;/p&gt;

&lt;p&gt;혹시나 해서 memcpy로 바꿔봤더니 바로 통과됐다.&lt;/p&gt;

&lt;p&gt;BFS에 대해서는 자신있다고 생각했는데 아직도 부족한점이 너무 많다.&lt;/p&gt;

&lt;p&gt;진짜로 마음잡고 다시 하루에 하나이상 풀어가며 실력 더 키워야겠다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 05/03/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;strings.h&amp;gt;
#include &amp;lt;memory.h&amp;gt;

using namespace std;

int N, M;

int map[20][20];
int tempMap[20][20];
bool visit[20][20];

int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

int maxValue = 0;
bool finish = false;

int BFS(int x, int y){
    int count = 0;

    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;

    memcpy(map, tempMap, sizeof(tempMap));

    Queue.push(make_pair(x, y));

    count++;

    while(!Queue.empty()){
        int currentX = Queue.front().first;
        int currentY = Queue.front().second;
        Queue.pop();

        for(int i=0; i&amp;lt;4; i++){
            int nextX = currentX + dx[i];
            int nextY = currentY + dy[i];

            if(nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt; N &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt; M){
                if(!visit[nextX][nextY] &amp;amp;&amp;amp; map[nextX][nextY] == 2){
                    visit[nextX][nextY] = true;
                    count++;
                    Queue.push(make_pair(nextX, nextY));
                }
                else if(map[nextX][nextY] == 0){
                    finish = true;
                }
            }
        }
    }

    if(finish){
        return 0;
    }

    return count;
}

void DFS(int count){
    if(count == 2){
        int temp = 0;
        bzero(visit, sizeof(visit));

        for(int i=0; i&amp;lt;N; i++){
            for(int j=0; j&amp;lt;M; j++){
                if(!visit[i][j] &amp;amp;&amp;amp; tempMap[i][j] == 2){
                    finish = false;
                    visit[i][j] = true;
                    temp += BFS(i, j);
                }
            }
        }

        maxValue = maxValue &amp;lt; temp ? temp : maxValue;

        return;
    }

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;M; j++){
            if(tempMap[i][j] == 0){
                tempMap[i][j] = 1;
                DFS(count+1);
                tempMap[i][j] = 0;
            }
        }
    }
}

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;M; j++){
            cin &amp;gt;&amp;gt; map[i][j];

            tempMap[i][j] = map[i][j];
        }
    }

    DFS(0);

    cout &amp;lt;&amp;lt; maxValue &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="BFS" /><category term="DFS" /><summary type="html">백준 16988번 Link: 16988번: Baaaaaaaaaduk2 (Easy)</summary></entry><entry><title type="html">2352</title><link href="keithlee94.github.io/algorithm/2352/" rel="alternate" type="text/html" title="2352" /><published>2019-03-02T00:00:00+09:00</published><updated>2019-03-02T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2352</id><content type="html" xml:base="keithlee94.github.io/algorithm/2352/">&lt;h1 id=&quot;백준-2352번&quot;&gt;백준 2352번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2352&quot;&gt;2352번: 반도체 설계&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;역시 DP문제.&lt;/p&gt;

&lt;p&gt;아주 오랫만에 자바로 문제를 풀었다.&lt;/p&gt;

&lt;p&gt;사실 C++로 풀긴 했는데, 누군가의 제보에 의하면 같은 알고리즘으로 풀었을때 C++로는 시간초과가 나고, 자바로는 제시간안에 풀린다는 말이 있어 자바로 바꿔서 풀었다.&lt;/p&gt;

&lt;p&gt;가장 긴 증가수열의 길이를 구하면 풀리는 문제다.&lt;/p&gt;

&lt;p&gt;내가 짠 알고리즘은 다음과 같다.&lt;/p&gt;

&lt;p&gt;1) DP 배열을 0으로 초기화한다.&lt;/p&gt;

&lt;p&gt;2) 입력을 받는다.&lt;/p&gt;

&lt;p&gt;3) i번째 인덱스에 입력받은 값이 들어간다고 가정할 때, 0부터 i-1까지의 j에 대해 port[j]가 port[i]보다 작을 때의 모든 DP값들 중 최대값을 찾는다.&lt;/p&gt;

&lt;p&gt;4) DP[i]는 3에서 구한 최대값 + 1 이다.&lt;/p&gt;

&lt;p&gt;5) DP 배열의 최대값이 구하고자 하는 답이다.&lt;/p&gt;

&lt;p&gt;위와 같은 알고리즘대로 풀어봤더니 자바로는 제시간에 풀렸다.&lt;/p&gt;

&lt;p&gt;예전에 배우기로는 여기다 이진검색까지 추가하면 더 빠르게 풀린다는 것을 배웠는데, 아직 제대로 이해하지 못해서 할수 있는 최선으로 이 알고리즘대로 풀었다.&lt;/p&gt;

&lt;p&gt;이진검색도 같이 사용해서 C++로도 풀어낼 수 있도록 공부해보고 다시한번 풀어봐야겠다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;시간-터지는-c-코드&quot;&gt;시간 터지는 C++ 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 02/03/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int N;
int DP[40001];
int port[40001];

int main(){
    cin &amp;gt;&amp;gt; N;

    port[0] = 0;
    DP[0] = 0;

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; port[i];

        int max = 0;

        for(int j=0; j&amp;lt;i; j++){
            if(port[j] &amp;lt; port[i] &amp;amp;&amp;amp; DP[j] &amp;gt; max){
                max = DP[j];
            }
        }

        DP[i] += max + 1;
    }

    int result = 0;
    for(int i=1; i&amp;lt;=N; i++){
        result = result &amp;lt; DP[i] ? DP[i] : result;
    }

    for(int i=0; i&amp;lt;=N; i++){
        cout &amp;lt;&amp;lt; DP[i] &amp;lt;&amp;lt; ' ';
    }
    cout &amp;lt;&amp;lt; '\n';

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;자바로는-돌아가는-정답-코드&quot;&gt;자바로는 돌아가는 정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Created&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Keith_Lee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;02&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;03&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2019.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Baekjoon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Main_2352&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;40001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;40001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++){&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;            &lt;span class=&quot;nf&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;        &lt;span class=&quot;nf&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;nf&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><category term="Greedy" /><category term="LIS" /><summary type="html">백준 2352번 Link: 2352번: 반도체 설계</summary></entry><entry><title type="html">11058</title><link href="keithlee94.github.io/algorithm/11058/" rel="alternate" type="text/html" title="11058" /><published>2019-02-28T00:00:00+09:00</published><updated>2019-02-28T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/11058</id><content type="html" xml:base="keithlee94.github.io/algorithm/11058/">&lt;h1 id=&quot;백준-11058번&quot;&gt;백준 11058번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/11058&quot;&gt;11058번: 크리보드&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;이번에도 DP 문제.&lt;/p&gt;

&lt;p&gt;예전에 풀었어야 했는데 그땐 DP에 대해 너무 자신이 없어서 쫄아서 패스했던 기억이 난다.&lt;/p&gt;

&lt;p&gt;이번에 DP를 제대로 공부하는 김에 풀어봤는데, 생각보다 금방 점화식을 찾아냈다.&lt;/p&gt;

&lt;p&gt;물론 여러번 시도해보긴 했지만, 생각했던 점화식이 맞았다.&lt;/p&gt;

&lt;p&gt;점화식에 대해 설명하자면 다음과 같다.&lt;/p&gt;

&lt;p&gt;현재의 DP 인덱스가 i라고 가정하자.&lt;/p&gt;

&lt;p&gt;우선 A만 누르는 경우는 직전 DP값에다 1을 더한 값이다.&lt;/p&gt;

&lt;p&gt;이는 곧 DP[i] = DP[i-1] + 1과 같다.&lt;/p&gt;

&lt;p&gt;이 다음부터가 꽤 복잡한데, 경우는 다음과 같다.&lt;/p&gt;

&lt;p&gt;1) 현재 기준 3번 전 DP에서 Ctrl + A를 눌러 그때 입력된 A들을 모두 선택하고, 2번 전 DP에서 Ctrl + C를 눌러 선택된 것을 복사한 다음 1번 전 DP에서 Ctrl + V를 눌러 복사된 내용을 붙여넣는 경우&lt;/p&gt;

&lt;p&gt;이는 곧 DP[i-3]에다가 DP[i-3]을 한번 더 쓰는 것과 같다.&lt;/p&gt;

&lt;p&gt;따라서 DP[i] = 2 * DP[i-3] 이다.&lt;/p&gt;

&lt;p&gt;2) 현재 기준 4번 전 DP에서 Ctrl + A를 눌러 그때 입력된 A들을 모두 선택하고, 3번 전 DP에서 Ctrl + C를 눌러 선택된 것을 복사한 다음 2번 전, 1번 전 DP에서 Ctrl + V를 눌러 복사된 내용을 붙여넣는 경우&lt;/p&gt;

&lt;p&gt;이는 곧 DP[i-4]를 3번 쓰는 것과 같으므로, DP[i] = 3 * DP[i-4] 이다.&lt;/p&gt;

&lt;p&gt;이 과정을 DP[0] * (i-1)까지 반복한다.&lt;/p&gt;

&lt;p&gt;이 모든 경우의 수들의 최대값이 현재 DP값이 된다.&lt;/p&gt;

&lt;p&gt;정답을 얻기 위해 예전 정답을 쌓아 나간다는 생각을 어거지로라도 하다 보니 점화식이 조금은 보이는 것 같다.&lt;/p&gt;

&lt;p&gt;이런식으로 DP를 정복할 수 있을것 같다는 자신감을 좀 갖게 해준 문제였다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 26/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int N;
long long DP[101];

long long max(vector&amp;lt;long long&amp;gt; v){
    long long result = -1;

    for(int i=0; i&amp;lt;v.size(); i++){
        if(v[i] &amp;gt; result){
            result = v[i];
        }
    }

    return result;
}

int main(){
    cin &amp;gt;&amp;gt; N;

    bzero(DP, sizeof(DP));

    DP[0] = 0;
    DP[1] = 1;
    DP[2] = 2;
    DP[3] = 3;
    DP[4] = 4;
    DP[5] = 5;
    DP[6] = 6;

    for(int i=7; i&amp;lt;=N; i++){
        vector&amp;lt;long long&amp;gt; temp;

        for(int j=3; j&amp;lt;=i; j++){
            temp.push_back(DP[i-j]*(j-1));
        }

        DP[i] = max(temp);
    }

    cout &amp;lt;&amp;lt; DP[N] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 11058번 Link: 11058번: 크리보드</summary></entry><entry><title type="html">11060</title><link href="keithlee94.github.io/algorithm/11060/" rel="alternate" type="text/html" title="11060" /><published>2019-02-26T00:00:00+09:00</published><updated>2019-02-26T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/11060</id><content type="html" xml:base="keithlee94.github.io/algorithm/11060/">&lt;h1 id=&quot;백준-11060번&quot;&gt;백준 11060번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/11060&quot;&gt;11060번: 점프 점프&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;역시 DP문제다.&lt;/p&gt;

&lt;p&gt;옆에서 친구가 풀던 문제여서 한번 풀어봤는데, 앞에서 풀었던 문제에서 찾아낸 규칙과 유사한 규칙으로 풀린다는 점을 알아냈다.&lt;/p&gt;

&lt;p&gt;될까 해서 돌려보니 역시 성공.&lt;/p&gt;

&lt;p&gt;이번에도 코드는 정말 짧다.&lt;/p&gt;

&lt;p&gt;하루에 DP를 2문제나 풀어내다니 내 자신이 살짝 놀랍다.&lt;/p&gt;

&lt;p&gt;이런식으로 DP에 대한 두려움을 좀 없앨 수 있으면 좋겠다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 26/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int N;

int map[1001];
int DP[1001];

int min(vector&amp;lt;int&amp;gt; v){
    int result = 99999;

    for(int i=0; i&amp;lt;v.size(); i++){
        if(result &amp;gt; v[i]){
            result = v[i];
        }
    }

    return result;
}

int main(){
    bzero(DP, sizeof(DP));
    bzero(map, sizeof(map));
    cin &amp;gt;&amp;gt; N;

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; map[i];
    }

    for(int i=2; i&amp;lt;=N; i++){
        vector&amp;lt;int&amp;gt; temp;

        for(int j=1; j&amp;lt;i; j++){
            if(j + map[j] &amp;gt;= i){
                temp.push_back(DP[j] + 1);
            }
        }

        DP[i] = min(temp);
    }

    if(DP[N] == 99999){
        DP[N] = -1;
    }

    cout &amp;lt;&amp;lt; DP[N] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 11060번 Link: 11060번: 점프 점프</summary></entry><entry><title type="html">1890</title><link href="keithlee94.github.io/algorithm/1890/" rel="alternate" type="text/html" title="1890" /><published>2019-02-26T00:00:00+09:00</published><updated>2019-02-26T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1890</id><content type="html" xml:base="keithlee94.github.io/algorithm/1890/">&lt;h1 id=&quot;백준-1890번&quot;&gt;백준 1890번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1890&quot;&gt;1890번: 점프&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;오늘도 DP문제.&lt;/p&gt;

&lt;p&gt;옆에서 친구가 풀던거 같이 한번 풀어봤는데, 조금 고전했다.&lt;/p&gt;

&lt;p&gt;처음에는 BFS로 풀어보려고 했는데 문제 자체가 BFS로 풀기에는 조건이 적당하지 않아서 무한루프로 끝났다.&lt;/p&gt;

&lt;p&gt;다른 방법으로 풀 수 있는지 찾아보던 중 어떻게든 규칙을 찾아서 DP로 풀어야겠다는 생각을 했고, 고민끝에 규칙을 찾아 샘플 케이스를 돌려보니 맞았다.&lt;/p&gt;

&lt;p&gt;구현하는데 인덱스가 헷갈려서 살짝 애먹긴 했지만 무난히 맞았다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 26/02/2019.
//

#include &amp;lt;iostream&amp;gt;

using namespace std;

int N;

int map[101][101] = {-1, };
long long DP[101][101] = {0, };

int main(){
    cin &amp;gt;&amp;gt; N;

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=N; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    DP[1][1] = 1;

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=N; j++){
            if(i == j &amp;amp;&amp;amp; i == 0){
                continue;
            }

            for(int k=0; k&amp;lt;j; k++){
                if(k + map[i][k] == j){
                    DP[i][j] += DP[i][k];
                }
            }

            for(int k=0; k&amp;lt;i; k++){
                if(k + map[k][j] == i){
                    DP[i][j] += DP[k][j];
                }
            }
        }
    }

//    for(int i=1; i&amp;lt;=N; i++){
//        for(int j=1; j&amp;lt;=N; j++){
//            cout &amp;lt;&amp;lt; DP[i][j] &amp;lt;&amp;lt; ' ';
//        }
//        cout &amp;lt;&amp;lt; '\n';
//    }

    cout &amp;lt;&amp;lt; DP[N][N] &amp;lt;&amp;lt; '\n';
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 1890번 Link: 1890번: 점프</summary></entry><entry><title type="html">1309</title><link href="keithlee94.github.io/algorithm/1309/" rel="alternate" type="text/html" title="1309" /><published>2019-02-25T00:00:00+09:00</published><updated>2019-02-25T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1309</id><content type="html" xml:base="keithlee94.github.io/algorithm/1309/">&lt;h1 id=&quot;백준-1309번&quot;&gt;백준 1309번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1309&quot;&gt;1309번: 동물원&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;오늘은 DP를 배워서 이제 한동안 DP문제에 매달릴 예정이다.&lt;/p&gt;

&lt;p&gt;그 중에서도 아주 간단한 문제를 하나 풀었다.&lt;/p&gt;

&lt;p&gt;정말 기본적인 문제라고 할 수 있는데, 몇개 케이스 따져보며 규칙 찾으면 바로 풀리는 문제다.&lt;/p&gt;

&lt;p&gt;역시 DP문제답게 규칙만 찾으면 구현은 간단히 끝난다.&lt;/p&gt;

&lt;p&gt;이번 기회에 DP에 대해 확실히 정복하고 갈 작정이다.&lt;/p&gt;

&lt;p&gt;여전히 갈길이 멀지만, 화이팅.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;///
// Created by Keith_Lee on 25/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int N;

long long zoo(int n){
    long long DP[n+1];
    bzero(DP, sizeof(DP));

    DP[0] = 0;
    DP[1] = 3;
    DP[2] = 7;

    for(int i=3; i&amp;lt;=n; i++){
        DP[i] = (2 * DP[i-1] + DP[i-2]) % 9901;
    }

    return DP[n];
}

int main(){
    cin &amp;gt;&amp;gt; N;

    cout &amp;lt;&amp;lt; zoo(N) &amp;lt;&amp;lt; '\n';
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 1309번 Link: 1309번: 동물원</summary></entry><entry><title type="html">2250</title><link href="keithlee94.github.io/algorithm/2250/" rel="alternate" type="text/html" title="2250" /><published>2019-02-22T00:00:00+09:00</published><updated>2019-02-22T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2250</id><content type="html" xml:base="keithlee94.github.io/algorithm/2250/">&lt;h1 id=&quot;백준-2250번&quot;&gt;백준 2250번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2250&quot;&gt;2250번: 트리의 높이와 너비&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;이번엔 DFS 문제다.&lt;/p&gt;

&lt;p&gt;문제 보고나서 트리 그리는 규칙 이해하는데만 한참 걸린것 같다.&lt;/p&gt;

&lt;p&gt;아무튼 이해하고 나서 트리를 직접 그려가면서 규칙을 찾아봤는데,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;우선 루트부터 찾은 다음 시작&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;루트 기준으로 왼쪽 방향으로 DFS시 만나는 가장 마지막 노드가 트리의 가장 왼쪽 노드&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;루트 기준으로 오른쪽 방향으로 DFS시 만나는 가장 마지막 노드가 트리의 가장 오른쪽 노드&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;루트 왼쪽 자식에서 오른쪽으로 DFS시 만나는 가장 마지막 노드가 루트 바로 왼쪽 노드&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;루트 오른쪽 자식에서 왼쪽으로 DFS시 만나는 가장 마지막 노드가 루트 바로 오른쪽 노드&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 5가지 규칙을 찾았다.&lt;/p&gt;

&lt;p&gt;이 규칙대로 트리를 만들고 문제를 풀어보려 했는데, 생각처럼 되지 않았다.&lt;/p&gt;

&lt;p&gt;이 5가지 말고 내가 놓치고 있는 부분이 무엇인지 계속 생각해봤는데, 한가지 큰 부분을 놓치고 있었다.&lt;/p&gt;

&lt;p&gt;이 트리를 그리는 규칙이 트리를 inorder 방식으로 탐색하는 순서와 같다는 점.&lt;/p&gt;

&lt;p&gt;이 규칙 찾는데 하루는 더 걸린것 같다.&lt;/p&gt;

&lt;p&gt;찾고 나니 푸는데 걸리는 시간은 순식간이었다.&lt;/p&gt;

&lt;p&gt;트리의 각 노드들의 레벨만 구하면 되니까.&lt;/p&gt;

&lt;p&gt;이 문제 알고리즘 분류가 DFS, 트리였는데 BFS를 넣어야 되지 않나 하는 생각도 들었다.&lt;/p&gt;

&lt;p&gt;레벨 찾는데 사용한 알고리즘이 BFS였기 때문.&lt;/p&gt;

&lt;p&gt;풀고 나니 나에게 실망스러웠는데, 그새 inorder, preorder, postorder 방식으로 트리 탐색하는 알고리즘을 까먹었다는 점 때문이다.&lt;/p&gt;

&lt;p&gt;평소에 잘 알고 있었다면 트리 그리는 규칙 보자마자 아 이거 루트 찾아서 inorder로 탐색하면 끝나는 문제구나 했을텐데…&lt;/p&gt;

&lt;p&gt;아무튼 늦게라도 떠올랐다는것 자체는 신기할 따름이다.&lt;/p&gt;

&lt;p&gt;아직 갈길이 멀다는 생각밖에 안든다…&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 21/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct Node{
    int num = -1;
    int left = 0;
    int right = 0;
    int parent = -1;
    int level = -1;
    int location = 0;
};

int N;
int lastLevel = 0; // 트리 최대 레벨
int place = 1;

Node nodeTree[10001]; // 입력따라 트리 저장할 공간
bool visit[10001] = {false, };

void inOrder(int start){
    if(!visit[nodeTree[start].left]){
        inOrder(nodeTree[start].left);
    }

    nodeTree[start].location = place++;
    visit[start] = true;

    if(!visit[nodeTree[start].right]){
        inOrder(nodeTree[start].right);
    }
}

void BFS(Node start){ // 각 노드들의 레벨을 찾는다.
    int level = 1;
    queue&amp;lt;Node&amp;gt; Queue;
    vector&amp;lt;Node&amp;gt; nodes;

    Queue.push(start);

    while(!Queue.empty()){
        nodes.clear();

        while(!Queue.empty()){
            Node temp = Queue.front();
            Queue.pop();
            nodes.push_back(temp);
        }

        for(int i=0; i&amp;lt;nodes.size(); i++){
            Node current = nodes[i];
            nodeTree[current.num].level = level;

            if(current.left != -1){
                Queue.push(nodeTree[current.left]);
            }
            if(current.right != -1){
                Queue.push(nodeTree[current.right]);
            }
        }

        level++;
    }
}

int main(){
    visit[0] = true;
    cin &amp;gt;&amp;gt; N;

    int nodeNum;
    int leftChild;
    int rightChild;

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; nodeNum &amp;gt;&amp;gt; leftChild &amp;gt;&amp;gt; rightChild;

        nodeTree[nodeNum].num = nodeNum;
        if(leftChild == -1){
            nodeTree[nodeNum].left = 0;
        }
        else{
            nodeTree[nodeNum].left = leftChild;
            nodeTree[leftChild].parent = nodeNum;
        }

        if(rightChild == -1){
            nodeTree[nodeNum].right = 0;
        }
        else{
            nodeTree[nodeNum].right = rightChild;
            nodeTree[rightChild].parent = nodeNum;
        }
    }

    int root = 0;

    for(int i=1; i&amp;lt;=N; i++){
        if(nodeTree[i].parent == -1){
            root = nodeTree[i].num;
            break;
        }
    }

    BFS(nodeTree[root]); // 각 노드의 레벨을 지정한다.

    inOrder(root);

    for(int i=1; i&amp;lt;=N; i++){
        if(lastLevel &amp;lt; nodeTree[i].level){
            lastLevel = nodeTree[i].level;
        }
    }

    int maxWidth = 0;
    int maxLevel = 0;

    vector&amp;lt;int&amp;gt; levels;
    for(int i=1; i&amp;lt;=lastLevel; i++){
        levels.clear();

        for(int j=1; j&amp;lt;=N; j++){
            if(nodeTree[j].level == i){
                levels.push_back(nodeTree[j].location);
            }
        }

        sort(levels.begin(), levels.end());

        int width = levels[levels.size()-1] - levels[0] + 1;

        if(maxWidth &amp;lt; width){
            maxLevel = i;
            maxWidth = width;
        }
    }

    cout &amp;lt;&amp;lt; maxLevel &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; maxWidth &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DFS" /><category term="Tree" /><category term="BFS" /><summary type="html">백준 2250번 Link: 2250번: 트리의 높이와 너비</summary></entry><entry><title type="html">1946</title><link href="keithlee94.github.io/algorithm/1946/" rel="alternate" type="text/html" title="1946" /><published>2019-02-19T00:00:00+09:00</published><updated>2019-02-19T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1946</id><content type="html" xml:base="keithlee94.github.io/algorithm/1946/">&lt;h1 id=&quot;백준-1946번&quot;&gt;백준 1946번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1946&quot;&gt;1946번: 신입 사원&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;오늘도 Greedy문제.&lt;/p&gt;

&lt;p&gt;문제 이해하는데 시간이 좀 오래걸렸다.&lt;/p&gt;

&lt;p&gt;이해하고 나서 풀어보려는데 처음에는 두 등수의 평균을 구한 다음 평균이 높은 절반끼리 비교하는 방식으로 구현했는데, 일단 시간초과가 났다.&lt;/p&gt;

&lt;p&gt;방문 여부를 표시하고 조건에 안맞으면 반복문 중간에서 나가는 방식으로 보완했는데, 이렇게 푸니까 이젠 답이 틀리더라.&lt;/p&gt;

&lt;p&gt;그 다음엔 각각의 등수가 1인 경우들은 반드시 포함시키고, 이 둘에 대해 비교하며 카운트를 늘려가는 방식으로 풀어봤는데, 역시 틀렸다.&lt;/p&gt;

&lt;p&gt;한참 고민하며 반례 찾으러 질문게시판에 들어가봤는데, 반례 찾다가 다른사람의 아이디어를 보고 힌트를 얻어 풀 수 있었다.&lt;/p&gt;

&lt;p&gt;핵심은 한가지 등수로 오름차순 정렬을 하는 것.&lt;/p&gt;

&lt;p&gt;이렇게 하면 두가지 등수 중 한가지 등수만 비교하면 풀린다.&lt;/p&gt;

&lt;p&gt;나머지 한 등수에 대해 정답에 포함시킨 바로 앞 등수보다 크면 포함시키지 않고, 반대의 경우 작은 등수로 바꿔주고 카운트를 하나 늘린 후 이를 반복하는 방식으로 풀 수 있었다.&lt;/p&gt;

&lt;p&gt;아이디어를 짜내보려고 노력한 것까지는 좋았던 것 같으나 핵심을 찾는데에는 도달하지 못했다.&lt;/p&gt;

&lt;p&gt;심지어 한가지 등수로 오름차순 정렬하는것까지는 했는데 그 다음을 생각해내지 못했다는 점이 아쉬웠다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 19/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct candidates{
    int doc, interview;
};

bool compare(candidates &amp;amp;a, candidates &amp;amp;b){
    if(a.doc &amp;gt; b.doc){
        return false;
    }
    return true;
}

int main(){
    int T;

    cin &amp;gt;&amp;gt; T;

    for(int test=0; test&amp;lt;T; test++){
        int N;

        cin &amp;gt;&amp;gt; N;

        vector&amp;lt;candidates&amp;gt; applicants;

        for(int i=0; i&amp;lt;N; i++){
            int doc, interview;

            cin &amp;gt;&amp;gt; doc &amp;gt;&amp;gt; interview;

            applicants.push_back({doc, interview});
        }

        sort(applicants.begin(), applicants.end(), compare);

        int count = 1;

        int standard = applicants[0].interview;

        for(int i=1; i&amp;lt;applicants.size(); i++){
            if(standard &amp;gt; applicants[i].interview){
                standard = applicants[i].interview;
                count++;
            }
        }

        cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Greedy" /><summary type="html">백준 1946번 Link: 1946번: 신입 사원</summary></entry><entry><title type="html">1931</title><link href="keithlee94.github.io/algorithm/1931/" rel="alternate" type="text/html" title="1931" /><published>2019-02-18T00:00:00+09:00</published><updated>2019-02-18T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1931</id><content type="html" xml:base="keithlee94.github.io/algorithm/1931/">&lt;h1 id=&quot;백준-1931번&quot;&gt;백준 1931번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1931&quot;&gt;1931번: 회의실배정&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;Greedy 알고리즘의 대표격인 문제다.&lt;/p&gt;

&lt;p&gt;예전에 한번 풀어봤던것 같긴 한데 그때도 틀렸다.&lt;/p&gt;

&lt;p&gt;마음 다잡고 다시한번 풀어봤는데, 답이 맞는것 같으면서도 계속 틀렸다고 나오더라.&lt;/p&gt;

&lt;p&gt;어떤 부분에서 문제가 있나 해서 질문게시판 돌아다니면서 반례들을 찾아봤는데, 크게 2가지 문제가 있었다.&lt;/p&gt;

&lt;p&gt;첫번째는 끝나는 시간이 같은 경우 시작하는 시간이 빠른 회의가 먼저 오도록 정렬되어야 한다는 점.&lt;/p&gt;

&lt;p&gt;두번째는 배정 가능한 회의에 포함시킬때 그 회의를 포함하였음을 표시하여 중복으로 포함시켜선 안된다는 점.&lt;/p&gt;

&lt;p&gt;첫번째 문제는 정렬 함수를 좀 바꿔서 해결했다.&lt;/p&gt;

&lt;p&gt;두번째 문제는 방문 여부를 어떻게 표시할지 고민하다 1부터 2147483647까지의 bool형태의 배열을 만들까 해봤다.&lt;/p&gt;

&lt;p&gt;용량이 용량이라 그런지 컴파일 자체가 안되더라.&lt;/p&gt;

&lt;p&gt;어떻게할지 고민하다가 구조체에 방문 여부도 포함하도록 바꿔서 제출해보니 바로 맞았다.&lt;/p&gt;

&lt;p&gt;Greedy나 BFS나 DFS나 방문여부 표시해주는게 참 중요한 것 같다.&lt;/p&gt;

&lt;p&gt;몇년전부터 못풀던 문제였는데 오늘에서라도 풀어서 기분은 좋다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 18/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

struct meeting{
    int start, end;
    bool visit;
};

int N;

bool compare(meeting a, meeting b){
    if(a.end &amp;lt; b.end){
        return true;
    }
    else if(a.end == b.end){
        if(a.start &amp;lt; b.start){
            return true;
        }
    }
    return false;
}

int main(){
    cin &amp;gt;&amp;gt; N;

    vector&amp;lt;meeting&amp;gt; meetings;

    int start, end;

    for(int i=0; i&amp;lt;N; i++){
        cin &amp;gt;&amp;gt; start &amp;gt;&amp;gt; end;

        meetings.push_back({start, end, false});
    }

    sort(meetings.begin(), meetings.end(), compare);

    vector&amp;lt;meeting&amp;gt; available;
    available.push_back(meetings[0]);
    meetings[0].visit = true;

    for(int i=0; i&amp;lt;meetings.size(); i++){
        int currentEnd = available[available.size()-1].end;

        if(meetings[i].start &amp;gt;= currentEnd &amp;amp;&amp;amp; !meetings[i].visit){
            available.push_back(meetings[i]);
        }
    }

    cout &amp;lt;&amp;lt; available.size() &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Greedy" /><summary type="html">백준 1931번 Link: 1931번: 회의실배정</summary></entry></feed>