<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-01-04T21:45:04+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">KeithLog</title><subtitle>SSAFY 교육내용, 알고리즘 문제풀이 정리하여 업로드할 블로그</subtitle><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><entry><title type="html">4th week summary</title><link href="http://localhost:4000/java/4th-Week-Summary/" rel="alternate" type="text/html" title="4th week summary" /><published>2019-01-04T00:00:00+09:00</published><updated>2019-01-04T00:00:00+09:00</updated><id>http://localhost:4000/java/4th%20Week%20Summary</id><content type="html" xml:base="http://localhost:4000/java/4th-Week-Summary/">&lt;h1 id=&quot;java-스터디-내용-정리&quot;&gt;Java 스터디 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;project-package-분리-이유&quot;&gt;Project, Package 분리 이유&lt;/h1&gt;
&lt;p&gt;프로젝트의 각 기능을 쪼개기 위해 패키지 사용.&lt;/p&gt;

&lt;p&gt;논리적으로 따로 나눠 작업하기 위해 분리하는 경우가 대다수이다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java의-특징&quot;&gt;Java의 특징&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;객체지향
    &lt;ul&gt;
      &lt;li&gt;시스템의 기본 구성단위는 &lt;strong&gt;객체(Object)&lt;/strong&gt; 이다.&lt;/li&gt;
      &lt;li&gt;객체: 일종의 부품 역할.&lt;/li&gt;
      &lt;li&gt;여러 부품들을 모아 조립하듯이 프로그램을 완성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;플랫폼 독립적
    &lt;ul&gt;
      &lt;li&gt;하드웨어, OS와 상관없이 모든 환경에서 동작 가능.&lt;/li&gt;
      &lt;li&gt;이유: JVM 위에서 작동하므로.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;분산 프로그래밍: 원격 접속 가능.&lt;/li&gt;
  &lt;li&gt;멀티스레드&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java-컴파일-과정&quot;&gt;Java 컴파일 과정&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;소스코드 작성: (…).java 파일 생성.&lt;/li&gt;
  &lt;li&gt;컴파일
    &lt;ul&gt;
      &lt;li&gt;명령어: javac (…).java
        &lt;ul&gt;
          &lt;li&gt;javac -d …: 패키지가 있을 경우 자동으로 패키지 폴더를 생성하며 컴파일.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;JVM이 인식 가능한 byte code로 번역하는 과정.&lt;/li&gt;
      &lt;li&gt;결과: Bytecode 생성 - (…).class 파일 생성.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실행
    &lt;ul&gt;
      &lt;li&gt;명령어: java (…)&lt;/li&gt;
      &lt;li&gt;JVM 위에서 실행됨.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/23356503/50677469-654b6480-103d-11e9-9b3c-e330a67fba48.jpeg&quot; alt=&quot;java compile&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C의 경우 실행파일을 다른 환경에서 실행시키면 실행 안됨.&lt;/p&gt;

&lt;p&gt;Java의 경우 JVM이 존재하므로 다른 환경에서 실행 가능함.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;primitive-data-type&quot;&gt;Primitive Data Type&lt;/h1&gt;
&lt;p&gt;기본적인 값을 기억하는 type.&lt;/p&gt;

&lt;p&gt;1 byte = 8 bit&lt;/p&gt;

&lt;p&gt;char = 16 bit = 2 byte&lt;/p&gt;

&lt;p&gt;int = 32 bit = 4 byte&lt;/p&gt;

&lt;p&gt;float = 32 bit = 4 byte&lt;/p&gt;

&lt;p&gt;double = 64 bit = 8 byte&lt;/p&gt;

&lt;p&gt;long = 64 bit = 8 byte&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;reference-data-type&quot;&gt;Reference Data Type&lt;/h1&gt;
&lt;p&gt;객체의 참조값을 기억하는 type.&lt;/p&gt;

&lt;p&gt;class, interface, 배열 등.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;String: class이므로 Reference Type이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;literal&quot;&gt;Literal&lt;/h1&gt;
&lt;p&gt;값 자체.&lt;/p&gt;

&lt;p&gt;예: 3.14, 10, ‘C’, false, …&lt;/p&gt;

&lt;p&gt;정수 리터럴 = 4바이트에 저장됨.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;논리연산자&quot;&gt;논리연산자&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&amp;amp;&amp;amp; 연산자: 앞조건이 false면 뒤에 오는 조건 확인하지 않고 연산 종료.&lt;/li&gt;
  &lt;li&gt;&amp;amp; 연산자: 앞조건이 false여도 뒤에 오는 조건을 확인한 후 연산 종료.&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;,&lt;/td&gt;
          &lt;td&gt;연산자도 동일함.&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;3항연산자&quot;&gt;3항연산자&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(x &amp;gt; y) ? x : y =&amp;gt; 실행결과: x가 y보다 크면 x, 작거나 같으면 y가 된다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;for--each&quot;&gt;for ~ each&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int sum = 0;
int[] su = {24, 6, 5, 36, 36, 65, 245, 56, 3, 64};

for(int s: su){
    System.out.println(s);
    sum += s;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;실행결과: sum에는 su 배열의 모든 숫자를 더한 값이 저장되고, su 배열의 모든 원소가 한번씩 출력된다.&lt;/p&gt;

&lt;p&gt;=&amp;gt; 배열 내 모든 원소에 한번씩 접근한다.(파이썬과 유사함)&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;error-exception&quot;&gt;Error, Exception&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Error
    &lt;ul&gt;
      &lt;li&gt;복구 불가능&lt;/li&gt;
      &lt;li&gt;프로그램이 비정상적으로 종료됨.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Exception
    &lt;ul&gt;
      &lt;li&gt;일종의 가벼운 에러&lt;/li&gt;
      &lt;li&gt;프로그램상으로 수정 가능함.&lt;/li&gt;
      &lt;li&gt;Java가 해결 방법을 알려줄 수 있음.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;배열-기본값&quot;&gt;배열 기본값&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;배열의 type에 따라 다르게 배열 생성시 기본값으로 자동으로 채워진다.&lt;/li&gt;
  &lt;li&gt;int형: 0&lt;/li&gt;
  &lt;li&gt;boolean형: false&lt;/li&gt;
  &lt;li&gt;double형: 0.0&lt;/li&gt;
  &lt;li&gt;String형: null
    &lt;ul&gt;
      &lt;li&gt;참조형 type의 배열의 기본값은 항상 null이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;main메소드의-args-사용법&quot;&gt;main메소드의 args 사용법&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;Run Configuration 설정&lt;/li&gt;
  &lt;li&gt;Arguments -&amp;gt; Program arguments -&amp;gt; ${string-prompt} 설정.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;new-키워드&quot;&gt;new 키워드&lt;/h1&gt;
&lt;p&gt;객체를 만들때 사용하는 키워드.&lt;/p&gt;

&lt;h1 id=&quot;method&quot;&gt;method&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;C의 함수와 같다.&lt;/li&gt;
  &lt;li&gt;클래스 내에서 객체가 가져야 할 기능을 정의.&lt;/li&gt;
  &lt;li&gt;독립적인 기능들을 분리하여 재사용 가능하도록 하기 위해 사용.&lt;/li&gt;
  &lt;li&gt;return type, method 이름, parameter list가 반드시 있어야 한다.&lt;/li&gt;
  &lt;li&gt;method 내에 method 정의 불가능.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;arraycopy&quot;&gt;arraycopy()&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;배열 복사 함수.&lt;/li&gt;
  &lt;li&gt;System.arraycopy(소스배열, 소스배열의 시작위치, 목적배열, 목적배열의 시작위치, 길이);&lt;/li&gt;
  &lt;li&gt;작은 배열일 경우 통상적인 반복문이 더 효율적.&lt;/li&gt;
  &lt;li&gt;배열이 클때 사용시 효율적이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;다차원-배열-길이&quot;&gt;다차원 배열 길이&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;su = new int[5][3];
su2 = new int[3];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;su.length: 5&lt;/p&gt;

&lt;p&gt;su[0].length: 3&lt;/p&gt;

&lt;p&gt;su2.length: 3&lt;/p&gt;

&lt;p&gt;=&amp;gt; 가장 첫번째 칸의 숫자가 배열의 길이.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;return&quot;&gt;return&lt;/h1&gt;
&lt;p&gt;문장의 실행을 그자리에서 멈춘다.&lt;/p&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Java" /><summary type="html">Java 스터디 내용 정리</summary></entry><entry><title type="html">1932</title><link href="http://localhost:4000/algorithm/1932/" rel="alternate" type="text/html" title="1932" /><published>2019-01-03T00:00:00+09:00</published><updated>2019-01-03T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/1932</id><content type="html" xml:base="http://localhost:4000/algorithm/1932/">&lt;h1 id=&quot;백준-1149번&quot;&gt;백준 1149번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1932&quot;&gt;1932번: 정수 삼각형&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;어제 풀었던 RGB거리와 비슷한 유형의 DP 문제.&lt;/p&gt;

&lt;p&gt;다른점이 있다면 제한조건인데, 3가지 경우를 고려했어야 했던 RGB 거리와 달리 삼각형을 이루는 정수들의 왼쪽 대각선, 오른쪽 대각선의 2가지 경우로만 이동 가능하므로 오히려 조건은 완화되었다.&lt;/p&gt;

&lt;p&gt;딱 문제 보고나서 ‘어 이거 어제 풀었던거랑 비슷한데’ 라는 생각으로 시작했다.&lt;/p&gt;

&lt;p&gt;결론부터 말하면 못풀어서 답보고 이해했는데, 접근방법이 아예 잘못되었다.&lt;/p&gt;

&lt;p&gt;조건에서 주어졌듯이 2개의 이전 결과값을 비교하고 현재 삼각형 위치의 숫자를 더하면 되는거였는데, 일단 이 조건을 무시하고 최대값만 다 찾았다가 1차로 망했다.&lt;/p&gt;

&lt;p&gt;잘못생각했다는걸 알아차리고 다른 방법을 생각해봤는데, 이것도 틀렸다.&lt;/p&gt;

&lt;p&gt;뭔지 대충 설명하자면 최대값을 가질때의 배열 인덱스를 따로 받아두고 이 인덱스를 기준으로 다음 최대값을 찾는 방식.&lt;/p&gt;

&lt;p&gt;DP에 대해 완벽히 이해하고 있는건 아닌것 같다.&lt;/p&gt;

&lt;p&gt;예전 계산 결과 가져다 쓰는 문제구나 하는 느낌은 오는데, 예전 계산 결과를 어떤식으로 저장할 것이며 어떻게 가져다 쓸것인지에 대해 생각해내는 부분이 부족한 것 같다.&lt;/p&gt;

&lt;p&gt;문제 보고도 뭔소린가 싶었던 옛날에 비해서는 많이 나아진 편이지만 아직도 갈길이 멀다…&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 03/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;

int n;
int maximum = 0;

int max(int a, int b){
    return (a &amp;gt; b) ? a : b;
}

int main(){
    cin &amp;gt;&amp;gt; n;

    int DP[n+1][n+1];
    int tree[n+1][n+1];

    bzero(DP, sizeof(DP));
    bzero(tree, sizeof(tree));

    int inputNum;

    for(int i=1; i&amp;lt;=n; i++){
        for(int j=1; j&amp;lt;=i; j++){
            cin &amp;gt;&amp;gt; inputNum;
            tree[i][j] = inputNum;
        }
    }

    for(int i=1; i&amp;lt;=n; i++){
        for(int j=1; j&amp;lt;=i; j++){
            DP[i][j] = max(DP[i-1][j-1], DP[i-1][j]) + tree[i][j];

            if(maximum &amp;lt; DP[i][j]){
                maximum = DP[i][j];
            }
        }
    }

    cout &amp;lt;&amp;lt; maximum &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 1149번 Link: 1932번: 정수 삼각형</summary></entry><entry><title type="html">1149</title><link href="http://localhost:4000/algorithm/1149/" rel="alternate" type="text/html" title="1149" /><published>2019-01-02T00:00:00+09:00</published><updated>2019-01-02T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/1149</id><content type="html" xml:base="http://localhost:4000/algorithm/1149/">&lt;h1 id=&quot;백준-1149번&quot;&gt;백준 1149번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1149&quot;&gt;1149번: RGB 거리&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;마을의 집 갯수와 각 집을 빨강, 초록, 파랑으로 각각 칠하는데 드는 비용이 입력으로 주어졌을때 마을의 모든 집을 칠하는 최저 비용을 구하는 문제.&lt;/p&gt;

&lt;p&gt;이웃하는 집들은 같은 색으로 칠할 수 없다는 조건도 붙었다.&lt;/p&gt;

&lt;p&gt;작년에 답보고 풀었던 기억이 나는 문제. 이번에는 꼭 내 힘으로 풀어내리라 결심하고 풀어보았다.&lt;/p&gt;

&lt;p&gt;우선 이웃하는 집들이 같은 색이 될수 없다는 조건을 단순화하여 앞집이랑만 다른 색이면 되지 않나? 라는 생각으로 풀었다.&lt;/p&gt;

&lt;p&gt;틀리고 한참 고민하고서야 왜 틀렸는지 알게 되었다. 반드시 최저값만으로 구성된 조합이 존재하지 않는 경우가 있다는 것.&lt;/p&gt;

&lt;p&gt;거꾸로도 풀어보고 어떻게든 풀어보려 애써봤는데 결국 안풀려서 예전 답을 보고 풀었다…&lt;/p&gt;

&lt;p&gt;생각보다 매우 단순했는데, 처음 칠하는 비용을 0으로 초기화한 다음 모든 경우를 따져가며 답을 구하는 방식이었다.&lt;/p&gt;

&lt;p&gt;예를 들면 DP[i][0]은 DP[i-1][1]과 DP[i-1][2] 중 작은 값에다가 칠하는 비용인 price[i][0]을 더하는 식.&lt;/p&gt;

&lt;p&gt;즉 DP[i][0]은 i번째 집을 0번째 색으로 칠한다는 것을 의미한다. 당연히 앞집이랑은 색이 겹칠 일이 없다.&lt;/p&gt;

&lt;p&gt;온갖 방법 다 생각해보다 답을 봤는데 정말 간단하게 풀려서 허무했다;;;&lt;/p&gt;

&lt;p&gt;2시간정도 고민해봤지만 못풀겠어서 결국 포기했던 점이 아쉽지만, 이러저러한 방법을 최대한 시도해 본 점은 나름 만족스럽다.&lt;/p&gt;

&lt;p&gt;다음에 푸는 문제들은 이런 고민끝에 끝까지 풀어낼 수 있길!!&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;내가-짰다가-틀린-코드&quot;&gt;내가 짰다가 틀린 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 02/01/2019.
//

#include &amp;lt;iostream&amp;gt;

using namespace std;

int N;

int main(){
    cin &amp;gt;&amp;gt; N;

    int price[N][3];
    int DP[N][2];

    for(int i=0; i&amp;lt;N; i++){
        cin &amp;gt;&amp;gt; price[i][0] &amp;gt;&amp;gt; price[i][1] &amp;gt;&amp;gt; price[i][2];
    }

    for(int i=0; i&amp;lt;N; i++){
        int min = 1001;

        if(i == 0){
            for(int j=0; j&amp;lt;3; j++){
                if(min &amp;gt; price[0][j]){
                    min = price[0][j];
                    DP[0][0] = min;
                    DP[0][1] = j;
                }
            }
        }
        else{
            for(int j=0; j&amp;lt;3; j++){
                if(j != DP[i-1][1]){
                    if(min + price[i][j] &amp;gt; DP[i-1][0] + price[i][j]){
                        min = price[i][j];
                        DP[i][0] = min + DP[i-1][0];
                        DP[i][1] = j;
                    }
                }
            }
        }
    }

    cout &amp;lt;&amp;lt; DP[N-1][0] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 02/01/2019.
//

#include &amp;lt;iostream&amp;gt;

using namespace std;

int N;

int min(int a, int b){
    return (a &amp;gt; b) ? b : a;
}

int main(){
    cin &amp;gt;&amp;gt; N;

    int price[N+1][3];
    int DP[N+1][3];

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; price[i][0] &amp;gt;&amp;gt; price[i][1] &amp;gt;&amp;gt; price[i][2];
    }

    price[0][0] = price[0][1] = price[0][2] = 0;
    DP[0][0] = DP[0][1] = DP[0][2] = 0;

    for(int i=1; i&amp;lt;N+1; i++){
        DP[i][0] = min(DP[i-1][1], DP[i-1][2]) + price[i][0];
        DP[i][1] = min(DP[i-1][0], DP[i-1][2]) + price[i][1];
        DP[i][2] = min(DP[i-1][0], DP[i-1][1]) + price[i][2];
    }

    cout &amp;lt;&amp;lt; min(min(DP[N][0], DP[N][1]), DP[N][2]) &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 1149번 Link: 1149번: RGB 거리</summary></entry><entry><title type="html">1003</title><link href="http://localhost:4000/algorithm/1003/" rel="alternate" type="text/html" title="1003" /><published>2019-01-01T00:00:00+09:00</published><updated>2019-01-01T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/1003</id><content type="html" xml:base="http://localhost:4000/algorithm/1003/">&lt;h1 id=&quot;백준-2108번&quot;&gt;백준 2108번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1003&quot;&gt;1003번: 피보나치 함수&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;피보나치 함수 실행시 0과 1이 몇번이나 출력되는지 구하는 문제.&lt;/p&gt;

&lt;p&gt;예전에 풀어본 적 있던 문제였는데 DP를 다시 공부하는 김에 새로 풀어보았다.&lt;/p&gt;

&lt;p&gt;다른점이 있다면 예전에는 답을 찾아보고 풀었던것 같은데 이번에는 내 힘만으로 풀었다는 점.&lt;/p&gt;

&lt;p&gt;DP를 사용해야 한다는 느낌은 왔는데 어떻게 DP 배열을 채울지가 관건이었다.&lt;/p&gt;

&lt;p&gt;시간제한이 0.25초였지만 입력의 크기가 최대 40까지인 것을 보고, 처음부터 DP 배열을 전부 채워놓고 입력에 따라 배열의 값만 리턴해줘도 되겠다는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;이렇게 생각하고 풀어봤더니 금방 풀렸다.&lt;/p&gt;

&lt;p&gt;이번주는 DP를 집중적으로 풀어볼 예정.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;내가-짠-코드&quot;&gt;내가 짠 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 01/01/2019.
//
#include &amp;lt;iostream&amp;gt;

using namespace std;

int T;
int DP[41][2];

void fibonacci(int n){
    if(n == 0){
        DP[n][0]++;
    }
    else if(n == 1){
        DP[n][1]++;
    }
    else{
        DP[n][0] = DP[n-1][0] + DP[n-2][0];
        DP[n][1] = DP[n-1][1] + DP[n-2][1];
    }
}

int main(){
    for(int i=0; i&amp;lt;41; i++){
        fibonacci(i);
    }

    cin &amp;gt;&amp;gt; T;

    int N;

    for(int i=0; i&amp;lt;T; i++){
        cin &amp;gt;&amp;gt; N;
        cout &amp;lt;&amp;lt; DP[N][0] &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; DP[N][1] &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 2108번 Link: 1003번: 피보나치 함수</summary></entry><entry><title type="html">2108</title><link href="http://localhost:4000/algorithm/2108/" rel="alternate" type="text/html" title="2108" /><published>2018-12-31T00:00:00+09:00</published><updated>2018-12-31T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2108</id><content type="html" xml:base="http://localhost:4000/algorithm/2108/">&lt;h1 id=&quot;백준-2108번&quot;&gt;백준 2108번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2108&quot;&gt;2108번: 통계학&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;문제에서 제시된 간단한 통계를 구하는 문제였다.&lt;/p&gt;

&lt;p&gt;평균, 최댓값, 범위까지는 쉽게쉽게 구했는데 최빈값을 어떻게 구할지에 대해서 많이 고민했던 문제.&lt;/p&gt;

&lt;p&gt;처음에는 8000개짜리 배열 만들고 숫자 넣을때마다 배열 값에다 1씩 더해서 빈도를 저장하려고 했는데 하다보니 아니다 싶어서 map을 사용했다.&lt;/p&gt;

&lt;p&gt;input으로 준 숫자가 map에 없으면 (input, 1)로 초기호하고 있으면 빈도에 해당하는 1을 하나씩 더해가는 방식으로 구현했다.&lt;/p&gt;

&lt;p&gt;최빈값을 찾기 위해 map을 한번 싹 돌았다.&lt;/p&gt;

&lt;p&gt;조건 중에 최빈값이 여러개면 두번째로 작은 값을 최빈값으로 하라는 조건이 있었는데, 이걸 구현하기 위해 map을 한번 더 돌았다. 이 부분에 대해서는 좀 더 세련된 방법으로 보완할 수 있을 것 같은데 일단은 시간제한도 넉넉해서 그냥 한바퀴 더 도는 방법으로 구현했다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;내가-짠-코드&quot;&gt;내가 짠 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 31/12/2018.
//
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;map&amp;gt;

using namespace std;

int N;

int halfProcess(double num){
    double high = ceil(num);
    double low = floor(num);

    if(num &amp;gt;= (high + low) / 2){
        return int(high);
    }

    return int(low);
}

int main(){
    cin &amp;gt;&amp;gt; N;

    vector&amp;lt;int&amp;gt; numbers;
    int sum = 0;
    map&amp;lt;int, int&amp;gt; frequencies;

    int inputNum;

    for(int i=0; i&amp;lt;N; i++){
        cin &amp;gt;&amp;gt; inputNum;
        sum += inputNum;
        numbers.push_back(inputNum);
        if(frequencies.find(inputNum) == frequencies.end()){
            frequencies.insert(make_pair(inputNum, 1));
        }
        else{
            frequencies.find(inputNum)-&amp;gt;second++;
        }
    }

    int temp = 0;
    int mostFrequent;
    int changeCount = 0;
    for(auto iter = frequencies.begin(); iter != frequencies.end(); iter++){
        if(iter-&amp;gt;second &amp;gt; temp){
            temp = iter-&amp;gt;second;
            mostFrequent = iter-&amp;gt;first;
            changeCount++;
        }
    }
    for(auto iter = frequencies.begin(); iter != frequencies.end(); iter++){
        if(iter-&amp;gt;second == temp &amp;amp;&amp;amp; iter-&amp;gt;first != mostFrequent){
            mostFrequent = iter-&amp;gt;first;
            break;
        }
    }

    sort(numbers.begin(), numbers.end());

    int average = halfProcess(double(sum) / double(N));
    int center = numbers[N/2];
    int range = numbers[N-1] - numbers[0];

    cout &amp;lt;&amp;lt; average &amp;lt;&amp;lt; '\n' &amp;lt;&amp;lt; center &amp;lt;&amp;lt; '\n' &amp;lt;&amp;lt; mostFrequent &amp;lt;&amp;lt; '\n' &amp;lt;&amp;lt; range &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Realization" /><summary type="html">백준 2108번 Link: 2108번: 통계학</summary></entry><entry><title type="html">3rd week summary</title><link href="http://localhost:4000/cse/3rd-Week-Summary/" rel="alternate" type="text/html" title="3rd week summary" /><published>2018-12-29T00:00:00+09:00</published><updated>2018-12-29T00:00:00+09:00</updated><id>http://localhost:4000/cse/3rd%20Week%20Summary</id><content type="html" xml:base="http://localhost:4000/cse/3rd-Week-Summary/">&lt;h1 id=&quot;markdown-문법-정리&quot;&gt;Markdown 문법 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;1--제목-쓸때-사용&quot;&gt;1. #: 제목 쓸때 사용.&lt;/h1&gt;
&lt;h1 id=&quot;this-is-h1&quot;&gt;This is h1&lt;/h1&gt;
&lt;h2 id=&quot;this-is-h2&quot;&gt;This is h2&lt;/h2&gt;
&lt;h3 id=&quot;this-is-h3&quot;&gt;This is h3&lt;/h3&gt;
&lt;h4 id=&quot;this-is-h4&quot;&gt;This is h4&lt;/h4&gt;
&lt;h5 id=&quot;this-is-h5&quot;&gt;This is h5&lt;/h5&gt;
&lt;h6 id=&quot;this-is-h6&quot;&gt;This is h6&lt;/h6&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;2--hr-줄바꿀때-쓴다&quot;&gt;2. «!– –&amp;gt;hr/&amp;gt;: 줄바꿀때 쓴다.&lt;/h1&gt;
&lt;h3 id=&quot;------------전부-줄바꿀때-쓰는-명령어&quot;&gt;&lt;!-- --&gt;—, &lt;strong&gt;&lt;em&gt;, * * *, **&lt;/em&gt;&lt;/strong&gt;, - - -: 전부 줄바꿀때 쓰는 명령어.&lt;/h3&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;3--블럭인용문자&quot;&gt;3. &amp;gt;: 블럭인용문자.&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;This is BlockQuote&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;이거슨 인용문자&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;p&gt;이런식으로 nest 구조를 만드는것도 가능하고&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;blockquote&gt;
        &lt;h2 id=&quot;이런식으로-인용문-안에-다른-명령어나-코드도-넣을-수-있다&quot;&gt;이런식으로 인용문 안에 다른 명령어나 코드도 넣을 수 있다.&lt;/h2&gt;
      &lt;/blockquote&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;blockquote&gt;
        &lt;ul&gt;
          &lt;li&gt;List&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/blockquote&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;blockquote&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
int main(){
   cout &amp;lt;&amp;lt; &quot;Hello, World!&quot; &amp;lt;&amp;lt; '\n';
   return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/blockquote&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;4--코드-입력-가능-입력-끝나면-다시-써서-닫으면-됨&quot;&gt;4. ```: 코드 입력 가능. 입력 끝나면 다시 써서 닫으면 됨.&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    cout &amp;lt;&amp;lt; &quot;Hello, World!&quot; &amp;lt;&amp;lt; '\n';
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;5-숫자-리스트&quot;&gt;5. 숫자 리스트&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;첫번째&lt;/li&gt;
  &lt;li&gt;두번째&lt;/li&gt;
  &lt;li&gt;세번째&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;6-순서-없는-리스트&quot;&gt;6. 순서 없는 리스트&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;First
    &lt;ul&gt;
      &lt;li&gt;Second
        &lt;ul&gt;
          &lt;li&gt;Third
            &lt;ul&gt;
              &lt;li&gt;Fourth
                &lt;ul&gt;
                  &lt;li&gt;Fifth
                    &lt;ul&gt;
                      &lt;li&gt;Sixth
                        &lt;ul&gt;
                          &lt;li&gt;Seventh
                            &lt;ul&gt;
                              &lt;li&gt;…&lt;/li&gt;
                            &lt;/ul&gt;
                          &lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;7-링크&quot;&gt;7. 링크&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Link: [Google][googlelink]
[googlelink]https://google.com &quot;Go google&quot;

이런식으로 링크걸면됨.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://google.com&quot; title=&quot;Go google&quot;&gt;Google&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://keithlee94.github.io/KeithLog/

이런식으로 바로 거는방법도 있음.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;https://keithlee94.github.io/KeithLog/&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;8-강조&quot;&gt;8. 강조&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*하이라이트*, _하이라이트_: 이탤릭체
**강조**, __강조__: 볼드체
~~취소선~~: 단어에 취소선 생김
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;하이라이트&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;중요해&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;강조&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;강조&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;취소선&lt;/del&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;9-이미지-삽입&quot;&gt;9. 이미지 삽입&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![Alt text](/path/to/img.jpg) - url 넣어줘도 됨.
사이즈 조절 기능은 없기 때문에 &amp;lt;img width=&quot;&quot; height=&quot;&quot;&amp;gt;&amp;lt;/img&amp;gt;를 이용한다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Markdown" /><summary type="html">Markdown 문법 정리</summary></entry><entry><title type="html">2nd week summary</title><link href="http://localhost:4000/cse/2nd-Week-Summary/" rel="alternate" type="text/html" title="2nd week summary" /><published>2018-12-28T00:00:00+09:00</published><updated>2018-12-28T00:00:00+09:00</updated><id>http://localhost:4000/cse/2nd%20Week%20Summary</id><content type="html" xml:base="http://localhost:4000/cse/2nd-Week-Summary/">&lt;h1 id=&quot;2주차-정리&quot;&gt;2주차 정리&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;라이브러리, 프레임워크 차이
    &lt;ul&gt;
      &lt;li&gt;라이브러리: 기능 하나에 대해서만 제공(제한적인 용도)&lt;/li&gt;
      &lt;li&gt;프레임워크: 틀이 잡혀져 있다.(다양한 용도, 범용적) =&amp;gt; 커스터마이징이 어러움.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;AWS EC2
    &lt;ul&gt;
      &lt;li&gt;인스턴스 == 임대받은 컴퓨터 1대.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;힙 영역
    &lt;ul&gt;
      &lt;li&gt;동적할당시 할당되는 메모리 영역.&lt;/li&gt;
      &lt;li&gt;자바, 파이썬은 Garbage collector가 있으므로 굳이 free 안해줘도 안쓰는 공간은 할당 해제됨.(But, file은 일일이 close해줘야함)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;파이썬 자료구조
    &lt;ul&gt;
      &lt;li&gt;tuple
        &lt;ul&gt;
          &lt;li&gt;가공된 데이터의 내용이 바뀌지 않도록 방어하기 위해 사용.&lt;/li&gt;
          &lt;li&gt;상수와 비슷한 역할을 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;dic
        &lt;ul&gt;
          &lt;li&gt;내부적으로는 트리 형태를 띈다.&lt;/li&gt;
          &lt;li&gt;검색시간: O(1)이지만 실제로는 트리 형태를 띄므 로 O(1)에 가까운 O(logn)이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;map()
        &lt;ul&gt;
          &lt;li&gt;데이터 구조의 각 원소들에 동일한 함수를 적용하여 새로운 데이터를 만드는 파이썬의 기본 함수.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;JSON
    &lt;ul&gt;
      &lt;li&gt;JavaScript Object Notation.&lt;/li&gt;
      &lt;li&gt;서버와 통신하는 기본 데이터 양식으로 많이 사용된다.&lt;/li&gt;
      &lt;li&gt;JSONLint: JSON 형식에 맞는지 유효성을 검사해주는 사이트.&lt;/li&gt;
      &lt;li&gt;json.loads(): JSON을 읽어 dic으로 변환.&lt;/li&gt;
      &lt;li&gt;json.dumps(): dic을 읽어 JSON으로 변환.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;API
    &lt;ul&gt;
      &lt;li&gt;여러 서비스들 간에 범용으로 쓰이는 인터페이스.&lt;/li&gt;
      &lt;li&gt;REST API: 웹서버를 이용하여 API 제공. JSON을 데이터 양식으로 활용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;DialogFlow: 사용자의 입력 의도를 파악하여 의도에 맞게 Flask를 동작시키는 역할.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Slack 챗봇 Flow
    &lt;ol&gt;
      &lt;li&gt;사용자가 문장 입력&lt;/li&gt;
      &lt;li&gt;Slack이 사용자가 입력한 문장 Flask에 전달&lt;/li&gt;
      &lt;li&gt;Flask가 DialogFlow로 전달받은 문장 전달&lt;/li&gt;
      &lt;li&gt;DialogFlow가 정의된 Intent들을 바탕으로 전달된 문장의 문맥 파악&lt;/li&gt;
      &lt;li&gt;DialogFlow의 분석 결과를 Flask로 전달&lt;/li&gt;
      &lt;li&gt;Flask에 정의된 함수 중 전달된 Intent에 맞는 함수 실행&lt;/li&gt;
      &lt;li&gt;Flask가 Slack으로 함수 실행으로 만들어진 response 전달&lt;/li&gt;
      &lt;li&gt;Slack에서 사용자로 response 전달&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Git
    &lt;ul&gt;
      &lt;li&gt;Fetch: 저장된 것을 가져온다.&lt;/li&gt;
      &lt;li&gt;Branch: 가지치기.(Master = 최종 결과물, 배포판)&lt;/li&gt;
      &lt;li&gt;Merge: Branch 병합.&lt;/li&gt;
      &lt;li&gt;장점: 분산 작업 가능, 오프라인 개발 가능 - 중앙 서버에 접속하지 않고 각자의 환경에서 작업할 수 있으므로.&lt;/li&gt;
      &lt;li&gt;명령어
        &lt;ul&gt;
          &lt;li&gt;git log: git에 수행한 행동들을 보여준다.&lt;/li&gt;
          &lt;li&gt;git reset –hard “hash값”: “hash”값의 시점으로 git을 되돌린다.(이 시점 이후에 수행된 모든 commit은 다 취소됨)&lt;/li&gt;
          &lt;li&gt;git push -f: 강제로 push.&lt;/li&gt;
          &lt;li&gt;git commit –amend: commit 메시지 수정 가능.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;topic branch: 기능 추가, 버그 수정 등 단위작업을 위한 branch.&lt;/li&gt;
      &lt;li&gt;Merge 과정
        &lt;ol&gt;
          &lt;li&gt;다른 branch에서 commit&lt;/li&gt;
          &lt;li&gt;Master에서 git merge 실행&lt;/li&gt;
          &lt;li&gt;conflict 없으면 commit, conflict 있으면 어떤 부분을 반영할지 결정 후 commit&lt;/li&gt;
          &lt;li&gt;git에 push&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;pull: fetch와 merge를 한번에 진행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Basic" /><summary type="html">2주차 정리</summary></entry></feed>