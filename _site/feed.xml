<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="keithlee94.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="keithlee94.github.io/" rel="alternate" type="text/html" /><updated>2019-02-19T23:55:12+09:00</updated><id>keithlee94.github.io/feed.xml</id><title type="html">KeithLog</title><subtitle>SSAFY 교육내용, 알고리즘 문제풀이 정리하여 업로드할 블로그</subtitle><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><entry><title type="html">1946</title><link href="keithlee94.github.io/algorithm/1946/" rel="alternate" type="text/html" title="1946" /><published>2019-02-19T00:00:00+09:00</published><updated>2019-02-19T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1946</id><content type="html" xml:base="keithlee94.github.io/algorithm/1946/">&lt;h1 id=&quot;백준-1946번&quot;&gt;백준 1946번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1946&quot;&gt;1946번: 신입 사원&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;오늘도 Greedy문제.&lt;/p&gt;

&lt;p&gt;문제 이해하는데 시간이 좀 오래걸렸다.&lt;/p&gt;

&lt;p&gt;이해하고 나서 풀어보려는데 처음에는 두 등수의 평균을 구한 다음 평균이 높은 절반끼리 비교하는 방식으로 구현했는데, 일단 시간초과가 났다.&lt;/p&gt;

&lt;p&gt;방문 여부를 표시하고 조건에 안맞으면 반복문 중간에서 나가는 방식으로 보완했는데, 이렇게 푸니까 이젠 답이 틀리더라.&lt;/p&gt;

&lt;p&gt;그 다음엔 각각의 등수가 1인 경우들은 반드시 포함시키고, 이 둘에 대해 비교하며 카운트를 늘려가는 방식으로 풀어봤는데, 역시 틀렸다.&lt;/p&gt;

&lt;p&gt;한참 고민하며 반례 찾으러 질문게시판에 들어가봤는데, 반례 찾다가 다른사람의 아이디어를 보고 힌트를 얻어 풀 수 있었다.&lt;/p&gt;

&lt;p&gt;핵심은 한가지 등수로 오름차순 정렬을 하는 것.&lt;/p&gt;

&lt;p&gt;이렇게 하면 두가지 등수 중 한가지 등수만 비교하면 풀린다.&lt;/p&gt;

&lt;p&gt;나머지 한 등수에 대해 정답에 포함시킨 바로 앞 등수보다 크면 포함시키지 않고, 반대의 경우 작은 등수로 바꿔주고 카운트를 하나 늘린 후 이를 반복하는 방식으로 풀 수 있었다.&lt;/p&gt;

&lt;p&gt;아이디어를 짜내보려고 노력한 것까지는 좋았던 것 같으나 핵심을 찾는데에는 도달하지 못했다.&lt;/p&gt;

&lt;p&gt;심지어 한가지 등수로 오름차순 정렬하는것까지는 했는데 그 다음을 생각해내지 못했다는 점이 아쉬웠다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 19/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct candidates{
    int doc, interview;
};

bool compare(candidates &amp;amp;a, candidates &amp;amp;b){
    if(a.doc &amp;gt; b.doc){
        return false;
    }
    return true;
}

int main(){
    int T;

    cin &amp;gt;&amp;gt; T;

    for(int test=0; test&amp;lt;T; test++){
        int N;

        cin &amp;gt;&amp;gt; N;

        vector&amp;lt;candidates&amp;gt; applicants;

        for(int i=0; i&amp;lt;N; i++){
            int doc, interview;

            cin &amp;gt;&amp;gt; doc &amp;gt;&amp;gt; interview;

            applicants.push_back({doc, interview});
        }

        sort(applicants.begin(), applicants.end(), compare);

        int count = 1;

        int standard = applicants[0].interview;

        for(int i=1; i&amp;lt;applicants.size(); i++){
            if(standard &amp;gt; applicants[i].interview){
                standard = applicants[i].interview;
                count++;
            }
        }

        cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Greedy" /><summary type="html">백준 1946번 Link: 1946번: 신입 사원</summary></entry><entry><title type="html">1931</title><link href="keithlee94.github.io/algorithm/1931/" rel="alternate" type="text/html" title="1931" /><published>2019-02-18T00:00:00+09:00</published><updated>2019-02-18T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1931</id><content type="html" xml:base="keithlee94.github.io/algorithm/1931/">&lt;h1 id=&quot;백준-1931번&quot;&gt;백준 1931번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1931&quot;&gt;1931번: 회의실배정&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;Greedy 알고리즘의 대표격인 문제다.&lt;/p&gt;

&lt;p&gt;예전에 한번 풀어봤던것 같긴 한데 그때도 틀렸다.&lt;/p&gt;

&lt;p&gt;마음 다잡고 다시한번 풀어봤는데, 답이 맞는것 같으면서도 계속 틀렸다고 나오더라.&lt;/p&gt;

&lt;p&gt;어떤 부분에서 문제가 있나 해서 질문게시판 돌아다니면서 반례들을 찾아봤는데, 크게 2가지 문제가 있었다.&lt;/p&gt;

&lt;p&gt;첫번째는 끝나는 시간이 같은 경우 시작하는 시간이 빠른 회의가 먼저 오도록 정렬되어야 한다는 점.&lt;/p&gt;

&lt;p&gt;두번째는 배정 가능한 회의에 포함시킬때 그 회의를 포함하였음을 표시하여 중복으로 포함시켜선 안된다는 점.&lt;/p&gt;

&lt;p&gt;첫번째 문제는 정렬 함수를 좀 바꿔서 해결했다.&lt;/p&gt;

&lt;p&gt;두번째 문제는 방문 여부를 어떻게 표시할지 고민하다 1부터 2147483647까지의 bool형태의 배열을 만들까 해봤다.&lt;/p&gt;

&lt;p&gt;용량이 용량이라 그런지 컴파일 자체가 안되더라.&lt;/p&gt;

&lt;p&gt;어떻게할지 고민하다가 구조체에 방문 여부도 포함하도록 바꿔서 제출해보니 바로 맞았다.&lt;/p&gt;

&lt;p&gt;Greedy나 BFS나 DFS나 방문여부 표시해주는게 참 중요한 것 같다.&lt;/p&gt;

&lt;p&gt;몇년전부터 못풀던 문제였는데 오늘에서라도 풀어서 기분은 좋다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 18/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

struct meeting{
    int start, end;
    bool visit;
};

int N;

bool compare(meeting a, meeting b){
    if(a.end &amp;lt; b.end){
        return true;
    }
    else if(a.end == b.end){
        if(a.start &amp;lt; b.start){
            return true;
        }
    }
    return false;
}

int main(){
    cin &amp;gt;&amp;gt; N;

    vector&amp;lt;meeting&amp;gt; meetings;

    int start, end;

    for(int i=0; i&amp;lt;N; i++){
        cin &amp;gt;&amp;gt; start &amp;gt;&amp;gt; end;

        meetings.push_back({start, end, false});
    }

    sort(meetings.begin(), meetings.end(), compare);

    vector&amp;lt;meeting&amp;gt; available;
    available.push_back(meetings[0]);
    meetings[0].visit = true;

    for(int i=0; i&amp;lt;meetings.size(); i++){
        int currentEnd = available[available.size()-1].end;

        if(meetings[i].start &amp;gt;= currentEnd &amp;amp;&amp;amp; !meetings[i].visit){
            available.push_back(meetings[i]);
        }
    }

    cout &amp;lt;&amp;lt; available.size() &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Greedy" /><summary type="html">백준 1931번 Link: 1931번: 회의실배정</summary></entry><entry><title type="html">16235</title><link href="keithlee94.github.io/algorithm/16235/" rel="alternate" type="text/html" title="16235" /><published>2019-02-17T00:00:00+09:00</published><updated>2019-02-17T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/16235</id><content type="html" xml:base="keithlee94.github.io/algorithm/16235/">&lt;h1 id=&quot;백준-16235번&quot;&gt;백준 16235번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/16235&quot;&gt;16235번: 나무 재테크&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;작년 삼성 기출문제.&lt;/p&gt;

&lt;p&gt;IM쪽 기출문제였는데, 여기 시험보고 온 친구들이 전부 못풀어서 멘탈 터져서 온게 기억이 난다.&lt;/p&gt;

&lt;p&gt;풀기 시작한게 목요일이었는데, 목요일에는 별 생각없는 노가다로 풀어봤는데 테스트케이스 3개정도 맞히고 나머지 못맞혀서 왜그럴지 고민해봤다.&lt;/p&gt;

&lt;p&gt;그렇게 고민해보다 금요일에는 큐를 써서 한 레벨에 대해 전부 뽑아내고 1년을 진행하는 방식으로 해봤다.&lt;/p&gt;

&lt;p&gt;그래도 안풀려서 다시 고민했는데, 토요일엔 놀다가 일요일 와서야 풀었다.&lt;/p&gt;

&lt;p&gt;매우 단순한 방법으로 해결했는데, 내가 짠 코드대로면 봄에 죽은 나무가 벡터에서는 살아있기 때문에 죽은 나무의 나이를 -1로 바꾸고, 가을에 번식하는 조건에 나이가 0보다 클때로 한정함으로써 풀 수 있었다.&lt;/p&gt;

&lt;p&gt;시뮬레이션 문제인것 같은데, 내가 시험볼때 풀어봤던 큐브 문제에 비해서는 훨씬 깔끔하게 답을 구할 수 있었던 문제인것 같다.&lt;/p&gt;

&lt;p&gt;뭐 그때의 나였다면 이런 문제 던져줘도 못풀었을것 같긴 하다만…&lt;/p&gt;

&lt;p&gt;어쨌든 곧 시험볼때까지 실력을 꾸준히 키워야겠다는 생각이 든다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 14/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct Tree{
    int x, y, age;
};

int N, M, K;

int map[11][11] = {0, };
int winterAdd[11][11] = {0, };
int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};

queue&amp;lt;Tree&amp;gt; Queue;

int compare(const Tree &amp;amp;t1, const Tree &amp;amp;t2){
    if(t1.age &amp;lt; t2.age){
        return true;
    }
    return false;
}

int BFS(){
    for(int i=0; i&amp;lt;K; i++){
        vector&amp;lt;Tree&amp;gt; lives;
        vector&amp;lt;Tree&amp;gt; deads;

        while(!Queue.empty()){
            lives.push_back(Queue.front());
            Queue.pop();
        }

        sort(lives.begin(), lives.end(), compare);

        for(int j=0; j&amp;lt;lives.size(); j++) {
            if (map[lives[j].x][lives[j].y] &amp;gt;= lives[j].age) { // 봄
                map[lives[j].x][lives[j].y] -= lives[j].age;
                Queue.push({lives[j].x, lives[j].y, lives[j].age + 1});
                lives[j].age++;
            }
            else {
                deads.push_back({lives[j].x, lives[j].y, lives[j].age});
                lives[j].age = -1;
            }

            if(lives[j].age &amp;gt; 0 &amp;amp;&amp;amp; lives[j].age % 5 == 0){ // 가을
                for(int k=0; k&amp;lt;8; k++){
                    int nextX = lives[j].x + dx[k];
                    int nextY = lives[j].y + dy[k];

                    if(nextX &amp;gt; 0 &amp;amp;&amp;amp; nextX &amp;lt;= N &amp;amp;&amp;amp; nextY &amp;gt; 0 &amp;amp;&amp;amp; nextY &amp;lt;= N){
                        Queue.push({nextX, nextY, 1});
                    }
                }
            }
        }

        for(int k=0; k&amp;lt;deads.size(); k++){ // 여름
            map[deads[k].x][deads[k].y] += deads[k].age / 2;
        }

        for(int k=1; k&amp;lt;=N; k++){ // 겨울
            for(int l=1; l&amp;lt;=N; l++){
                map[k][l] += winterAdd[k][l];
            }
        }
    }

    return Queue.size();
}

int main(){
    for(int i=0; i&amp;lt;=10; i++){
        for(int j=0; j&amp;lt;=10; j++){
            map[i][j] = 5;
        }
    }

    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M &amp;gt;&amp;gt; K;

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=N; j++){
            cin &amp;gt;&amp;gt; winterAdd[i][j];
        }
    }

    int x, y, z;

    for(int i=0; i&amp;lt;M; i++){
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; z;

        Queue.push({x, y, z});
    }

    cout &amp;lt;&amp;lt; BFS() &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Simulation" /><category term="Brute Force" /><summary type="html">백준 16235번 Link: 16235번: 나무 재테크</summary></entry><entry><title type="html">9019</title><link href="keithlee94.github.io/algorithm/9019/" rel="alternate" type="text/html" title="9019" /><published>2019-02-13T00:00:00+09:00</published><updated>2019-02-13T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/9019</id><content type="html" xml:base="keithlee94.github.io/algorithm/9019/">&lt;h1 id=&quot;백준-9019번&quot;&gt;백준 9019번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/9019&quot;&gt;9019번: DSLR&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;예전에 풀어보다가 실패해서 그대로 접어뒀던 문제.&lt;/p&gt;

&lt;p&gt;알고리즘 스터디에서 BFS문제집을 만들었는데 만드는 김에 한번 다시 풀어볼 생각으로 넣었다.&lt;/p&gt;

&lt;p&gt;그리고 오늘 다시 풀어서 드디어 맞혔다.&lt;/p&gt;

&lt;p&gt;우선 그전에 짰던 코드는 정말 터무니없는 코드였던 것 같다.&lt;/p&gt;

&lt;p&gt;아예 새로운 마음으로 짰는데, 처음에 돌려봤을땐 메모리 초과가 났다.&lt;/p&gt;

&lt;p&gt;메모리 초과가 날만한 여지들을 전부 없애보려고 큐를 전역변수로 만들어도 보고 큐를 싹 비워도 봤는데 메모리 초과가 잡히지 않더라.&lt;/p&gt;

&lt;p&gt;질문게시판을 좀 찾아보던 중 나랑 비슷한 처지인 사람이 글을 올린걸 봤는데, 중복방문을 안하면 메모리 초과 문제를 해결할 수 있을 것이라는 답변을 보았다.&lt;/p&gt;

&lt;p&gt;그런데 그대로 실천해보니 이번엔 답이 틀렸다.&lt;/p&gt;

&lt;p&gt;무슨 문제일까 해서 모든 경우를 다 찍어봤는데, C++의 모듈러 연산과 내가 아는 모듈러 연산은 다르다는 점이 문제였다.&lt;/p&gt;

&lt;p&gt;-1을 10000으로 모듈러 연산을 한다고 생각해보자.&lt;/p&gt;

&lt;p&gt;모듈러 연산의 피연산자가 음수이므로 답은 9999가 되어야 한다.&lt;/p&gt;

&lt;p&gt;그런데 코드로 옮겨 보니, 9999가 아니라 -1이 그대로 나오더라.&lt;/p&gt;

&lt;p&gt;사실 문제 조건에도 -1이 나올 경우 9999로 만들라는 조건이 있었는데, 음수에 대한 모듈러 연산 한번이면 다 해결될줄 알았다.&lt;/p&gt;

&lt;p&gt;이 부분까지 잡아내고 돌려보니 바로 맞았다.&lt;/p&gt;

&lt;p&gt;내가 아는 상식과 컴퓨터의 연산 방식이 다르다는 점을 알게 된 문제였다.&lt;/p&gt;

&lt;p&gt;또, 난 보통 BFS문제를 풀때 방문 여부를 체크해주는 것을 자주 까먹는편인데 시간도 시간이지만 메모리상으로도 문제가 발생할 수 있다는 점을 알게 되었다.&lt;/p&gt;

&lt;p&gt;앞으로 BFS문제를 풀때는 방문 여부 체크하는 부분을 빼먹지 말아야겠다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 13/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int T;
int A, B;
string result;

bool visit[10000] = {false, };
char delta[4] = {'D', 'S', 'L', 'R'};

queue&amp;lt;pair&amp;lt;int, string&amp;gt;&amp;gt; Queue;

void BFS(){
    Queue.push(make_pair(A, &quot;&quot;));
    visit[A] = true;

    while(!Queue.empty()){
        int current = Queue.front().first;
        string currentAnswer = Queue.front().second;
        Queue.pop();

        if(current == B){
            result = currentAnswer;
            break;
        }

        for(int i=0; i&amp;lt;4; i++){
            int next = 0;
            string temp = &quot;&quot;;
            if(delta[i] == 'D'){
                next = (current * 2) % 10000;
            }
            else if(delta[i] == 'S'){
                if(current - 1 &amp;gt;= 0){
                    next = (current - 1) % 10000;
                }
                else{
                    next = 9999;
                }
            }
            else if(delta[i] == 'L'){
                next += (current % 1000) * 10;
                next += current / 1000;
            }
            else if(delta[i] == 'R'){
                next += current / 10;
                next += (current % 10) * 1000;
            }

            if(!visit[next]){
                visit[next] = true;
                temp += delta[i];
                Queue.push(make_pair(next, currentAnswer + temp));
            }
        }
    }
}

int main(){
    cin &amp;gt;&amp;gt; T;

    for(int test=0; test&amp;lt;T; test++){
        result = &quot;&quot;;
        bzero(visit, sizeof(visit));

        cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B;

        BFS();

        while(!Queue.empty()){
            Queue.pop();
        }

        cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Brute Force" /><category term="BFS" /><summary type="html">백준 9019번 Link: 9019번: DSLR</summary></entry><entry><title type="html">14500</title><link href="keithlee94.github.io/algorithm/14500/" rel="alternate" type="text/html" title="14500" /><published>2019-02-12T00:00:00+09:00</published><updated>2019-02-12T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/14500</id><content type="html" xml:base="keithlee94.github.io/algorithm/14500/">&lt;h1 id=&quot;백준-14500번&quot;&gt;백준 14500번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/14500&quot;&gt;14500번: 테트로미노&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;최대 500*500의 지도 위에 블럭을 놓을 수 있는 모든 경우를 고려하여 블럭이 놓인 부분에 위치한 숫자 합의 최대값을 찾는 문제.&lt;/p&gt;

&lt;p&gt;우선 블럭을 회전시키거나 대칭시켜보며 나올 수 있는 모든 경우를 생각해보았다.&lt;/p&gt;

&lt;p&gt;다 해보니 꽤 많았는데, 19가지였다.&lt;/p&gt;

&lt;p&gt;500*500짜리 지도에서 최악의 경우 500 * 500 * 19 = 4750000가지 경우를 전부 고려해봐야 하는데 이게 시간초과 안나고 가능할까? 라는 생각이 먼저 들었다.&lt;/p&gt;

&lt;p&gt;처음에는 19가지 도형이 전부 들어갈 수 있는 최소한의 넓이인 4*4짜리 map을 따로 만들어 이걸로 맞춰볼 생각을 해봤는데, 이 안에서 나올 수 있는 19가지 도형의 위치 경우의 수를 구해보니 113가지가 되더라.&lt;/p&gt;

&lt;p&gt;이건 아니다 싶어 결국 switch문 안에 19가지 경우를 전부 명시해서 넣고 3중 for문으로 돌렸다.&lt;/p&gt;

&lt;p&gt;조건문이 19가지나 되다 보니 중간에 헷갈려서 조건 잘못쓴 경우도 있었고 계산식 잘못 넣은 경우도 있었다.&lt;/p&gt;

&lt;p&gt;어찌어찌해서 다 잡아내고 돌려봤는데, 시간초과날줄 알았는데 잘 돌아가서 정답으로 나오더라.&lt;/p&gt;

&lt;p&gt;DFS나 BFS처럼 알려진 방법 말고 이런 무식한 방법으로 풀리는 문제도 있구나 하는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;아마 시뮬레이션 문제를 풀게 된다면 이런 문제가 아닐까라는 생각도 들었고.&lt;/p&gt;

&lt;p&gt;여튼 그리 깊게 생각하지 않아도 풀 수 있는 문제였다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 12/02/2019.
//

#include &amp;lt;iostream&amp;gt;

using namespace std;

int N, M;
int map[500][500] = {0, };
int result = 0;

int max(int a, int b){
    return a &amp;lt; b ? b : a;
}

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;M; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;M; j++){
            for(int shape=0; shape&amp;lt;19; shape++) {
                int sum = 0;

                switch (shape) {
                    case 0:
                        if(j+3 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i][j+3];
                        }
                        break;
                    case 1:
                        if(i+3 &amp;lt; N){
                            sum += map[i][j] + map[i+1][j] + map[i+2][j] + map[i+3][j];
                        }
                        break;
                    case 2:
                        if(i+1 &amp;lt; N &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i+1][j] + map[i][j+1] + map[i+1][j+1];
                        }
                        break;
                    case 3:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i+1][j] + map[i+2][j] + map[i+2][j+1];
                        }
                        break;
                    case 4:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j-1 &amp;gt;= 0){
                            sum += map[i][j] + map[i+1][j] + map[i+2][j] + map[i+2][j-1];
                        }
                        break;
                    case 5:
                        if(i+1 &amp;lt; N &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i+1][j];
                        }
                        break;
                    case 6:
                        if(i+1 &amp;lt; N &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i+1][j+2];
                        }
                        break;
                    case 7:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i+1][j+1] + map[i+2][j+1];
                        }
                        break;
                    case 8:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i+1][j] + map[i+2][j];
                        }
                        break;
                    case 9:
                        if(i-1 &amp;gt;= 0 &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i-1][j+2];
                        }
                        break;
                    case 10:
                        if(i+1 &amp;lt; N &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i+1][j] + map[i+1][j+1] + map[i+1][j+2];
                        }
                        break;
                    case 11:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i+1][j] + map[i+1][j+1] + map[i+2][j+1];
                        }
                        break;
                    case 12:
                        if(i-1 &amp;gt;= 0 &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i-1][j+1] + map[i-1][j+2];
                        }
                        break;
                    case 13:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j-1 &amp;gt;= 0){
                            sum += map[i][j] + map[i+1][j] + map[i+1][j-1] + map[i+2][j-1];
                        }
                        break;
                    case 14:
                        if(i+1 &amp;lt; N &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i+1][j+1] + map[i+1][j+2];
                        }
                        break;
                    case 15:
                        if(i+1 &amp;lt; N &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i][j+2] + map[i+1][j+1];
                        }
                        break;
                    case 16:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; i-1 &amp;gt;= 0 &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i+1][j+1] + map[i-1][j+1];
                        }
                        break;
                    case 17:
                        if(i-1 &amp;gt;= 0 &amp;amp;&amp;amp; j+2 &amp;lt; M){
                            sum += map[i][j] + map[i][j+1] + map[i-1][j+1] + map[i][j+2];
                        }
                        break;
                    case 18:
                        if(i+2 &amp;lt; N &amp;amp;&amp;amp; j+1 &amp;lt; M){
                            sum += map[i][j] + map[i+1][j] + map[i+2][j] + map[i+1][j+1];
                        }
                        break;
                }

                result = max(sum, result);
            }
        }
    }

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Brute Force" /><summary type="html">백준 14500번 Link: 14500번: 테트로미노</summary></entry><entry><title type="html">2309</title><link href="keithlee94.github.io/algorithm/2309/" rel="alternate" type="text/html" title="2309" /><published>2019-02-11T00:00:00+09:00</published><updated>2019-02-11T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2309</id><content type="html" xml:base="keithlee94.github.io/algorithm/2309/">&lt;h1 id=&quot;백준-2309번&quot;&gt;백준 2309번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2309&quot;&gt;2309번: 일곱 난쟁이&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;평범하게 모든 경우를 따져가며 조건 맞으면 출력해주는 DFS 문제였다.&lt;/p&gt;

&lt;p&gt;9개 중 7개를 뽑아 합이 100이 될때 리턴해주면 되는 문제다.&lt;/p&gt;

&lt;p&gt;요즘 DFS를 활용한 완전탐색 문제를 많이 접하는 것 같다.&lt;/p&gt;

&lt;p&gt;이건 그중에서도 기초적인 문제인듯 하다.&lt;/p&gt;

&lt;p&gt;분명 방학 시작 전까지는 이런 쉬운 문제도 쩔쩔매며 어떻게 풀지 고민했을 것 같은데, 어느새 아 이거 DFS로 조합 구해서 풀면 되는 문제네 하고 떠오를 수준이 되었다는 점이 마냥 신기하다.&lt;/p&gt;

&lt;p&gt;이런식으로 DP도 정복하는 것이 목표이다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 11/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int littles[9] = {0, };
bool visit[9] = {false, };
vector&amp;lt;int&amp;gt; intermediate;

void DFS(int index, int count){
    if(index == 9){
        if(count == 7){
            int sum = 0;

            for(int i=0; i&amp;lt;9; i++){
                if(visit[i]){
                    sum += littles[i];
                }
            }

            if(sum == 100){
                for(int i=0; i&amp;lt;9; i++){
                    if(visit[i]){
                        intermediate.push_back(littles[i]);
                    }
                }
            }
        }

        return;
    }

    visit[index] = true;
    DFS(index+1, count+1);
    visit[index] = false;
    DFS(index+1, count);
}

int main(){
    for(int i=0; i&amp;lt;9; i++){
        cin &amp;gt;&amp;gt; littles[i];
    }

    DFS(0, 0);

    vector&amp;lt;int&amp;gt; result;

    for(int i=0; i&amp;lt;7; i++){
        result.push_back(intermediate[i]);
    }

    sort(result.begin(), result.end());

    for(int i=0; i&amp;lt;result.size(); i++){
        cout &amp;lt;&amp;lt; result[i] &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Brute Force" /><category term="DFS" /><summary type="html">백준 2309번 Link: 2309번: 일곱 난쟁이</summary></entry><entry><title type="html">9663</title><link href="keithlee94.github.io/algorithm/9663/" rel="alternate" type="text/html" title="9663" /><published>2019-02-10T00:00:00+09:00</published><updated>2019-02-10T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/9663</id><content type="html" xml:base="keithlee94.github.io/algorithm/9663/">&lt;h1 id=&quot;백준-9663번&quot;&gt;백준 9663번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/9663&quot;&gt;9663번: N-Queen&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;많이들 알고있는 그 n-queen problem 문제다.&lt;/p&gt;

&lt;p&gt;백트래킹 알고리즘의 교과서같은 문제로, 그냥 DFS 다돌리면 시간 부족해서 안풀릴 문제다.&lt;/p&gt;

&lt;p&gt;짜다가 위키에 있는 소스코드를 봤는데, 내것보단 이게 훨씬 나아보여서 이걸 보고 이해하는 방향으로 했다.&lt;/p&gt;

&lt;p&gt;내가 생각했던 것과의 가장 큰 차이점은 체스판을 1차원 배열로만 표현했다는 점.&lt;/p&gt;

&lt;p&gt;1차원 배열로만 표현한 덕분에 2차원 배열을 순회하는 데 필요한 2중 for문을 단순 1중 for문으로 끝낼 수 있다는 시간적 이점이 있다.&lt;/p&gt;

&lt;p&gt;대각선으로 다른 퀸이 있는지 검사하는 방법을 제일 이해하기 힘들었는데, 우선 지금까지 놓여진 퀸들에 대해 for문을 통해 검사한다.&lt;/p&gt;

&lt;p&gt;이 for문의 iter 값은 곧 i번째 행 j번째 열에 퀸이 있는지를 표현하는 것이더라.&lt;/p&gt;

&lt;p&gt;abs(count - j) == abs(i - map[j])는 count번째 행 i열의 대각 2방향(위쪽, 아래쪽 모두)에 퀸이 있는지 없는지 검사하는 내용이다.&lt;/p&gt;

&lt;p&gt;이 if문에 걸리지 않았다면 퀸을 놓을 수 있는 것이므로 결과값을 1 증가시킨다.&lt;/p&gt;

&lt;p&gt;만약 걸렸다면 즉시 for문을 나가고 바깥쪽 for문을 통해 다음 놓을 수 있는 자리를 찾는다.&lt;/p&gt;

&lt;p&gt;이런식으로 반복하며 답을 찾는 문제다.&lt;/p&gt;

&lt;p&gt;어제만해도 DFS문제에 대해 자신감이 좀 생겼는데 이 문제는 또 다른것 같다.&lt;/p&gt;

&lt;p&gt;체스판을 1차원 배열로 표현하고 대각선방향 검사하는 코드만 봐도 아직 많이 모자라다는 걸 알 수 있었다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 10/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

using namespace std;

int N;
int map[14];
int result = 0;

void DFS(int count){
    if(count == N){
        result++;
        return;
    }

    for(int i=0; i&amp;lt;N; i++){
        bool available = true;

        for(int j=0; j&amp;lt;count; j++){ // 지금까지 놓아진 퀸들을 검사한다.
            if(map[j] == i || abs(count - j) == abs(i - map[j])){
                // map[j] == i: 새로운 퀸을 놓으려는 줄에 이미 다른 퀸이 있다.
                // abs(count - j) == abs(i - map[j]): 새로운 퀸을 놓으려는 위치의 대각선 방향에 이미 다른 퀸이 있다.
                available = false;
                break;
            }
        }

        if(available){
            map[count] = i;
            // count열 i행에 퀸을 배치한다.
            DFS(count+1);
        }
    }
}

int main(){
    cin &amp;gt;&amp;gt; N;

    DFS(0);

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Back Tracking" /><summary type="html">백준 9663번 Link: 9663번: N-Queen</summary></entry><entry><title type="html">12100</title><link href="keithlee94.github.io/algorithm/12100/" rel="alternate" type="text/html" title="12100" /><published>2019-02-09T00:00:00+09:00</published><updated>2019-02-09T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/12100</id><content type="html" xml:base="keithlee94.github.io/algorithm/12100/">&lt;h1 id=&quot;백준-12100번&quot;&gt;백준 12100번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/12100&quot;&gt;12100번: 2048 (Easy)&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;일단 내 힘만으로 풀었다는 것부터 적고간다ㅋㅋㅋㅋ&lt;/p&gt;

&lt;p&gt;DFS를 통해 모든 경우를 고려해봐야 하는 문제였다.&lt;/p&gt;

&lt;p&gt;우선 DFS를 구현하기 전에 map을 어떤 식으로 밀고 같은 수를 합치면 되는지를 먼저 고민해봤다.&lt;/p&gt;

&lt;p&gt;여러가지 방법을 생각해보던 중 벡터를 활용해서 옮겨야 하는 수들을 전부 집어넣고 옮긴 다음 옮겨진 수들을 합치는 방법을 생각해 봤다.&lt;/p&gt;

&lt;p&gt;그런데 이 방법에는 큰 문제가 있는데, 옮기고 합친 다음 다시 옮겨야 한다는 점이었다.&lt;/p&gt;

&lt;p&gt;이를 보완하기 위해 벡터에 옮겨야 하는 수들을 전부 넣고 map을 0으로 바꾼 다음, 그 수들을 비교해서 두 숫자가 같은 숫자이면 합치고 뒤의 숫자를 0으로 바꾼다.&lt;/p&gt;

&lt;p&gt;이렇게 벡터의 내용을 바꿔준 다음, 별도로 큐를 정의하여 벡터를 한번 순회하며 0이 아닌 수를 만나면 큐에 넣는다.&lt;/p&gt;

&lt;p&gt;마지막으로 옮기는 방향에 맞춰 큐의 내용대로 map을 바꿔주는 방법으로 구현하였다.&lt;/p&gt;

&lt;p&gt;메모리상으로는 비효율적이겠지만, 중요한건 시간이니 넘어가자…&lt;/p&gt;

&lt;p&gt;이렇게 옮기는 함수를 구현한 다음, DFS를 구현하였다.&lt;/p&gt;

&lt;p&gt;이 과정에서 많이 고민했는데, 처음에는 DFS의 인자로 DFS 횟수와 map을 주는 방법으로 구현하였다.&lt;/p&gt;

&lt;p&gt;이런식으로 하니 분명 모든 경우의 수를 따지긴 하지만 제출해보니 틀렸는데, 바로 map이 제대로 바뀌지 않는 것이 문제였다.&lt;/p&gt;

&lt;p&gt;처음에는 DFS가 제대로 돌지 않는게 아닌가 싶어서 string으로 모든 경우를 다 출력해봤다. 확인 결과 모든 경우 따지는건 맞더라.&lt;/p&gt;

&lt;p&gt;여기다 map도 같이 찍어보니 map이 제대로 안바뀌는 문제가 있다는 것을 찾아냈다.&lt;/p&gt;

&lt;p&gt;이걸 어떻게 해야 해결할 수 있나 한참 고민하던 중, string으로 찍어본 결과를 이용해보자는 생각을 하게 되었다.&lt;/p&gt;

&lt;p&gt;string에 찍힌 대로 DFS의 종료 조건에서 map을 바꾸는 방법을 생각해 냈고, 이대로 구현해보니 시간초과가 났다.&lt;/p&gt;

&lt;p&gt;DFS 돌때마다 20*20짜리 배열을 계속 돈다고 생각해보면 시간초과 나는게 당연했다.&lt;/p&gt;

&lt;p&gt;이 문제를 해결하기 위해 포인터를 사용했는데, 우선 20*20짜리 배열을 map과 같은 내용을 갖도록 초기화해준 다음 2차원 배열 포인터로 이 배열을 가리키도록 한다.&lt;/p&gt;

&lt;p&gt;이 2차원 배열 포인터를 map 바꿔주는 함수의 인자로 전달하여 map을 5번 바꿔준 다음, 앞에서 만든 20*20짜리 배열의 내용을 갱신해준다. 또 갱신 과정에서 최대값도 같이 갱신해준다.&lt;/p&gt;

&lt;p&gt;이런식으로 구현하여 제출하니 드디어 맞았다고 나왔다.&lt;/p&gt;

&lt;p&gt;DFS로 모든 경우를 다 따져보기만 하면 풀리는 문제였다. 다만 그 경우를 따지기 위한 전처리가 상당히 까다로웠던 문제.&lt;/p&gt;

&lt;p&gt;이제 DFS로 푸는 방법을 좀 이해한 것 같다.&lt;/p&gt;

&lt;p&gt;문제 풀면서 막히는 부분에 대해 어느 부분에서 막히는지 직접 찾아내고 해결했다는 점에서 매우 뿌듯하다.&lt;/p&gt;

&lt;p&gt;앞으로도 이렇게 내 힘만으로 풀어내는 문제들이 많이 있길!!&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 08/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

int N;
int result = 0;
int map[20][20] = {0, };

string progress = &quot;MMMMM&quot;;

int (*push(char direction, int (*tempMap)[20]))[20]{ // 이동시킨 후 바뀐 map 리턴.
    // 상
    if(direction == 'U'){
        for(int i=0; i&amp;lt;N; i++){
            vector&amp;lt;int&amp;gt; toMove; // 위로 이동시킬 숫자들
            queue&amp;lt;int&amp;gt; merge; // 이동 후 같은 숫자일때 합치고 저장

            for(int j=0; j&amp;lt;N; j++){
                if(tempMap[j][i] != 0){ // 위로 이동시킬 숫자가 있으면
                    toMove.push_back(tempMap[j][i]); // 벡터에 넣고
                    tempMap[j][i] = 0; // 숫자 자리를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){
                if(j+1 &amp;lt; toMove.size() &amp;amp;&amp;amp; toMove[j] == toMove[j+1]){ // 벡터 내에서 같은 숫자가 연속될 경우
                    toMove[j] *= 2; // 합친다
                    toMove[j+1] = 0; // 뒷 숫자를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){ // 벡터를 돌면서
                if(toMove[j] != 0){ // 원소가 0이 아니면
                    merge.push(toMove[j]); // 큐에 넣는다.
                }
            }

            int index = 0;

            while(!merge.empty()){ // 큐를 돌면서
                tempMap[index][i] = merge.front(); // 바뀐 숫자를 맵에 반영한다.
                merge.pop();
                index++;
            }
        }
    }

    // 하
    if(direction == 'D'){
        for(int i=0; i&amp;lt;N; i++){
            vector&amp;lt;int&amp;gt; toMove; // 아래로 이동시킬 숫자들
            queue&amp;lt;int&amp;gt; merge; // 이동 후 같은 숫자일때 합치고 저장

            for(int j=N-1; j&amp;gt;=0; j--){ // 아래쪽부터 돌거임
                if(tempMap[j][i] != 0){ // 아래로 이동시킬 숫자가 있으면
                    toMove.push_back(tempMap[j][i]); // 벡터에 넣고
                    tempMap[j][i] = 0; // 숫자 자리를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){
                if(j+1 &amp;lt; toMove.size() &amp;amp;&amp;amp; toMove[j] == toMove[j+1]){ // 벡터 내에서 같은 숫자가 연속될 경우
                    toMove[j] *= 2; // 합친다
                    toMove[j+1] = 0; // 뒷 숫자를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){ // 벡터를 돌면서
                if(toMove[j] != 0){ // 원소가 0이 아니면
                    merge.push(toMove[j]); // 큐에 넣는다.
                }
            }

            int index = 0;

            while(!merge.empty()){ // 큐를 돌면서
                tempMap[N-1-index][i] = merge.front(); // 바뀐 숫자를 맵에 반영한다.
                merge.pop();
                index++;
            }
        }
    }

    // 좌
    if(direction == 'L'){
        for(int i=0; i&amp;lt;N; i++){
            vector&amp;lt;int&amp;gt; toMove; // 왼쪽으로 이동시킬 숫자들
            queue&amp;lt;int&amp;gt; merge; // 이동 후 같은 숫자일때 합치고 저장

            for(int j=0; j&amp;lt;N; j++){
                if(tempMap[i][j] != 0){ // 왼쪽으로 이동시킬 숫자가 있으면
                    toMove.push_back(tempMap[i][j]); // 벡터에 넣고
                    tempMap[i][j] = 0; // 숫자 자리를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){
                if(j+1 &amp;lt; toMove.size() &amp;amp;&amp;amp; toMove[j] == toMove[j+1]){ // 벡터 내에서 같은 숫자가 연속될 경우
                    toMove[j] *= 2; // 합친다
                    toMove[j+1] = 0; // 뒷 숫자를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){ // 벡터를 돌면서
                if(toMove[j] != 0){ // 원소가 0이 아니면
                    merge.push(toMove[j]); // 큐에 넣는다.
                }
            }

            int index = 0;

            while(!merge.empty()){ // 큐를 돌면서
                tempMap[i][index] = merge.front(); // 바뀐 숫자를 맵에 반영한다.
                merge.pop();
                index++;
            }
        }
    }

    // 우
    if(direction == 'R'){
        for(int i=0; i&amp;lt;N; i++){
            vector&amp;lt;int&amp;gt; toMove; // 오른쪽으로 이동시킬 숫자들
            queue&amp;lt;int&amp;gt; merge; // 이동 후 같은 숫자일때 합치고 저장

            for(int j=N-1; j&amp;gt;=0; j--){ // 오른쪽부터 돌거임
                if(tempMap[i][j] != 0){ // 오른쪽으로 이동시킬 숫자가 있으면
                    toMove.push_back(tempMap[i][j]); // 벡터에 넣고
                    tempMap[i][j] = 0; // 숫자 자리를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){
                if(j+1 &amp;lt; toMove.size() &amp;amp;&amp;amp; toMove[j] == toMove[j+1]){ // 벡터 내에서 같은 숫자가 연속될 경우
                    toMove[j] *= 2; // 합친다
                    toMove[j+1] = 0; // 뒷 숫자를 0으로 만든다.
                }
            }

            for(int j=0; j&amp;lt;toMove.size(); j++){ // 벡터를 돌면서
                if(toMove[j] != 0){ // 원소가 0이 아니면
                    merge.push(toMove[j]); // 큐에 넣는다.
                }
            }

            int index = 0;

            while(!merge.empty()){ // 큐를 돌면서
                tempMap[i][N-1-index] = merge.front(); // 바뀐 숫자를 맵에 반영한다.
                merge.pop();
                index++;
            }
        }
    }

    return tempMap;
}

void DFS(int count){
    if(count == 5){
        int newMap[20][20] = {0, };
        int (*temp)[20] = newMap;

        for(int i=0; i&amp;lt;N; i++){
            for(int j=0; j&amp;lt;N; j++){
                newMap[i][j] = map[i][j];
            }
        }

        for(int i=0; i&amp;lt;progress.length(); i++){
            temp = push(progress[i], temp);
        }

        for(int i=0; i&amp;lt;N; i++){
            for(int j=0; j&amp;lt;N; j++){
                newMap[i][j] = temp[i][j];
                if(newMap[i][j] &amp;gt; result){
                    result = newMap[i][j];
                }
            }
        }

        return;
    }

    for(int i=1; i&amp;lt;=4; i++){
        if(i == 1){
            progress[count] = 'U';
        }
        else if(i == 2){
            progress[count] = 'D';
        }
        else if(i == 3){
            progress[count] = 'L';
        }
        else if(i == 4){
            progress[count] = 'R';
        }
        DFS(count+1);
    }
}

int main(){
    cin &amp;gt;&amp;gt; N;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;N; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    DFS(0);

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Brute Force" /><category term="DFS" /><summary type="html">백준 12100번 Link: 12100번: 2048 (Easy)</summary></entry><entry><title type="html">2251</title><link href="keithlee94.github.io/algorithm/2251/" rel="alternate" type="text/html" title="2251" /><published>2019-02-07T00:00:00+09:00</published><updated>2019-02-07T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2251</id><content type="html" xml:base="keithlee94.github.io/algorithm/2251/">&lt;h1 id=&quot;백준-2251번&quot;&gt;백준 2251번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2251&quot;&gt;2251번: 물통&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;연휴 시작한 다음날 어떻게 풀지 고민하다 방법만 생각해두고 풀진 않았던 문제.&lt;/p&gt;

&lt;p&gt;생각했던 풀이대로 풀어봤는데 우선 틀리고 시작했다.&lt;/p&gt;

&lt;p&gt;알고리즘 분류는 BFS로 되어 있는데 굳이 BFS를 써야하나…?? 라는 생각이 좀 들었다.&lt;/p&gt;

&lt;p&gt;아무튼 어거지로라도 BFS로 맞춰서 풀어보니 풀렸다.&lt;/p&gt;

&lt;p&gt;통상 아는 BFS와는 좀 다른데, 우선 3개의 물통의 양을 전부 한번에 저장해야 한다는 점이 달랐고 길찾는 BFS는 for문 돌려서 4방향정도 생각해보는게 끝인데 이건 6가지 경우를 전부 하나씩 고려해야 한다는 점이 조금 달랐다.&lt;/p&gt;

&lt;p&gt;BFS를 이렇게도 쓸수 있구나 하는 생각이 들게 된 문제.&lt;/p&gt;

&lt;p&gt;한가지 더 특기하자면 구조체를 직접 정의하고 활용한 첫 문제인 것 같다.&lt;/p&gt;

&lt;p&gt;예전에 한번 3가지였나 4가지 값을 큐에 넣고 썼던 적이 있던것 같은데 그때는 make_pair를 여러번 써서 무식하게 해결했던 것 같다.&lt;/p&gt;

&lt;p&gt;구조체에 익숙해지면 훨씬 우아한 방법으로 해결 가능할듯 하다.&lt;/p&gt;

&lt;p&gt;연휴 내내 놀았으니 이제 다시 또 꾸준히 풀어볼 작정이다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;어림도-없던-코드&quot;&gt;어림도 없던 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 07/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

int main(){
    int A, B, C;

    cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B &amp;gt;&amp;gt; C;

    bool basket[201];

    vector&amp;lt;int&amp;gt; possible;

    if(C &amp;gt; 0){
        if(!basket[C]) {
            possible.push_back(C);
            basket[C] = true;
        }
    }

    if(C - (C-A) &amp;gt;= 0){
        if(!basket[C-A] &amp;amp;&amp;amp; C-A &amp;gt;= 0) {
            possible.push_back(C - A);
            basket[C-A] = true;
        }
    }

    if(C - (C-B) &amp;gt;= 0){
        if(!basket[C-B] &amp;amp;&amp;amp; C-B &amp;gt;= 0){
            possible.push_back(C-B);
            basket[C-B] = true;
        }
    }

    if(C - A &amp;gt;= 0){
        if(!basket[A]){
            possible.push_back(A);
            basket[A] = true;
        }
    }

    if(C - B &amp;gt;= 0){
        if(!basket[B]){
            possible.push_back(B);
            basket[B] = true;
        }
    }

    sort(possible.begin(), possible.end());

    for(int i=0; i&amp;lt;possible.size(); i++){
        cout &amp;lt;&amp;lt; possible[i] &amp;lt;&amp;lt; ' ';
    }
    cout &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 07/02/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

struct water{
    int a, b, c;
};

int A, B, C;
bool visit[201][201];
bool result[201];

void BFS(){
    queue&amp;lt;water&amp;gt; Queue;
    Queue.push({0, 0, C});

    while(!Queue.empty()){
        water current = Queue.front();
        Queue.pop();

        if(visit[current.a][current.b]){
            continue;
        }

        visit[current.a][current.b] = true;

        if(current.a == 0){
            result[current.c] = true;
        }

        if(current.a + current.b &amp;gt; B) { // A -&amp;gt; B / A + B가 B보다 크면 B는 가득, A는 A + B - B의 용량만큼 찬다.
            Queue.push({current.a + current.b - B, B, current.c});
        }
        else{ // A + B가 B보다 작으므로 A의 물을 전부 B로 붓는다.
            Queue.push({0, current.a + current.b, current.c});
        }

        if(current.a + current.b &amp;gt; A){ // B -&amp;gt; A
            Queue.push({A, current.a + current.b - A, current.c});
        }
        else{
            Queue.push({current.a + current.b, 0, current.c});
        }

        if(current.a + current.c &amp;gt; C){ // A -&amp;gt; C
            Queue.push({current.a + current.c - C, current.b, C});
        }
        else{
            Queue.push({0, current.b, current.a + current.c});
        }

        if(current.a + current.c &amp;gt; A){ // C -&amp;gt; A
            Queue.push({A, current.b, current.a + current.c - A});
        }
        else{
            Queue.push({current.a + current.c, current.b, 0});
        }

        if(current.b + current.c &amp;gt; C){ // B -&amp;gt; C
            Queue.push({current.a, current.b + current.c - C, C});
        }
        else{
            Queue.push({current.a, 0, current.b + current.c});
        }

        if(current.b + current.c &amp;gt; B){ // C -&amp;gt; B
            Queue.push({current.a, B, current.b + current.c - B});
        }
        else{
            Queue.push({current.a, current.b + current.c, 0});
        }
    }
}

int main(){
    cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B &amp;gt;&amp;gt; C;

    BFS();

    for(int i=0; i&amp;lt;201; i++){
        if(result[i]){
            cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; ' ';
        }
    }
    cout &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="BFS" /><summary type="html">백준 2251번 Link: 2251번: 물통</summary></entry><entry><title type="html">1062</title><link href="keithlee94.github.io/algorithm/1062/" rel="alternate" type="text/html" title="1062" /><published>2019-01-30T00:00:00+09:00</published><updated>2019-01-30T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1062</id><content type="html" xml:base="keithlee94.github.io/algorithm/1062/">&lt;h1 id=&quot;백준-1062번&quot;&gt;백준 1062번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1062&quot;&gt;1062번: 가르침&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;29일부터 풀기 시작해서 30일에서 31일 넘어가는 새벽에야 겨우 해결했던 문제.&lt;/p&gt;

&lt;p&gt;내 답이 맞는것 같아 계속 고민하다 결국 답을 보고 해결했다.&lt;/p&gt;

&lt;p&gt;답을 찾아보고서야 예전에 DFS를 통해 조합을 구하는 방법을 써서 문제를 풀때 어떤식으로 코드를 짰는지 떠오르더라.&lt;/p&gt;

&lt;p&gt;정신승리를 좀 하자면, 시간초과가 났긴 했지만 어쨌든 답을 구할 수 있는 방법들을 최대한 생각해보고 여러 방법들을 비교해봤다는 점.&lt;/p&gt;

&lt;p&gt;이러는 과정에서 시간초과를 수십번 본 것 같은데, 어떤 부분에서 시간초과가 일어나는지는 짚어냈다.&lt;/p&gt;

&lt;p&gt;문제는 그 부분을 고치니 답이 틀렸다는 것.&lt;/p&gt;

&lt;p&gt;이렇게 여러번 고민해봐도 도저히 안풀려서 답을 찾아보게 되었다.&lt;/p&gt;

&lt;p&gt;답을 보고 나니 뭔가 매우 허무한 느낌이 들었다. 그동안 뭘 짜고 있었나 싶기도 하고.&lt;/p&gt;

&lt;p&gt;답을 찾아내기 위해 삽질했던 시간들이 있었기 때문에 정답을 보고서도 이 부분은 나도 구현했는데 왜 틀렸을까 하는 생각이 들게 하였고 이 부분은 이래서 이렇게 짰구나 하는 생각도 들 수 있었던것 같다.&lt;/p&gt;

&lt;p&gt;요며칠 단순한 BFS문제를 풀면서 이런식으로 DFS를 통해 조합을 구하고 백트래킹해야 풀리는 문제 푸는 연습을 해야겠다고 생각했는데, 이 문제가 전형적인 그런 문제였다.&lt;/p&gt;

&lt;p&gt;시간 지나고 푸는 방법 까먹을때쯤 한번 더 풀어봐야겠다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;삽질했던-코드&quot;&gt;삽질했던 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int result = 0;
int N, K;
int candidates[26] = {0, };
int words[50][26] = {0, };

int max(int a, int b){
    return a &amp;gt; b ? a : b;
}

void searchTeach(int count, int index, int toTeach[26], int limit){
    int tempResult = 0;

    int temp[26];
    for(int i=0; i&amp;lt;26; i++){
        temp[i] = toTeach[i];
    }

    if(candidates[index] == 1){
        temp[index] = 1;
    }

    if(count == limit){
        for(int i=0; i&amp;lt;N; i++){
            bool invalid = false;

            for(int j=0; j&amp;lt;26; j++){
                if(toTeach[j] - words[i][j] &amp;lt; 0){
                    invalid = true;
                    break;
                }
            }

            if(!invalid){
                tempResult++;
            }
        }

        result = max(result, tempResult);
        return;
    }

    int next = 0;
    for(int i=index+1; i&amp;lt;26; i++){
        if(candidates[i] == 1){
            next = i;
            break;
        }
    }

    searchTeach(count+1, next, temp, limit);
    searchTeach(count+1, next, toTeach, limit);
}

void toTeach(){
    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;26; j++){
            if(candidates[j] != 1){
                candidates[j] = words[i][j];
            }
        }
    }
}

int main(){
    string word;

    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K;

    for(int i=0; i&amp;lt;N; i++){
        cin &amp;gt;&amp;gt; word;

        if(K &amp;gt;= 5){
            string temp = word.substr(4, word.length()-8);
            for(int j=0; j&amp;lt;temp.length(); j++){
                int current = temp[j] - 'a';
                if(current != 0 &amp;amp;&amp;amp; current != 2 &amp;amp;&amp;amp; current != 8 &amp;amp;&amp;amp; current != 13 &amp;amp;&amp;amp; current != 19){
                    words[i][current] = 1;
                }
            }
        }
    }

    if(K &amp;lt; 5){
        result = 0;
    }
    else{
        toTeach();

        int input[26] = {0, };

        for(int i=0; i&amp;lt;26; i++){
            if(candidates[i] == 1){
                searchTeach(0, i, input, K-5);
                candidates[i]--;
            }
        }

        if(K == 5){
            searchTeach(0, 0, input, K-5);
        }
    }

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 30/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int result = 0;
int N, K;

string words[50];
bool visit[26];

int max(int a, int b){
    return a &amp;gt; b ? a : b;
}

void searchTeach(int index, int count){
    if(count == K-5){
        int tempResult = 0;

        for(int i=0; i&amp;lt;N; i++){
            bool invalid = false;

            for(int j=0; j&amp;lt;words[i].length(); j++){
                if(!visit[words[i][j] - 'a']){
                    invalid = true;
                    break;
                }

            }

            if(!invalid){
                tempResult++;
            }
        }

        result = max(result, tempResult);
        return;
    }

    for(int i=index; i&amp;lt;26; i++){
        if(!visit[i]){
            visit[i] = true;
            searchTeach(i, count+1);
            visit[i] = false;
        }
    }

}

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K;

    for(int i=0; i&amp;lt;N; i++){
        cin &amp;gt;&amp;gt; words[i];

        words[i] = words[i].substr(4, words[i].length()-8);
    }

    if(K &amp;lt; 5){
        result = 0;
    }
    else if(K == 26){
        result = N;
    }
    else{
        visit['a' - 'a'] = true;
        visit['n' - 'a'] = true;
        visit['t' - 'a'] = true;
        visit['c' - 'a'] = true;
        visit['i' - 'a'] = true;

        searchTeach(0, 0);
    }

    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Brute Force" /><category term="Backtracking" /><summary type="html">백준 1062번 Link: 1062번: 가르침</summary></entry></feed>