<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="keithlee94.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="keithlee94.github.io/" rel="alternate" type="text/html" /><updated>2019-01-14T21:38:47+09:00</updated><id>keithlee94.github.io/feed.xml</id><title type="html">KeithLog</title><subtitle>SSAFY 교육내용, 알고리즘 문제풀이 정리하여 업로드할 블로그</subtitle><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><entry><title type="html">1520</title><link href="keithlee94.github.io/algorithm/1520/" rel="alternate" type="text/html" title="1520" /><published>2019-01-14T00:00:00+09:00</published><updated>2019-01-14T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1520</id><content type="html" xml:base="keithlee94.github.io/algorithm/1520/">&lt;h1 id=&quot;백준-1520번&quot;&gt;백준 1520번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1520&quot;&gt;1520번: 내리막 길&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;평범한 길찾는문제일줄 알고 우선 BFS부터 냅다 써서 풀었다.&lt;/p&gt;

&lt;p&gt;분명 틀린 답은 아니다. 그런데 문제의 의도는 BFS 대신 DFS를 사용하여 메모리를 절약하고, DFS에 DP를 적용하여 시간을 절약하는 것이 의도였다.&lt;/p&gt;

&lt;p&gt;DFS에 DP를 접목시키는 문제는 처음 보는것 같다.&lt;/p&gt;

&lt;p&gt;그 느린 DFS를 이렇게 보완할수도 있구나 하는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;이 문제를 풀면서 BFS와 DFS의 차이를 제대로 체감할 수 있었던 것 같다.&lt;/p&gt;

&lt;p&gt;BFS는 시간 내에 해를 찾을 수 있지만, 큐를 사용하는 만큼 더 많은 메모리 공간을 사용한다는 점이 특징.&lt;/p&gt;

&lt;p&gt;DFS는 메모리 공간은 절약할 수 있지만, 깊이가 깊어질수록 매우 많은 시간을 요구한다는 점이 특징이다.&lt;/p&gt;

&lt;p&gt;이러한 DFS의 깊이에 따른 문제를 보완하는 방법으로 DP를 사용하는 문제였다.&lt;/p&gt;

&lt;p&gt;둘을 어떻게 접목시킬지 방법이 안떠올라서 결국 답을 찾아보고서야 이해할 수 있었다.&lt;/p&gt;

&lt;p&gt;우선 DP 배열을 전부 -1로 초기화하고 시작한다.&lt;/p&gt;

&lt;p&gt;그 다음, DFS를 목적지부터 (0, 0)까지 가도록 거꾸로 실행한다.&lt;/p&gt;

&lt;p&gt;DFS에 들어가면 우선 DP 배열부터 살펴보게 되는데, DP[startX][startY]가 -1이 아니라는 것은 이미 저장된 값이 있으며, 이는 이미 탐색해서 구한 값이 있음을 의미하므로 그대로 리턴한다.&lt;/p&gt;

&lt;p&gt;만약 startX나 startY가 범위를 벗어나면 0을 리턴하고, (0, 0)에 도착하게 되면 1을 리턴한다.&lt;/p&gt;

&lt;p&gt;이 3가지 조건문에 걸리지 않았다는 것은 아직 탐색하지 않은 곳임을 의미하므로 탐색을 진행한다.&lt;/p&gt;

&lt;p&gt;가장 먼저 DP[startX][startY]를 0으로 설정한다.&lt;/p&gt;

&lt;p&gt;그 다음은 통상 아는 DFS를 진행하는데, 내려가는 방향으로만 갈 수 있고 우리는 DFS를 거꾸로 진행하고 있으므로 map[nextX][nextY]가 map[startX][startY]보다 클 경우에만 DFS를 진행한다.&lt;/p&gt;

&lt;p&gt;조금 다른점이 있다면 통상 아는 DFS였다면 DFS(nextX, nextY)만 부르고 끝났겠지만, 이 문제는 DP를 접목시켜야 하므로 DP[startX][startY]의 값에 DFS(nextX, nextY)를 더한 값을 설정한다.&lt;/p&gt;

&lt;p&gt;이때 연쇄적으로 재귀함수를 돌다 더 갈수 없으면 DP[startX][startY]를 리턴하고, 리턴되는 값을 계속 더해주는 것이다.&lt;/p&gt;

&lt;p&gt;같은 방법으로 4방향 모두 탐색하며 DFS를 완성한다.&lt;/p&gt;

&lt;p&gt;풀이방법을 외워둬야 할 것 같은 문제다.&lt;/p&gt;

&lt;p&gt;BFS와 DFS의 차이점, DFS와 DP의 연계를 모두 배울 수 있는 문제였다. 까먹을때쯤 꼭 다시풀어볼 문제.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;bfs로-풀다-틀린-코드&quot;&gt;BFS로 풀다 틀린 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 13/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

int N, M;

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

int map[501][501];

int BFS(int startX, int startY){
    int result = 0;
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;

    Queue.push(make_pair(startX, startY));

//    vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; visits;

    while(!Queue.empty()){
        int currentX = Queue.front().first;
        int currentY = Queue.front().second;
        Queue.pop();

//        visits.push_back(make_pair(currentX, currentY));

        if(currentX == N &amp;amp;&amp;amp; currentY == M){
//            for(int i=0; i&amp;lt;visits.size(); i++){
//                cout &amp;lt;&amp;lt; map[visits[i].first][visits[i].second] &amp;lt;&amp;lt; ' ';
//            }
//            cout &amp;lt;&amp;lt; '\n';
//            visits.clear();
            result++;
        }

        for(int i=0; i&amp;lt;4; i++){
            int nextX = currentX + dx[i];
            int nextY = currentY + dy[i];

            if(nextX &amp;gt; 0 &amp;amp;&amp;amp; nextX &amp;lt;= N &amp;amp;&amp;amp; nextY &amp;gt; 0 &amp;amp;&amp;amp; nextY &amp;lt;= N){
                if(map[currentX][currentY] &amp;gt; map[nextX][nextY]){
                    Queue.push(make_pair(nextX, nextY));
                }
            }
        }
    }

    return result;
}

int main(){
    cin &amp;gt;&amp;gt; M &amp;gt;&amp;gt; N;

    for(int i=1; i&amp;lt;=M; i++) {
        for (int j = 1; j &amp;lt;= N; j++) {
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    cout &amp;lt;&amp;lt; BFS(1, 1) &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 13/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory.h&amp;gt;

using namespace std;

int N, M;

int map[501][501];
int DP[501][501];

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

int DFS(int startX, int startY){
    if(DP[startX][startY] != -1){
        return DP[startX][startY];
    }
    if(startX &amp;lt; 0 || startX &amp;gt;= N || startY &amp;lt; 0 || startY &amp;gt;= M){
        return 0;
    }
    if(startX == 0 &amp;amp;&amp;amp; startY == 0){
        return 1;
    }

    DP[startX][startY] = 0;

    for(int i=0; i&amp;lt;4; i++){
        int nextX = startX + dx[i];
        int nextY = startY + dy[i];

        if(map[nextX][nextY] &amp;gt; map[startX][startY]){
            DP[startX][startY] += DFS(nextX, nextY);
        }
    }

    return DP[startX][startY];
}

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;M; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }
    memset(DP, -1, sizeof(DP));

    cout &amp;lt;&amp;lt; DFS(N-1, M-1) &amp;lt;&amp;lt; '\n';

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;M; j++){
            cout &amp;lt;&amp;lt; DP[i][j] &amp;lt;&amp;lt; ' ';
        }
        cout &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><category term="DFS" /><category term="BFS" /><summary type="html">백준 1520번 Link: 1520번: 내리막 길</summary></entry><entry><title type="html">5th week summary</title><link href="keithlee94.github.io/java/5th-Week-Summary/" rel="alternate" type="text/html" title="5th week summary" /><published>2019-01-11T00:00:00+09:00</published><updated>2019-01-11T00:00:00+09:00</updated><id>keithlee94.github.io/java/5th%20Week%20Summary</id><content type="html" xml:base="keithlee94.github.io/java/5th-Week-Summary/">&lt;h1 id=&quot;알고리즘-스터디-내용-정리&quot;&gt;알고리즘 스터디 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;알고리즘-설계-기법&quot;&gt;알고리즘 설계 기법&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;완전검색: Brute Force
    &lt;ul&gt;
      &lt;li&gt;시간이 가장 많이 걸린다.&lt;/li&gt;
      &lt;li&gt;반드시 답을 찾을 수 있다 =&amp;gt; 소요 시간 비교의 척도가 된다.&lt;/li&gt;
      &lt;li&gt;시간 내에 답을 찾을 수 있는지 사전에 확인해봐야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;탐욕기법: Greedy
    &lt;ul&gt;
      &lt;li&gt;현재의 위치에서 최선의 선택을 한다.&lt;/li&gt;
      &lt;li&gt;선택이 옳았음을 증명하는 과정이 필요하다.&lt;/li&gt;
      &lt;li&gt;코드가 짧다.&lt;/li&gt;
      &lt;li&gt;답을 못찾을 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가지치기: Backtracking
    &lt;ul&gt;
      &lt;li&gt;답이 될 수 없는 것은 탐색하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;분할정복: Divide &amp;amp; Conquer
    &lt;ul&gt;
      &lt;li&gt;부분해로 전체 해를 구해 나간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;동적계획법: Dynamic Programming
    &lt;ul&gt;
      &lt;li&gt;부분해로 전체 해를 구해 나간다.(분할정복과 유사)&lt;/li&gt;
      &lt;li&gt;분할정복과의 차이: 부분해를 따로 저장함으로써 중복된 계산을 방지한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정렬&quot;&gt;정렬&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;버블 정렬
    &lt;ul&gt;
      &lt;li&gt;O(n^2)&lt;/li&gt;
      &lt;li&gt;맨 뒤에 정렬된 원소는 고정시킨다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;카운팅 정렬
    &lt;ul&gt;
      &lt;li&gt;O(n+k)&lt;/li&gt;
      &lt;li&gt;n이 비교적 작을때만 가능.&lt;/li&gt;
      &lt;li&gt;양의 정수만 정렬 가능.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;선택 정렬
    &lt;ul&gt;
      &lt;li&gt;O(n^2)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;퀵 정렬
    &lt;ul&gt;
      &lt;li&gt;O(nlogn)&lt;/li&gt;
      &lt;li&gt;상용 API의 정렬은 거의 퀵정렬로 구현되어 있음: 카운팅 정렬이 가장 빠르지만 대상이 정수일때만 사용 가능하므로 제약사항이 없는 퀵정렬로 구현.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;병합 정렬
    &lt;ul&gt;
      &lt;li&gt;O(nlogn)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;가능하면-카운팅-정렬-사용-안되면-api-사용&quot;&gt;가능하면 카운팅 정렬 사용, 안되면 API 사용.&lt;/h3&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;입력-방식-비교&quot;&gt;입력 방식 비교&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Scanner: 편하지만 시간이 많이 걸린다.&lt;/li&gt;
  &lt;li&gt;BufferedReader: 시간이 적게 걸리나 문자열로만 리턴 가능.
    &lt;ul&gt;
      &lt;li&gt;사용 예시
  ```
  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  String s = br.readLine(); // 문자열로만 리턴. 사용자가 입력한 한 줄을 문자열로 통째로 받아옴.
  s = “20”;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;int num = Integer.parseInt(s); // 숫자로 변경됨.&lt;/p&gt;

    &lt;p&gt;s = “1 2 3 4 5”;
  String[] arr = s.split(“ “); // s를 공백단위로 쪼갠다 =&amp;gt; arr: 5개의 문자열이 들어간다.
  ```&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;출력-방식-비교&quot;&gt;출력 방식 비교&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;System.out.println(): 출력하기 쉬우나 느리다.&lt;/li&gt;
  &lt;li&gt;BufferedWriter: 빠르게 출력 가능.
    &lt;ul&gt;
      &lt;li&gt;사용 예시
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  BufferedWriter bw = new BufferedWriter(System.out);
  bw.write(&quot;abcde&quot;); // 줄 안바뀜.
  bw.write(&quot;\n&quot;); // 줄바꿈하려면 개행문자 써줘야 함.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;static--non-static&quot;&gt;static / non-static&lt;/h1&gt;
&lt;p&gt;static 멤버는 non-static 멤버에 접근할 수 없다: static 멤버는 객체 생성 전에 사용할 수 있고, non-static 멤버는 객체 생성 후에 사용할 수 있기 때문.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;static
    &lt;ul&gt;
      &lt;li&gt;클래스 정보가 처음 로딩된 후 ~ 프로그램 종료시까지 사용 가능.(속도 빠름)&lt;/li&gt;
      &lt;li&gt;단점: 메모리에 상주하므로 메모리 낭비 가능성 존재.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;non-static
    &lt;ul&gt;
      &lt;li&gt;객체 생성 시점 ~ 참조변수가 없어질때까지 사용 가능.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java-프로그램-메모리-영역&quot;&gt;Java 프로그램 메모리 영역&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Call Stack: 메인 메소드, 지역변수 + 메인 메소드에서 호출된 메소드, 지역변수 저장.&lt;/li&gt;
  &lt;li&gt;Heap&lt;/li&gt;
  &lt;li&gt;Method Area&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;의 3가지 영역이 프로그램 실행시 자동으로 생성됨.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;반복문-재귀함수&quot;&gt;반복문, 재귀함수&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;반복문: CPU의 연산만 사용하므로 메모리 사용량이 적다.&lt;/li&gt;
  &lt;li&gt;재귀함수: 속도가 느리고 Call Stack 영역의 메모리를 많이 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;=&amp;gt; 꼭 필요한 경우에만 재귀함수 사용할것.(필요할때: 동적으로 반복문을 추가해야할 때)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;재귀함수의 인자도 Call Stack에 계속 쌓이므로 반드시 필요한 경우가 아니면 전역변수 등으로 처리하여 메모리를 절약할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;재귀함수 예시: 2진수 3자리를 모두 출력하는 재귀함수
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void twoThree(int i, int end, int[] arr){ // i: 시작 차수, end: 종료 차수, arr: 숫자 저장할 배열
  if(i == end){
      System.out.println(Arrays.toString(arr));
      return;
  }
  else{
      arr[i] = 0;
      twoThree(i+1, end, arr);
      arr[i] = 1;
      twoThree(i+1, end, arr);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;java-내용-정리&quot;&gt;Java 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;class-object&quot;&gt;class, object&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;class: 틀&lt;/li&gt;
  &lt;li&gt;object: 틀에서 만든 대상.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;class-정의&quot;&gt;class 정의&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;class명: 특수문자는 $, _만 허용. 길이제한 없음. 반드시 문자로 시작(숫자로 시작할 수 없음)&lt;/li&gt;
  &lt;li&gt;class를 개발한다 = 부품을 만드는 것과 같다. =&amp;gt; 재활용성을 염두에 두고 개발해야 한다.&lt;/li&gt;
  &lt;li&gt;class 내 field값을 초기화하지 않고 객체 생성시 각 타입의 기본값으로 초기화된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;객체-생성&quot;&gt;객체 생성&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;Class Area에서 호출하려는 class가 있는지 찾는다.&lt;/li&gt;
  &lt;li&gt;있으면 Heap 영역에 객체 주소 할당.&lt;/li&gt;
  &lt;li&gt;생성된 객체에 할당된 주소값 저장.
    &lt;ul&gt;
      &lt;li&gt;Class Loader: 하드디스크에 있는 class 파일을 메모리로 읽어온다.&lt;/li&gt;
      &lt;li&gt;Class Area: 메모리로 읽어온 클래스의 정보를 저장하는 곳.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;생성자&quot;&gt;생성자&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;클래스와 이름이 같은 메소드.&lt;/li&gt;
  &lt;li&gt;반드시 리턴타입이 없어야 한다.&lt;/li&gt;
  &lt;li&gt;객체 생성시 항상 호출된다 =&amp;gt; 반드시 있어야 한다.(초기화작업 필요없을 경우 생략 가능)&lt;/li&gt;
  &lt;li&gt;생성자를 따로 정의해두지 않았다면 컴파일러가 컴파일 시 기본 생성자를 코드에 삽입한다.&lt;/li&gt;
  &lt;li&gt;기본 생성자: 아무 파라미터가 없는 생성자.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;this&quot;&gt;this()&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;생성자 안에서만 사용 가능한 메소드.&lt;/li&gt;
  &lt;li&gt;다른 여러 생성자가 있으면 this()를 통해 다른 생성자 실행 가능.&lt;/li&gt;
  &lt;li&gt;다른 생성자 호출시 넘겨줄 인자가 없으면 임의로 기본값을 정해 넘길 수 있다. =&amp;gt; 아무 인자 없이 호출시 전부 설정된 기본값으로 들어간다.&lt;/li&gt;
  &lt;li&gt;목적: 중복 코드를 줄이기 위해.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;overloading&quot;&gt;Overloading&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;같거나 비슷한 일을 하는 메소드 구현시 메소드 이름을 같게 정의하여 사용을 편리하게 한다.&lt;/li&gt;
  &lt;li&gt;메소드명은 같고, 파라미터가 다르다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;접근-수식어접근-지정자-접근-제한자&quot;&gt;접근 수식어(=접근 지정자, 접근 제한자)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;public: 모든 경우 접근 가능.&lt;/li&gt;
  &lt;li&gt;protected: 패키지 상관없이 상속관계면 접근 가능.&lt;/li&gt;
  &lt;li&gt;default: 아무 접근 지정자가 없으면 default. 같은 패키지 내에서만 접근 가능.&lt;/li&gt;
  &lt;li&gt;private: 같은 class 내에서만 접근 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;같은 패키지 &amp;amp; 상속관계: default, protected, public 접근 가능.&lt;/li&gt;
  &lt;li&gt;같은 패키지 &amp;amp; 다른 클래스: default, protected, public 접근 가능.&lt;/li&gt;
  &lt;li&gt;같은 클래스: default, private, protected, public 접근 가능.&lt;/li&gt;
  &lt;li&gt;다른 패키지 &amp;amp; 상속관계: protected, public 접근 가능.&lt;/li&gt;
  &lt;li&gt;다른 패키지: public 접근 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;getter-setter&quot;&gt;getter, setter&lt;/h1&gt;
&lt;p&gt;함부로 데이터에 접근하려는 시도를 방지할 수 있다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;한개의-java파일-내에-여러개의-클래스&quot;&gt;한개의 .java파일 내에 여러개의 클래스&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;한 클래스 내에 여러 클래스 생성 가능.&lt;/li&gt;
  &lt;li&gt;But, 접근지정자는 단 하나의 클래스에만 붙일 수 있다.(.java파일의 파일명과 일치하는 클래스에만 붙일 수 있음): 프로그램 외부에서 무분별하게 접근하는 것을 막기 위함(보안적 측면)&lt;/li&gt;
  &lt;li&gt;파일명과 일치하지 않는 모든 클래스들은 default 접근 지정자만 혀용한다.&lt;/li&gt;
  &lt;li&gt;class에 대한 접근 지정자는 public, default의 2가지만 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;api&quot;&gt;API&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Application Programming Interface&lt;/li&gt;
  &lt;li&gt;객체지향 언어에서 class 단위로 미리 구현되어 제공되는 프로그램.&lt;/li&gt;
  &lt;li&gt;class 단위의 library.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;객체지향형-언어의-3가지-특징&quot;&gt;객체지향형 언어의 3가지 특징&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;Encapsulation(캡슐화)&lt;/li&gt;
  &lt;li&gt;Inheritance(상속)&lt;/li&gt;
  &lt;li&gt;Polymorphism(다형성)&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;inheritance&quot;&gt;Inheritance&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Java에서는 단일 상속만 지원.(부모는 하나만 가능)&lt;/li&gt;
  &lt;li&gt;class 설계시 특정 class를 상속받아 그 class의 variable과 메소드를 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;is a 관계
    &lt;ul&gt;
      &lt;li&gt;자식이 부모자리에 갈 수 있으나 부모가 자식자리에 갈 수 없다.&lt;/li&gt;
      &lt;li&gt;예: Tiger is an Animal - Tiger: 자식, Animal: 부모.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Generalization: class들의 공통된 특징을 모아 super class를 만든다.&lt;/li&gt;
  &lt;li&gt;Specialization: 비슷한 속성, 기능을 가진 클래스를 상속받아 새로운 클래스를 만든다.(sub class를 만든다)&lt;/li&gt;
  &lt;li&gt;sub class object 생성시 자동으로 super class의 생성자가 먼저 실행된다.
    &lt;ul&gt;
      &lt;li&gt;parent 객체가 먼저 생성된다.&lt;/li&gt;
      &lt;li&gt;상속관계가 여러 단계를 거치면 메모리가 낭비될 수 있다 =&amp;gt; 상속구조를 최소화하는 것이 좋다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;overriding&quot;&gt;Overriding&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;부모에게 물려받은 메소드를 자식 클래스에 맞게 재정의하는 것.&lt;/li&gt;
  &lt;li&gt;메소드 이름, 리턴 타입, 파라미터 모두 부모클래스의 메소드와 일치해야 한다.&lt;/li&gt;
  &lt;li&gt;바꿀 수 있는것: 메소드 바디, 접근 지정자.&lt;/li&gt;
  &lt;li&gt;접근 지정자는 부모의 접근 지정자와 같게 하거나 범위를 넓히는 방향으로만 가능하다.(좁아지면 안됨)&lt;/li&gt;
  &lt;li&gt;@Override annotation이 붙는다.&lt;/li&gt;
  &lt;li&gt;오버라이딩한 후에는 부모의 메소드 대신 항상 자식이 오버라이딩한 메소드가 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;annotation&quot;&gt;@annotation&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램에 대한 설명이나 설정사항 등을 나타냄.&lt;/li&gt;
  &lt;li&gt;함부로 지우다가 큰일난다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;super-this&quot;&gt;super, this&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;static 메소드 내에서 사용 불가.&lt;/li&gt;
  &lt;li&gt;static 메소드 내에서 굳이 쓰려면: non static 메소드를 메소드에서 super나 this를 사용하도록 새롭게 정의한 후 static 메소드에서 그 메소드를 호출한다.&lt;/li&gt;
  &lt;li&gt;super는 한번만 쓸 수 있다: super.super 안됨.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;nullpointerexception&quot;&gt;NullPointerException&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;객체 생성이 안된 상태에서 객체의 메소드 호출시 발생.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;상속관계에서-인자-있는-생성자&quot;&gt;상속관계에서 인자 있는 생성자&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;부모, 자식의 생성자 인자 중 겹치는게 있으면 super(겹치는인자, 겹치는인자, …)을 쓴 다음 자식만의 인자를 사용하여 따로 초기화하면 편하다.&lt;/li&gt;
  &lt;li&gt;목적: 코드 중복 제거 + 자식이 별도의 생성자를 정의할 수 있도록 한다.&lt;/li&gt;
  &lt;li&gt;주의사항: super(…) 구문이 항상 맨 먼저 나와야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;상속관계-예시&quot;&gt;상속관계 예시&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Parent{}

class Child extends Parent{}

Parent x = new Child(); // 가능: 자식은 부모자리에 갈 수 있다.
Child x = new Parent(): // 불가능: 부모는 자식자리에 갈 수 없다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;polymorphism다형성&quot;&gt;Polymorphism(다형성)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;생성된 객체를 가리키는 레퍼런스(변수)의 타입이 여러가지인 경우.&lt;/li&gt;
  &lt;li&gt;타입 캐스팅: 실제 저장되어 있는 객체가 캐스팅할 타입보다 작은 타입이어야 형변환 가능.
    &lt;ul&gt;
      &lt;li&gt;반대로 할 경우 컴파일은 되지만 실행시 Exception 발생.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상속관계에서는 부모가 항상 자식보다 큰 타입이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;polymorphism-예시&quot;&gt;Polymorphism 예시&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class GrandParent{
    String name = &quot;Doe&quot;;

    public void printName(){
        System.out.println(name);
    }

}

class Parent extends GrandParent{
    String name = &quot;Tom&quot;;
    String address = &quot;Seoul&quot;;

    public void printName(){
        System.out.println(name);
    }

    public void printAddress(){
        System.out.println(address);
    }

}

public class Child extends Parent{
    public void printName(){
        System.out.println(&quot;Tomson&quot;);
    }

    public void callSuper(){
        super.printName();
    }

    public static void main(String[] args){
        Parent x = new Child(); // 가능
        GrandParent c = new Child(); // 가능
        Child y = new Parent(); // 불가능

        c.printName(); // 결과: Tomson =&amp;gt; GrandParent의 printName을 Parent가, Parent의 printName을 Child가 재정의하므로 Child까지의 범위에서 가장 마지막에 재정의된 Child의 printName이 실행된다.
        c.callSuper(); // 에러: GrandParent 타입의 상위가 없기 때문.
        c.printAddress(); // 에러: GrandParent에 printAddress 메소드가 정의되어 있지 않다.
        System.out.println(c.getClass().getSimpleName()); // 결과: Child =&amp;gt; c의 타입은 GrandParent지만, 실제로 저장된 객체는 Child이므로 Child가 출력된다.(getClass: 실제로 저장된 객체의 타입을 가져온다.)
        
        GrandParent e = new Parent();
        e.printName(); // 결과: Tom =&amp;gt; GrandParent의 printName을 Parent가 재정의했으므로 Parent까지의 범위에서 가장 마지막에 재정의된 Parent의 printName이 실행된다.
        System.out.println(e.getClass().getSimpleName()); // 결과: Parent.
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Java" /><summary type="html">알고리즘 스터디 내용 정리</summary></entry><entry><title type="html">2156</title><link href="keithlee94.github.io/algorithm/2156/" rel="alternate" type="text/html" title="2156" /><published>2019-01-11T00:00:00+09:00</published><updated>2019-01-11T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2156</id><content type="html" xml:base="keithlee94.github.io/algorithm/2156/">&lt;h1 id=&quot;백준-2156번&quot;&gt;백준 2156번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2156&quot;&gt;2156번: 포도주 시식&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;문제를 보자마자 예전에 풀었던 계단 오르기와 비슷한 문제라는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;Link: &lt;a href=&quot;https://keithlee94.github.io/KeithLog/algorithm/2579/&quot;&gt;2579번: 계단 오르기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;차이점이 있다면 계단 오르기의 경우 마지막 계단을 반드시 밟아야 했지만, 이 문제는 3잔을 연속으로 마실 수 없다는 제약을 제외하면 어떠한 제약사항이 없다는 점이다.&lt;/p&gt;

&lt;p&gt;점화식으로 풀어야 한다는 점은 동일하다.&lt;/p&gt;

&lt;p&gt;예전에 계단 오르기를 풀때 점화식 세우는 과정을 제대로 이해하지 못한 것 같다.&lt;/p&gt;

&lt;p&gt;이번 문제에서도 점화식 세우는데 많은 어려움을 겪었고, 결국 에전에 풀었던 계단 오르기 문제를 다시 보면서 점화식을 어떻게 세워야 하는지 생각했다.&lt;/p&gt;

&lt;p&gt;또, 마지막 계단을 반드시 밟아야 한다는 제약사항을 빼고 구현하는 방법에 대해서도 많이 고민했던것 같다.&lt;/p&gt;

&lt;p&gt;결론적으로는 답을 찾아서 풀었다.&lt;/p&gt;

&lt;p&gt;점화식 세우는 연습은 얼마나 해야 점화식을 세울 줄 알게 되려나??&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 11/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int N;

int maximum(vector&amp;lt;int&amp;gt; numbers){
    int result = 0;

    for(int i=0; i&amp;lt;numbers.size(); i++){
        if(numbers[i] &amp;gt; result){
            result = numbers[i];
        }
    }

    numbers.clear();
    return result;
}

int main(){
    cin &amp;gt;&amp;gt; N;

    int DP[10001];
    int score[10001];

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; score[i];
    }

    vector&amp;lt;int&amp;gt; to_compare;

    DP[1] = score[1];
    DP[2] = max(score[1] + score[2], score[2]);

    for(int i=3; i&amp;lt;=N; i++){
        to_compare.push_back(DP[i-1]);
        to_compare.push_back(DP[i-2] + score[i]);
        to_compare.push_back(DP[i-3] + score[i] + score[i-1]);
        DP[i] = maximum(to_compare);
    }

    cout &amp;lt;&amp;lt; DP[N] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 2156번 Link: 2156번: 포도주 시식</summary></entry><entry><title type="html">2293</title><link href="keithlee94.github.io/algorithm/2293/" rel="alternate" type="text/html" title="2293" /><published>2019-01-10T00:00:00+09:00</published><updated>2019-01-10T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2293</id><content type="html" xml:base="keithlee94.github.io/algorithm/2293/">&lt;h1 id=&quot;백준-2293번&quot;&gt;백준 2293번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2293&quot;&gt;2293번: 동전 1&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;이 문제도 어떻게든 DP로 풀어보려 온갖 방법으로 생각해봤다.&lt;/p&gt;

&lt;p&gt;우선 각 동전들에 대해 최대로 쓸 수 있는 갯수를 구한 다음 하나씩 빼가면서 조합을 구하려고 생각해봤다.&lt;/p&gt;

&lt;p&gt;그런데 동전이 몇종류나 있을지도 모르고 시간도 그만큼 오래걸릴것 같아 이 생각은 접었다.&lt;/p&gt;

&lt;p&gt;암만 고민해봐도 이 방법 말고는 떠오르는 방법이 없어 결국 답을 찾아봤다.&lt;/p&gt;

&lt;p&gt;답 찾아보니 점화식을 세울줄 알아야 풀 수 있는 문제더라.&lt;/p&gt;

&lt;p&gt;심지어 그 점화식을 어떻게 세우는지에 대해서도 설명이 자세하게 나와있는게 잘 없어서 한참 뒤지면서 여러개 찾아보다가 겨우 이해했다.&lt;/p&gt;

&lt;p&gt;어떤 블로그에서 표를 그려가면서 풀면 금방 이해하고 점화식을 세울 수 있을거라 했는데, 점화식에 대해 이해하고 나니 왜 그렇게 말했는지 알 것 같다.&lt;/p&gt;

&lt;p&gt;점화식을 구하는 과정이다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;1원만 쓸 때 각 금액에 대해 나올 수 있는 경우의 수
    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;1원&lt;/td&gt;
            &lt;td&gt;2원&lt;/td&gt;
            &lt;td&gt;3원&lt;/td&gt;
            &lt;td&gt;4원&lt;/td&gt;
            &lt;td&gt;5원&lt;/td&gt;
            &lt;td&gt;6원&lt;/td&gt;
            &lt;td&gt;7원&lt;/td&gt;
            &lt;td&gt;8원&lt;/td&gt;
            &lt;td&gt;9원&lt;/td&gt;
            &lt;td&gt;10원&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;{1, 1, 1, 1, 1, 1, 1, 1, 1, 1}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;2원도 쓸 때 각 금액에 대해 나올 수 있는 경우의 수
    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;1원&lt;/td&gt;
            &lt;td&gt;2원&lt;/td&gt;
            &lt;td&gt;3원&lt;/td&gt;
            &lt;td&gt;4원&lt;/td&gt;
            &lt;td&gt;5원&lt;/td&gt;
            &lt;td&gt;6원&lt;/td&gt;
            &lt;td&gt;7원&lt;/td&gt;
            &lt;td&gt;8원&lt;/td&gt;
            &lt;td&gt;9원&lt;/td&gt;
            &lt;td&gt;10원&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;{1, 2, 2, 3, 3, 4, 4, 5, 5, 6}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;규칙&quot;&gt;규칙&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2원 경우의수 = 1원, 2원을 쓸때 0원 경우의수 + 1원만 쓸때 2원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3원 경우의수 = 1원, 2원을 쓸때 1원 경우의수 + 1원만 쓸때 3원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4원 경우의수 = 1원, 2원을 쓸때 2원 경우의수 + 1원만 쓸때 4원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1원, 2원을 쓸때 K원을 만드는 경우의 수: DP[K] += DP[K - 2]&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;5원도 쓸 때 각 금액에 대해 나올 수 있는 경우의 수
    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;1원&lt;/td&gt;
            &lt;td&gt;2원&lt;/td&gt;
            &lt;td&gt;3원&lt;/td&gt;
            &lt;td&gt;4원&lt;/td&gt;
            &lt;td&gt;5원&lt;/td&gt;
            &lt;td&gt;6원&lt;/td&gt;
            &lt;td&gt;7원&lt;/td&gt;
            &lt;td&gt;8원&lt;/td&gt;
            &lt;td&gt;9원&lt;/td&gt;
            &lt;td&gt;10원&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;{1, 2, 2, 3, 4, 5, 6, 7, 8, 10}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;규칙-1&quot;&gt;규칙&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;6원 경우의수 = 1원, 2원, 5원을 쓸때 6원 경우의수 + 1원, 2원을 쓸때 6원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7원 경우의수 = 1원, 2원, 5원을 쓸때 7원 경우의수 + 1원, 2원을 쓸때 7원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1원, 2원, 5원을 쓸때 K원을 만드는 경우의 수: DP[K] += DP[K - 5]&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;최종-점화식-x원을-추가했을때-k원을-만드는-경우의-수-dpk--dpk---x&quot;&gt;최종 점화식: x원을 추가했을때 K원을 만드는 경우의 수: DP[K] += DP[K - x]&lt;/h1&gt;

&lt;p&gt;이대로 코드로 옮기면 풀린다.&lt;/p&gt;

&lt;p&gt;작은문제로 쪼개고 그 결과를 저장하며 DP문제를 해결하는 유형에 대해서는 어떻게든 방법을 생각해낼 수 있을것 같은데, 점화식 짜서 풀어야되는 문제는 정말 답이 없는것 같다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 10/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int N, K;

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K;

    int DP[10001] = {0, };
    int coins[101];

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; coins[i];
    }

    DP[0] = 1;

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=K; j++){
            if(j &amp;gt;= coins[i]){
                DP[j] += DP[j - coins[i]];
            }
        }
    }

    cout &amp;lt;&amp;lt; DP[K] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 2293번 Link: 2293번: 동전 1</summary></entry><entry><title type="html">10844</title><link href="keithlee94.github.io/algorithm/10844/" rel="alternate" type="text/html" title="10844" /><published>2019-01-09T00:00:00+09:00</published><updated>2019-01-09T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/10844</id><content type="html" xml:base="keithlee94.github.io/algorithm/10844/">&lt;h1 id=&quot;백준-10844번&quot;&gt;백준 10844번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/10844&quot;&gt;10844번: 쉬운 계단 수&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;어제는 피곤함에 빈둥거리다 아무것도 못올렸다.&lt;/p&gt;

&lt;p&gt;이 문제는 어제부터 고민하다 방법을 찾았고, 그 방법을 어떻게 구현할지 많은 시행착오를 거친 끝에 결국 풀었다.&lt;/p&gt;

&lt;p&gt;사실 맨 마지막에 내 생각이 확실한데 답이 자꾸 틀려서 다른사람 답을 찾아보긴 했지만, 그 답이 내가 생각한 그대로여서 여태껏 답 찾아본 문제들중 가장 치열하게 고민한 문제인 것 같다는 생각을 했다.&lt;/p&gt;

&lt;p&gt;그만큼 이번에는 답찾아서 풀었음에도 쪽팔리다는 생각이 들지 않았고.&lt;/p&gt;

&lt;p&gt;각설하고, 푸는 방법에 대해 설명해보자면 이 문제에서 각 자릿수가 몇자리수이냐는 아무 상관이 없다.&lt;/p&gt;

&lt;p&gt;가장 중요한 것은 1의자리 숫자가 무엇인지.&lt;/p&gt;

&lt;p&gt;N이 1일때, 2일때, 3일때의 경우들을 직접 구해보니 1의자리 숫자에 따라 다음 수가 영향을 받는다는 것을 알 수 있었다.&lt;/p&gt;

&lt;p&gt;자꾸 보다보니 N일때의 답 = (N-1일때의 답 * 2) - (N-1일때의 계단수 중 첫자리 숫자가 1인 것의 갯수) 라는 규칙을 찾은것같은데, 맞는지는 모르겠다.&lt;/p&gt;

&lt;p&gt;어떻게 구현할지 한참 고민하다 저 규칙대로 풀어보기 위해 우선 큐에 넣고 갱신해가면서 모든 경우를 다 돌려봤다.&lt;/p&gt;

&lt;p&gt;한 5분은 지나야 전체 답을 구할 수 있더라.&lt;/p&gt;

&lt;p&gt;이런 과정을 거치면서 이 문제를 어떻게하면 이전 N에서 얻은 답을 사용할수 있을지에 대해 중점적으로 고민해보았고, 결국 1의자리 숫자만이 영향을 미친다는 점을 찾기에 이르렀다.&lt;/p&gt;

&lt;p&gt;이 문제를 풀며 가장 고무적이었다고 생각했던 부분은 DP의 특성을 어떻게든 적용하기 위해 노력했다는 점.&lt;/p&gt;

&lt;p&gt;앞에서 구한 답을 어떻게 써먹을수 있는지 그 어느때보다 치열하게 고민한 것 같다.&lt;/p&gt;

&lt;p&gt;이 문제를 풀어낸 것이 앞으로 DP문제를 푸는데 있어 전환점이 되길!!&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 08/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int main(){
    int N;

    cin &amp;gt;&amp;gt; N;

    unsigned long long DP[101][11];
    bzero(DP, sizeof(DP));

    for(int i=1; i&amp;lt;10; i++){
        DP[1][i] = 1;
    }

    for(int i=2; i&amp;lt;=N; i++) {
        DP[i][0] = DP[i-1][1];
        for(int j=1; j&amp;lt;10; j++){
            DP[i][j] = (DP[i-1][j-1] + DP[i-1][j+1]) % 1000000000;
        }
    }

    unsigned long long sum = 0;
    for(int i=0; i&amp;lt;10; i++){
        sum += DP[N][i];
    }
    cout &amp;lt;&amp;lt; (sum % 1000000000) &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 10844번 Link: 10844번: 쉬운 계단 수</summary></entry><entry><title type="html">Swea_1289</title><link href="keithlee94.github.io/algorithm/SWEA_1289/" rel="alternate" type="text/html" title="Swea_1289" /><published>2019-01-07T00:00:00+09:00</published><updated>2019-01-07T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/SWEA_1289</id><content type="html" xml:base="keithlee94.github.io/algorithm/SWEA_1289/">&lt;h1 id=&quot;swea-1289번&quot;&gt;SWEA 1289번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AWgebGzaXfEDFAW0&amp;amp;contestProbId=AV19AcoKI9sCFAZN&amp;amp;probBoxId=AWgebGzqXfIDFAW0+&amp;amp;type=PROBLEM&amp;amp;problemBoxTitle=Club+Problem+box+01&amp;amp;problemBoxCnt=++3+&quot;&gt;1289번: 원재의 메모리 복구하기&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;무난하게 풀었던 구현 문제.&lt;/p&gt;

&lt;p&gt;string 처리에서 살짝 헤맨것 말고는 무난하게 풀었다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 07/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string.h&amp;gt;

using namespace std;

int T;

int main(){
    cin &amp;gt;&amp;gt; T;

    string input = &quot;&quot;;

    for(int test=1; test&amp;lt;=T; test++){
        int count = 0;
        string modified = &quot;&quot;;

        cin &amp;gt;&amp;gt; input;

        for(int i=0; i&amp;lt;input.length(); i++){
            modified.push_back('0');
        }

        for(int i=0; i&amp;lt;input.length(); i++){
            if(modified[i] != input[i]){
                if(input[i] == '0'){
                    for(int j=i; j&amp;lt;modified.length(); j++){
                        modified[j] = '0';
                    }
                }
                else if(input[i] == '1'){
                    for(int j=i; j&amp;lt;modified.length(); j++){
                        modified[j] = '1';
                    }
                }
                count++;
            }
        }

        cout &amp;lt;&amp;lt; '#' &amp;lt;&amp;lt; test &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; count &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Realization" /><summary type="html">SWEA 1289번 Link: 1289번: 원재의 메모리 복구하기</summary></entry><entry><title type="html">Swea_3307</title><link href="keithlee94.github.io/algorithm/SWEA_3307/" rel="alternate" type="text/html" title="Swea_3307" /><published>2019-01-07T00:00:00+09:00</published><updated>2019-01-07T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/SWEA_3307</id><content type="html" xml:base="keithlee94.github.io/algorithm/SWEA_3307/">&lt;h1 id=&quot;swea-3307번&quot;&gt;SWEA 3307번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AWgebGzaXfEDFAW0&amp;amp;contestProbId=AWBOKg-a6l0DFAWr&amp;amp;probBoxId=AWgebGzqXfIDFAW0+&amp;amp;type=PROBLEM&amp;amp;problemBoxTitle=Club+Problem+box+01&amp;amp;problemBoxCnt=++3+&quot;&gt;3307번: 최장 증가 부분 수열&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;완전탐색 문제인줄 알고 앞에서 썼던 DFS 써서 풀었다가 시간초과났던 문제.&lt;/p&gt;

&lt;p&gt;조합을 하는건 맞는데, DP로 풀었어야 풀리는 문제였다.&lt;/p&gt;

&lt;p&gt;최근에 DP 공부를 하고있었는데도 DP로 풀어야겠다는 생각은 여전히 들지 않았다.&lt;/p&gt;

&lt;p&gt;어찌어찌 테스트케이스는 맞출수 있도록 구현했는데, 제출해보니 한개도 못맞히더라.&lt;/p&gt;

&lt;p&gt;시험장가서 테스트케이스 맞히고도 탈락하는 경우가 왕왕 있다던데, 이런 경우인가 싶었다.&lt;/p&gt;

&lt;p&gt;덤으로 이딴 실력으로 시험장에 가지 않았다는 점이 천만다행.&lt;/p&gt;

&lt;p&gt;풀이에 대해 설명하자면, 우선 입력받은 숫자들 중 수열의 시작점을 for문을 통해 정한다.&lt;/p&gt;

&lt;p&gt;그 다음, 남은 숫자들을 택해서 증가수열을 만들고 그 증가수열의 길이를 갱신하며 최대값을 구하는 문제다.&lt;/p&gt;

&lt;p&gt;이를 위한 조건으로 2가지를 넣었다.&lt;/p&gt;

&lt;p&gt;첫째는 다음 숫자가 반드시 수열의 시작점보다 큰 숫자일 것.&lt;/p&gt;

&lt;p&gt;두번째는 증가수열의 길이가 증가하는 방향일 것.&lt;/p&gt;

&lt;p&gt;이 두가지를 만족하지 못하면 증가수열에 숫자를 포함하지 않고, 다음 숫자들을 계속 살펴보는 식이다.&lt;/p&gt;

&lt;p&gt;이 문제도 답보고 겨우 풀었는데, DP 문제에 대한 감을 살짝 잡은 것 같다.(아직 확실하진 않음)&lt;/p&gt;

&lt;p&gt;이런 최대값 찾는 DP문제의 경우 조건에 맞아 DP 배열의 값을 갱신한 후, 최대값을 갱신하는 작업을 반복하는 방식인 것 같다.&lt;/p&gt;

&lt;p&gt;너무 당연한 말을 한것 같지만, 이런 감 찾는데 정말 오래걸렸다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;아무튼&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;될때까지-하자&quot;&gt;될때까지 하자.&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 08/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;string.h&amp;gt;

using namespace std;

int T;

int main(){
    cin &amp;gt;&amp;gt; T;

    for(int test=1; test&amp;lt;=T; test++){
        int maximum = 0;
        int N;

        cin &amp;gt;&amp;gt; N;

        int numbers[N];
        int DP[N];

        for(int i=0; i&amp;lt;N; i++){
            cin &amp;gt;&amp;gt; numbers[i];
        }

        bzero(DP, sizeof(DP));

        for(int i=0; i&amp;lt;N; i++){
            for(int j=i+1; j&amp;lt;N; j++){
                if(numbers[j] &amp;lt; numbers[i]) continue;
                if(DP[j] &amp;gt;= DP[i] + 1) continue;
                DP[j] = DP[i] + 1; // 증가수열이면서 수열 count가 증가한다면 1 더해줌.
                maximum = max(maximum, DP[j]); // 최대값 갱신.
            }
        }

        cout &amp;lt;&amp;lt; '#' &amp;lt;&amp;lt; test &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; maximum+1 &amp;lt;&amp;lt; '\n';
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">SWEA 3307번 Link: 3307번: 최장 증가 부분 수열</summary></entry><entry><title type="html">Swea_5215</title><link href="keithlee94.github.io/algorithm/SWEA_5215/" rel="alternate" type="text/html" title="Swea_5215" /><published>2019-01-07T00:00:00+09:00</published><updated>2019-01-07T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/SWEA_5215</id><content type="html" xml:base="keithlee94.github.io/algorithm/SWEA_5215/">&lt;h1 id=&quot;swea-5215번&quot;&gt;SWEA 5215번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AWgebGzaXfEDFAW0&amp;amp;contestProbId=AWT-lPB6dHUDFAVT&amp;amp;probBoxId=AWgebGzqXfIDFAW0+&amp;amp;type=PROBLEM&amp;amp;problemBoxTitle=Club+Problem+box+01&amp;amp;problemBoxCnt=++3+&quot;&gt;5215번: 햄버거 다이어트&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;완전탐색으로 최적의 조합을 구하는 문제.&lt;/p&gt;

&lt;p&gt;문제 보자마자 ‘이건 DFS쓰면 풀리겠구나’ 하는 생각은 들었다.&lt;/p&gt;

&lt;p&gt;이렇게 생각하고 풀었는데, DFS 구현에서 정말 많이 헤맸다.&lt;/p&gt;

&lt;p&gt;DFS랑 BFS는 그래도 구현방법을 다 외우고 있었다고 생각했었는데 벌써 다 까먹은 모양이다.&lt;/p&gt;

&lt;p&gt;예전에 코딩테스트 볼때도 확실하게 몰랐던거니 당연할수도.&lt;/p&gt;

&lt;p&gt;어떻게든 고쳐서 해보다 안되서 답 찾아서 풀었다.&lt;/p&gt;

&lt;p&gt;핵심은 DFS를 쓰긴 하는데 각각의 재료를 포함했을때와 포함하지 않았을때를 반드시 같이 돌려야 한다는것.&lt;/p&gt;

&lt;p&gt;제약조건에 따라 포함하거나 포함안하거나 따지면서 DFS 두번 돌리면 바로 풀린다.&lt;/p&gt;

&lt;p&gt;아직도 정말 갈길이 멀다고 생각했다.&lt;/p&gt;

&lt;p&gt;DFS, BFS는 자신있다고 생각했는데… 심지어 DFS로 풀어야된다는걸 알면서도 틀려서 더 자괴감 오진다.&lt;/p&gt;

&lt;h1 id=&quot;될때까지-하자&quot;&gt;될때까지 하자.&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 07/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int T;
int N, L;
int maximum = 0;

vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; base;

void DFS(int start, int calory, int score){
    if(start == N){
        maximum = maximum &amp;gt; score ? maximum : score;
        return;
    }
    if(calory + base[start].second &amp;lt;= L){
        DFS(start+1, calory+base[start].second, score+base[start].first); // start번째 재료 추가
    }
    DFS(start+1, calory, score); // start번째 재료 거름
}

int main(){
    cin &amp;gt;&amp;gt; T;

    for(int test=1; test&amp;lt;=T; test++){
        cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; L;

        for(int i=0; i&amp;lt;N; i++){
            int calory;
            int score;

            cin &amp;gt;&amp;gt; score &amp;gt;&amp;gt; calory;

            base.push_back(make_pair(score, calory));
        }

        DFS(0, 0, 0);

        cout &amp;lt;&amp;lt; '#' &amp;lt;&amp;lt; test &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; maximum &amp;lt;&amp;lt; '\n';
        while(!base.empty()){
            base.pop_back();
        }
        maximum = 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DFS" /><summary type="html">SWEA 5215번 Link: 5215번: 햄버거 다이어트</summary></entry><entry><title type="html">1463</title><link href="keithlee94.github.io/algorithm/1463/" rel="alternate" type="text/html" title="1463" /><published>2019-01-07T00:00:00+09:00</published><updated>2019-01-07T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1463</id><content type="html" xml:base="keithlee94.github.io/algorithm/1463/">&lt;h1 id=&quot;백준-1463번&quot;&gt;백준 1463번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1463&quot;&gt;1463번: 1로 만들기&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;오늘도 내힘으로 푸는데 실패.&lt;/p&gt;

&lt;p&gt;이 문제도 직전에 풀었던 계단문제처럼 점화식이 가장 중요했다.&lt;/p&gt;

&lt;p&gt;주어진 조건을 곧이곧대로 썼다가 답없는 상황이 나왔다.&lt;/p&gt;

&lt;p&gt;가장 먼저 입력된 수를 3으로 나눠떨어지는지 검사하고 나눠떨어지면 3으로 나누는 것을 첫번째 조건으로 넣었고&lt;/p&gt;

&lt;p&gt;3으로 나눠떨어지지 않으면 2로 나눠떨어지는지 검사하고 나눠떨어지면 2로 나누는 것을 두번째 조건으로 넣었다.&lt;/p&gt;

&lt;p&gt;이 두가지를 만족하지 않을때 1을 빼는 것으로 3가지 조건을 넣었다.&lt;/p&gt;

&lt;p&gt;도무지 어떻게 더 나갈지 모르겠어서 예전 답을 다시 찾아봤다.&lt;/p&gt;

&lt;p&gt;예전 답도 구글링해서 답 찾아보고 풀었는데, 1년동안 실력이 전혀 안늘어난 느낌이다.&lt;/p&gt;

&lt;p&gt;정답은 우선 1을 뺀 다음, 3으로 나눠떨어지면 3으로 나눴을때와 1을 뺐을때의 DP를 비교하는 것이었다.&lt;/p&gt;

&lt;p&gt;3으로 나눠떨어지지 않을 경우, 2로 나눠떨어지면 2로 나눴을때와 1을 뺐을때의 DP를 비교한다.&lt;/p&gt;

&lt;p&gt;나머지 경우는 당연히 1을 뺀 값이 DP에 들어간다.&lt;/p&gt;

&lt;p&gt;오늘로 DP에서 5문제를 풀고있는데, 문제마다 매번 다른 개념인것 같은 느낌이다.&lt;/p&gt;

&lt;p&gt;DP 문제 전반에 걸칠 수 있는 개념이 안잡힌 느낌. 첫술에 배부를수는 당연히 없지만 이대로 갔을때 실력이 늘긴 할지, DP에 대한 접근 방법을 제대로 파악할 수 있긴 할지 매우 걱정된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 07/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string.h&amp;gt;

using namespace std;

int min(int a, int b){
    return a &amp;gt; b ? b : a;
}

int main(){
    int N;
    int DP[1000000];

    cin &amp;gt;&amp;gt; N;

    bzero(DP, sizeof(DP));

    for(int i=2; i&amp;lt;=N; i++){
        DP[i] = DP[i-1] + 1; // 기본적으로 1 빼준다.

        if(i % 2 == 0){
            DP[i] = min(DP[i], DP[i/2] + 1); // 2로 나눠떨어지면 2로 나눴을때와 1뺐을때를 비교한다.
        }
        if(i % 3 == 0){
            DP[i] = min(DP[i], DP[i/3] + 1); // 3으로 나눠떨어지면 3으로 나눴을때와 1뺐을때를 비교한다.
        }
    }

    cout &amp;lt;&amp;lt; DP[N] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 1463번 Link: 1463번: 1로 만들기</summary></entry><entry><title type="html">4th week summary</title><link href="keithlee94.github.io/java/4th-Week-Summary/" rel="alternate" type="text/html" title="4th week summary" /><published>2019-01-04T00:00:00+09:00</published><updated>2019-01-04T00:00:00+09:00</updated><id>keithlee94.github.io/java/4th%20Week%20Summary</id><content type="html" xml:base="keithlee94.github.io/java/4th-Week-Summary/">&lt;h1 id=&quot;java-스터디-내용-정리&quot;&gt;Java 스터디 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;project-package-분리-이유&quot;&gt;Project, Package 분리 이유&lt;/h1&gt;
&lt;p&gt;프로젝트의 각 기능을 쪼개기 위해 패키지 사용.&lt;/p&gt;

&lt;p&gt;논리적으로 따로 나눠 작업하기 위해 분리하는 경우가 대다수이다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java의-특징&quot;&gt;Java의 특징&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;객체지향
    &lt;ul&gt;
      &lt;li&gt;시스템의 기본 구성단위는 &lt;strong&gt;객체(Object)&lt;/strong&gt; 이다.&lt;/li&gt;
      &lt;li&gt;객체: 일종의 부품 역할.&lt;/li&gt;
      &lt;li&gt;여러 부품들을 모아 조립하듯이 프로그램을 완성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;플랫폼 독립적
    &lt;ul&gt;
      &lt;li&gt;하드웨어, OS와 상관없이 모든 환경에서 동작 가능.&lt;/li&gt;
      &lt;li&gt;이유: JVM 위에서 작동하므로.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;분산 프로그래밍: 원격 접속 가능.&lt;/li&gt;
  &lt;li&gt;멀티스레드&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java-컴파일-과정&quot;&gt;Java 컴파일 과정&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;소스코드 작성: (…).java 파일 생성.&lt;/li&gt;
  &lt;li&gt;컴파일
    &lt;ul&gt;
      &lt;li&gt;명령어: javac (…).java
        &lt;ul&gt;
          &lt;li&gt;javac -d …: 패키지가 있을 경우 자동으로 패키지 폴더를 생성하며 컴파일.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;JVM이 인식 가능한 byte code로 번역하는 과정.&lt;/li&gt;
      &lt;li&gt;결과: Bytecode 생성 - (…).class 파일 생성.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실행
    &lt;ul&gt;
      &lt;li&gt;명령어: java (…)&lt;/li&gt;
      &lt;li&gt;JVM 위에서 실행됨.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/23356503/50677469-654b6480-103d-11e9-9b3c-e330a67fba48.jpeg&quot; alt=&quot;java compile&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C의 경우 실행파일을 다른 환경에서 실행시키면 실행 안됨.&lt;/p&gt;

&lt;p&gt;Java의 경우 JVM이 존재하므로 다른 환경에서 실행 가능함.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;primitive-data-type&quot;&gt;Primitive Data Type&lt;/h1&gt;
&lt;p&gt;기본적인 값을 기억하는 type.&lt;/p&gt;

&lt;p&gt;1 byte = 8 bit&lt;/p&gt;

&lt;p&gt;char = 16 bit = 2 byte&lt;/p&gt;

&lt;p&gt;int = 32 bit = 4 byte&lt;/p&gt;

&lt;p&gt;float = 32 bit = 4 byte&lt;/p&gt;

&lt;p&gt;double = 64 bit = 8 byte&lt;/p&gt;

&lt;p&gt;long = 64 bit = 8 byte&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;reference-data-type&quot;&gt;Reference Data Type&lt;/h1&gt;
&lt;p&gt;객체의 참조값을 기억하는 type.&lt;/p&gt;

&lt;p&gt;class, interface, 배열 등.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;String: class이므로 Reference Type이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;literal&quot;&gt;Literal&lt;/h1&gt;
&lt;p&gt;값 자체.&lt;/p&gt;

&lt;p&gt;예: 3.14, 10, ‘C’, false, …&lt;/p&gt;

&lt;p&gt;정수 리터럴 = 4바이트에 저장됨.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;논리연산자&quot;&gt;논리연산자&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&amp;amp;&amp;amp; 연산자: 앞조건이 false면 뒤에 오는 조건 확인하지 않고 연산 종료.&lt;/li&gt;
  &lt;li&gt;&amp;amp; 연산자: 앞조건이 false여도 뒤에 오는 조건을 확인한 후 연산 종료.&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;,&lt;/td&gt;
          &lt;td&gt;연산자도 동일함.&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;3항연산자&quot;&gt;3항연산자&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(x &amp;gt; y) ? x : y =&amp;gt; 실행결과: x가 y보다 크면 x, 작거나 같으면 y가 된다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;for--each&quot;&gt;for ~ each&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int sum = 0;
int[] su = {24, 6, 5, 36, 36, 65, 245, 56, 3, 64};

for(int s: su){
    System.out.println(s);
    sum += s;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;실행결과: sum에는 su 배열의 모든 숫자를 더한 값이 저장되고, su 배열의 모든 원소가 한번씩 출력된다.&lt;/p&gt;

&lt;p&gt;=&amp;gt; 배열 내 모든 원소에 한번씩 접근한다.(파이썬과 유사함)&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;error-exception&quot;&gt;Error, Exception&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Error
    &lt;ul&gt;
      &lt;li&gt;복구 불가능&lt;/li&gt;
      &lt;li&gt;프로그램이 비정상적으로 종료됨.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Exception
    &lt;ul&gt;
      &lt;li&gt;일종의 가벼운 에러&lt;/li&gt;
      &lt;li&gt;프로그램상으로 수정 가능함.&lt;/li&gt;
      &lt;li&gt;Java가 해결 방법을 알려줄 수 있음.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;배열-기본값&quot;&gt;배열 기본값&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;배열의 type에 따라 다르게 배열 생성시 기본값으로 자동으로 채워진다.&lt;/li&gt;
  &lt;li&gt;int형: 0&lt;/li&gt;
  &lt;li&gt;boolean형: false&lt;/li&gt;
  &lt;li&gt;double형: 0.0&lt;/li&gt;
  &lt;li&gt;String형: null
    &lt;ul&gt;
      &lt;li&gt;참조형 type의 배열의 기본값은 항상 null이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;main메소드의-args-사용법&quot;&gt;main메소드의 args 사용법&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;Run Configuration 설정&lt;/li&gt;
  &lt;li&gt;Arguments -&amp;gt; Program arguments -&amp;gt; ${string-prompt} 설정.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;new-키워드&quot;&gt;new 키워드&lt;/h1&gt;
&lt;p&gt;객체를 만들때 사용하는 키워드.&lt;/p&gt;

&lt;h1 id=&quot;method&quot;&gt;method&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;C의 함수와 같다.&lt;/li&gt;
  &lt;li&gt;클래스 내에서 객체가 가져야 할 기능을 정의.&lt;/li&gt;
  &lt;li&gt;독립적인 기능들을 분리하여 재사용 가능하도록 하기 위해 사용.&lt;/li&gt;
  &lt;li&gt;return type, method 이름, parameter list가 반드시 있어야 한다.&lt;/li&gt;
  &lt;li&gt;method 내에 method 정의 불가능.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;arraycopy&quot;&gt;arraycopy()&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;배열 복사 함수.&lt;/li&gt;
  &lt;li&gt;System.arraycopy(소스배열, 소스배열의 시작위치, 목적배열, 목적배열의 시작위치, 길이);&lt;/li&gt;
  &lt;li&gt;작은 배열일 경우 통상적인 반복문이 더 효율적.&lt;/li&gt;
  &lt;li&gt;배열이 클때 사용시 효율적이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;다차원-배열-길이&quot;&gt;다차원 배열 길이&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;su = new int[5][3];
su2 = new int[3];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;su.length: 5&lt;/p&gt;

&lt;p&gt;su[0].length: 3&lt;/p&gt;

&lt;p&gt;su2.length: 3&lt;/p&gt;

&lt;p&gt;=&amp;gt; 가장 첫번째 칸의 숫자가 배열의 길이.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;return&quot;&gt;return&lt;/h1&gt;
&lt;p&gt;문장의 실행을 그자리에서 멈춘다.&lt;/p&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Java" /><summary type="html">Java 스터디 내용 정리</summary></entry></feed>