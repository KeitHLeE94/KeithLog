<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="keithlee94.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="keithlee94.github.io/" rel="alternate" type="text/html" /><updated>2019-01-11T00:02:57+09:00</updated><id>keithlee94.github.io/feed.xml</id><title type="html">KeithLog</title><subtitle>SSAFY 교육내용, 알고리즘 문제풀이 정리하여 업로드할 블로그</subtitle><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><entry><title type="html">2293</title><link href="keithlee94.github.io/algorithm/2293/" rel="alternate" type="text/html" title="2293" /><published>2019-01-10T00:00:00+09:00</published><updated>2019-01-10T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2293</id><content type="html" xml:base="keithlee94.github.io/algorithm/2293/">&lt;h1 id=&quot;백준-2293번&quot;&gt;백준 2293번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2293&quot;&gt;2293번: 동전 1&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;이 문제도 어떻게든 DP로 풀어보려 온갖 방법으로 생각해봤다.&lt;/p&gt;

&lt;p&gt;우선 각 동전들에 대해 최대로 쓸 수 있는 갯수를 구한 다음 하나씩 빼가면서 조합을 구하려고 생각해봤다.&lt;/p&gt;

&lt;p&gt;그런데 동전이 몇종류나 있을지도 모르고 시간도 그만큼 오래걸릴것 같아 이 생각은 접었다.&lt;/p&gt;

&lt;p&gt;암만 고민해봐도 이 방법 말고는 떠오르는 방법이 없어 결국 답을 찾아봤다.&lt;/p&gt;

&lt;p&gt;답 찾아보니 점화식을 세울줄 알아야 풀 수 있는 문제더라.&lt;/p&gt;

&lt;p&gt;심지어 그 점화식을 어떻게 세우는지에 대해서도 설명이 자세하게 나와있는게 잘 없어서 한참 뒤지면서 여러개 찾아보다가 겨우 이해했다.&lt;/p&gt;

&lt;p&gt;어떤 블로그에서 표를 그려가면서 풀면 금방 이해하고 점화식을 세울 수 있을거라 했는데, 점화식에 대해 이해하고 나니 왜 그렇게 말했는지 알 것 같다.&lt;/p&gt;

&lt;p&gt;점화식을 구하는 과정이다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;1원만 쓸 때 각 금액에 대해 나올 수 있는 경우의 수
    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;1원&lt;/td&gt;
            &lt;td&gt;2원&lt;/td&gt;
            &lt;td&gt;3원&lt;/td&gt;
            &lt;td&gt;4원&lt;/td&gt;
            &lt;td&gt;5원&lt;/td&gt;
            &lt;td&gt;6원&lt;/td&gt;
            &lt;td&gt;7원&lt;/td&gt;
            &lt;td&gt;8원&lt;/td&gt;
            &lt;td&gt;9원&lt;/td&gt;
            &lt;td&gt;10원&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;{1, 1, 1, 1, 1, 1, 1, 1, 1, 1}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;2원도 쓸 때 각 금액에 대해 나올 수 있는 경우의 수
    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;1원&lt;/td&gt;
            &lt;td&gt;2원&lt;/td&gt;
            &lt;td&gt;3원&lt;/td&gt;
            &lt;td&gt;4원&lt;/td&gt;
            &lt;td&gt;5원&lt;/td&gt;
            &lt;td&gt;6원&lt;/td&gt;
            &lt;td&gt;7원&lt;/td&gt;
            &lt;td&gt;8원&lt;/td&gt;
            &lt;td&gt;9원&lt;/td&gt;
            &lt;td&gt;10원&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;{1, 2, 2, 3, 3, 4, 4, 5, 5, 6}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;규칙&quot;&gt;규칙&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2원 경우의수 = 1원, 2원을 쓸때 0원 경우의수 + 1원만 쓸때 2원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3원 경우의수 = 1원, 2원을 쓸때 1원 경우의수 + 1원만 쓸때 3원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4원 경우의수 = 1원, 2원을 쓸때 2원 경우의수 + 1원만 쓸때 4원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1원, 2원을 쓸때 K원을 만드는 경우의 수: DP[K] += DP[K - 2]&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;5원도 쓸 때 각 금액에 대해 나올 수 있는 경우의 수
    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;1원&lt;/td&gt;
            &lt;td&gt;2원&lt;/td&gt;
            &lt;td&gt;3원&lt;/td&gt;
            &lt;td&gt;4원&lt;/td&gt;
            &lt;td&gt;5원&lt;/td&gt;
            &lt;td&gt;6원&lt;/td&gt;
            &lt;td&gt;7원&lt;/td&gt;
            &lt;td&gt;8원&lt;/td&gt;
            &lt;td&gt;9원&lt;/td&gt;
            &lt;td&gt;10원&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;{1, 2, 2, 3, 4, 5, 6, 7, 8, 10}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;규칙-1&quot;&gt;규칙&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;6원 경우의수 = 1원, 2원, 5원을 쓸때 6원 경우의수 + 1원, 2원을 쓸때 6원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7원 경우의수 = 1원, 2원, 5원을 쓸때 7원 경우의수 + 1원, 2원을 쓸때 7원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1원, 2원, 5원을 쓸때 K원을 만드는 경우의 수: DP[K] += DP[K - 5]&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;최종-점화식-x원을-추가했을때-k원을-만드는-경우의-수-dpk--dpk---x&quot;&gt;최종 점화식: x원을 추가했을때 K원을 만드는 경우의 수: DP[K] += DP[K - x]&lt;/h1&gt;

&lt;p&gt;이대로 코드로 옮기면 풀린다.&lt;/p&gt;

&lt;p&gt;작은문제로 쪼개고 그 결과를 저장하며 DP문제를 해결하는 유형에 대해서는 어떻게든 방법을 생각해낼 수 있을것 같은데, 점화식 짜서 풀어야되는 문제는 정말 답이 없는것 같다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 10/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int N, K;

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K;

    int DP[10001] = {0, };
    int coins[101];

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; coins[i];
    }

    DP[0] = 1;

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=K; j++){
            if(j &amp;gt;= coins[i]){
                DP[j] += DP[j - coins[i]];
            }
        }
    }

    cout &amp;lt;&amp;lt; DP[K] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 2293번 Link: 2293번: 동전 1</summary></entry><entry><title type="html">10844</title><link href="keithlee94.github.io/algorithm/10844/" rel="alternate" type="text/html" title="10844" /><published>2019-01-09T00:00:00+09:00</published><updated>2019-01-09T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/10844</id><content type="html" xml:base="keithlee94.github.io/algorithm/10844/">&lt;h1 id=&quot;백준-10844번&quot;&gt;백준 10844번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/10844&quot;&gt;10844번: 쉬운 계단 수&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;어제는 피곤함에 빈둥거리다 아무것도 못올렸다.&lt;/p&gt;

&lt;p&gt;이 문제는 어제부터 고민하다 방법을 찾았고, 그 방법을 어떻게 구현할지 많은 시행착오를 거친 끝에 결국 풀었다.&lt;/p&gt;

&lt;p&gt;사실 맨 마지막에 내 생각이 확실한데 답이 자꾸 틀려서 다른사람 답을 찾아보긴 했지만, 그 답이 내가 생각한 그대로여서 여태껏 답 찾아본 문제들중 가장 치열하게 고민한 문제인 것 같다는 생각을 했다.&lt;/p&gt;

&lt;p&gt;그만큼 이번에는 답찾아서 풀었음에도 쪽팔리다는 생각이 들지 않았고.&lt;/p&gt;

&lt;p&gt;각설하고, 푸는 방법에 대해 설명해보자면 이 문제에서 각 자릿수가 몇자리수이냐는 아무 상관이 없다.&lt;/p&gt;

&lt;p&gt;가장 중요한 것은 1의자리 숫자가 무엇인지.&lt;/p&gt;

&lt;p&gt;N이 1일때, 2일때, 3일때의 경우들을 직접 구해보니 1의자리 숫자에 따라 다음 수가 영향을 받는다는 것을 알 수 있었다.&lt;/p&gt;

&lt;p&gt;자꾸 보다보니 N일때의 답 = (N-1일때의 답 * 2) - (N-1일때의 계단수 중 첫자리 숫자가 1인 것의 갯수) 라는 규칙을 찾은것같은데, 맞는지는 모르겠다.&lt;/p&gt;

&lt;p&gt;어떻게 구현할지 한참 고민하다 저 규칙대로 풀어보기 위해 우선 큐에 넣고 갱신해가면서 모든 경우를 다 돌려봤다.&lt;/p&gt;

&lt;p&gt;한 5분은 지나야 전체 답을 구할 수 있더라.&lt;/p&gt;

&lt;p&gt;이런 과정을 거치면서 이 문제를 어떻게하면 이전 N에서 얻은 답을 사용할수 있을지에 대해 중점적으로 고민해보았고, 결국 1의자리 숫자만이 영향을 미친다는 점을 찾기에 이르렀다.&lt;/p&gt;

&lt;p&gt;이 문제를 풀며 가장 고무적이었다고 생각했던 부분은 DP의 특성을 어떻게든 적용하기 위해 노력했다는 점.&lt;/p&gt;

&lt;p&gt;앞에서 구한 답을 어떻게 써먹을수 있는지 그 어느때보다 치열하게 고민한 것 같다.&lt;/p&gt;

&lt;p&gt;이 문제를 풀어낸 것이 앞으로 DP문제를 푸는데 있어 전환점이 되길!!&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 08/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int main(){
    int N;

    cin &amp;gt;&amp;gt; N;

    unsigned long long DP[101][11];
    bzero(DP, sizeof(DP));

    for(int i=1; i&amp;lt;10; i++){
        DP[1][i] = 1;
    }

    for(int i=2; i&amp;lt;=N; i++) {
        DP[i][0] = DP[i-1][1];
        for(int j=1; j&amp;lt;10; j++){
            DP[i][j] = (DP[i-1][j-1] + DP[i-1][j+1]) % 1000000000;
        }
    }

    unsigned long long sum = 0;
    for(int i=0; i&amp;lt;10; i++){
        sum += DP[N][i];
    }
    cout &amp;lt;&amp;lt; (sum % 1000000000) &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 10844번 Link: 10844번: 쉬운 계단 수</summary></entry><entry><title type="html">Swea_5215</title><link href="keithlee94.github.io/algorithm/SWEA_5215/" rel="alternate" type="text/html" title="Swea_5215" /><published>2019-01-07T00:00:00+09:00</published><updated>2019-01-07T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/SWEA_5215</id><content type="html" xml:base="keithlee94.github.io/algorithm/SWEA_5215/">&lt;h1 id=&quot;swea-5215번&quot;&gt;SWEA 5215번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AWgebGzaXfEDFAW0&amp;amp;contestProbId=AWT-lPB6dHUDFAVT&amp;amp;probBoxId=AWgebGzqXfIDFAW0+&amp;amp;type=PROBLEM&amp;amp;problemBoxTitle=Club+Problem+box+01&amp;amp;problemBoxCnt=++3+&quot;&gt;5215번: 햄버거 다이어트&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;완전탐색으로 최적의 조합을 구하는 문제.&lt;/p&gt;

&lt;p&gt;문제 보자마자 ‘이건 DFS쓰면 풀리겠구나’ 하는 생각은 들었다.&lt;/p&gt;

&lt;p&gt;이렇게 생각하고 풀었는데, DFS 구현에서 정말 많이 헤맸다.&lt;/p&gt;

&lt;p&gt;DFS랑 BFS는 그래도 구현방법을 다 외우고 있었다고 생각했었는데 벌써 다 까먹은 모양이다.&lt;/p&gt;

&lt;p&gt;예전에 코딩테스트 볼때도 확실하게 몰랐던거니 당연할수도.&lt;/p&gt;

&lt;p&gt;어떻게든 고쳐서 해보다 안되서 답 찾아서 풀었다.&lt;/p&gt;

&lt;p&gt;핵심은 DFS를 쓰긴 하는데 각각의 재료를 포함했을때와 포함하지 않았을때를 반드시 같이 돌려야 한다는것.&lt;/p&gt;

&lt;p&gt;제약조건에 따라 포함하거나 포함안하거나 따지면서 DFS 두번 돌리면 바로 풀린다.&lt;/p&gt;

&lt;p&gt;아직도 정말 갈길이 멀다고 생각했다.&lt;/p&gt;

&lt;p&gt;DFS, BFS는 자신있다고 생각했는데… 심지어 DFS로 풀어야된다는걸 알면서도 틀려서 더 자괴감 오진다.&lt;/p&gt;

&lt;h1 id=&quot;될때까지-하자&quot;&gt;될때까지 하자.&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 07/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int T;
int N, L;
int maximum = 0;

vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; base;

void DFS(int start, int calory, int score){
    if(start == N){
        maximum = maximum &amp;gt; score ? maximum : score;
        return;
    }
    if(calory + base[start].second &amp;lt;= L){
        DFS(start+1, calory+base[start].second, score+base[start].first); // start번째 재료 추가
    }
    DFS(start+1, calory, score); // start번째 재료 거름
}

int main(){
    cin &amp;gt;&amp;gt; T;

    for(int test=1; test&amp;lt;=T; test++){
        cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; L;

        for(int i=0; i&amp;lt;N; i++){
            int calory;
            int score;

            cin &amp;gt;&amp;gt; score &amp;gt;&amp;gt; calory;

            base.push_back(make_pair(score, calory));
        }

        DFS(0, 0, 0);

        cout &amp;lt;&amp;lt; '#' &amp;lt;&amp;lt; test &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; maximum &amp;lt;&amp;lt; '\n';
        while(!base.empty()){
            base.pop_back();
        }
        maximum = 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DFS" /><summary type="html">SWEA 5215번 Link: 5215번: 햄버거 다이어트</summary></entry><entry><title type="html">Swea_3307</title><link href="keithlee94.github.io/algorithm/SWEA_3307/" rel="alternate" type="text/html" title="Swea_3307" /><published>2019-01-07T00:00:00+09:00</published><updated>2019-01-07T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/SWEA_3307</id><content type="html" xml:base="keithlee94.github.io/algorithm/SWEA_3307/">&lt;h1 id=&quot;swea-3307번&quot;&gt;SWEA 3307번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AWgebGzaXfEDFAW0&amp;amp;contestProbId=AWBOKg-a6l0DFAWr&amp;amp;probBoxId=AWgebGzqXfIDFAW0+&amp;amp;type=PROBLEM&amp;amp;problemBoxTitle=Club+Problem+box+01&amp;amp;problemBoxCnt=++3+&quot;&gt;3307번: 최장 증가 부분 수열&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;완전탐색 문제인줄 알고 앞에서 썼던 DFS 써서 풀었다가 시간초과났던 문제.&lt;/p&gt;

&lt;p&gt;조합을 하는건 맞는데, DP로 풀었어야 풀리는 문제였다.&lt;/p&gt;

&lt;p&gt;최근에 DP 공부를 하고있었는데도 DP로 풀어야겠다는 생각은 여전히 들지 않았다.&lt;/p&gt;

&lt;p&gt;어찌어찌 테스트케이스는 맞출수 있도록 구현했는데, 제출해보니 한개도 못맞히더라.&lt;/p&gt;

&lt;p&gt;시험장가서 테스트케이스 맞히고도 탈락하는 경우가 왕왕 있다던데, 이런 경우인가 싶었다.&lt;/p&gt;

&lt;p&gt;덤으로 이딴 실력으로 시험장에 가지 않았다는 점이 천만다행.&lt;/p&gt;

&lt;p&gt;풀이에 대해 설명하자면, 우선 입력받은 숫자들 중 수열의 시작점을 for문을 통해 정한다.&lt;/p&gt;

&lt;p&gt;그 다음, 남은 숫자들을 택해서 증가수열을 만들고 그 증가수열의 길이를 갱신하며 최대값을 구하는 문제다.&lt;/p&gt;

&lt;p&gt;이를 위한 조건으로 2가지를 넣었다.&lt;/p&gt;

&lt;p&gt;첫째는 다음 숫자가 반드시 수열의 시작점보다 큰 숫자일 것.&lt;/p&gt;

&lt;p&gt;두번째는 증가수열의 길이가 증가하는 방향일 것.&lt;/p&gt;

&lt;p&gt;이 두가지를 만족하지 못하면 증가수열에 숫자를 포함하지 않고, 다음 숫자들을 계속 살펴보는 식이다.&lt;/p&gt;

&lt;p&gt;이 문제도 답보고 겨우 풀었는데, DP 문제에 대한 감을 살짝 잡은 것 같다.(아직 확실하진 않음)&lt;/p&gt;

&lt;p&gt;이런 최대값 찾는 DP문제의 경우 조건에 맞아 DP 배열의 값을 갱신한 후, 최대값을 갱신하는 작업을 반복하는 방식인 것 같다.&lt;/p&gt;

&lt;p&gt;너무 당연한 말을 한것 같지만, 이런 감 찾는데 정말 오래걸렸다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;아무튼&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;될때까지-하자&quot;&gt;될때까지 하자.&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 08/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;string.h&amp;gt;

using namespace std;

int T;

int main(){
    cin &amp;gt;&amp;gt; T;

    for(int test=1; test&amp;lt;=T; test++){
        int maximum = 0;
        int N;

        cin &amp;gt;&amp;gt; N;

        int numbers[N];
        int DP[N];

        for(int i=0; i&amp;lt;N; i++){
            cin &amp;gt;&amp;gt; numbers[i];
        }

        bzero(DP, sizeof(DP));

        for(int i=0; i&amp;lt;N; i++){
            for(int j=i+1; j&amp;lt;N; j++){
                if(numbers[j] &amp;lt; numbers[i]) continue;
                if(DP[j] &amp;gt;= DP[i] + 1) continue;
                DP[j] = DP[i] + 1; // 증가수열이면서 수열 count가 증가한다면 1 더해줌.
                maximum = max(maximum, DP[j]); // 최대값 갱신.
            }
        }

        cout &amp;lt;&amp;lt; '#' &amp;lt;&amp;lt; test &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; maximum+1 &amp;lt;&amp;lt; '\n';
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">SWEA 3307번 Link: 3307번: 최장 증가 부분 수열</summary></entry><entry><title type="html">Swea_1289</title><link href="keithlee94.github.io/algorithm/SWEA_1289/" rel="alternate" type="text/html" title="Swea_1289" /><published>2019-01-07T00:00:00+09:00</published><updated>2019-01-07T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/SWEA_1289</id><content type="html" xml:base="keithlee94.github.io/algorithm/SWEA_1289/">&lt;h1 id=&quot;swea-1289번&quot;&gt;SWEA 1289번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AWgebGzaXfEDFAW0&amp;amp;contestProbId=AV19AcoKI9sCFAZN&amp;amp;probBoxId=AWgebGzqXfIDFAW0+&amp;amp;type=PROBLEM&amp;amp;problemBoxTitle=Club+Problem+box+01&amp;amp;problemBoxCnt=++3+&quot;&gt;1289번: 원재의 메모리 복구하기&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;무난하게 풀었던 구현 문제.&lt;/p&gt;

&lt;p&gt;string 처리에서 살짝 헤맨것 말고는 무난하게 풀었다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 07/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string.h&amp;gt;

using namespace std;

int T;

int main(){
    cin &amp;gt;&amp;gt; T;

    string input = &quot;&quot;;

    for(int test=1; test&amp;lt;=T; test++){
        int count = 0;
        string modified = &quot;&quot;;

        cin &amp;gt;&amp;gt; input;

        for(int i=0; i&amp;lt;input.length(); i++){
            modified.push_back('0');
        }

        for(int i=0; i&amp;lt;input.length(); i++){
            if(modified[i] != input[i]){
                if(input[i] == '0'){
                    for(int j=i; j&amp;lt;modified.length(); j++){
                        modified[j] = '0';
                    }
                }
                else if(input[i] == '1'){
                    for(int j=i; j&amp;lt;modified.length(); j++){
                        modified[j] = '1';
                    }
                }
                count++;
            }
        }

        cout &amp;lt;&amp;lt; '#' &amp;lt;&amp;lt; test &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; count &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Realization" /><summary type="html">SWEA 1289번 Link: 1289번: 원재의 메모리 복구하기</summary></entry><entry><title type="html">1463</title><link href="keithlee94.github.io/algorithm/1463/" rel="alternate" type="text/html" title="1463" /><published>2019-01-07T00:00:00+09:00</published><updated>2019-01-07T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1463</id><content type="html" xml:base="keithlee94.github.io/algorithm/1463/">&lt;h1 id=&quot;백준-1463번&quot;&gt;백준 1463번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1463&quot;&gt;1463번: 1로 만들기&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;오늘도 내힘으로 푸는데 실패.&lt;/p&gt;

&lt;p&gt;이 문제도 직전에 풀었던 계단문제처럼 점화식이 가장 중요했다.&lt;/p&gt;

&lt;p&gt;주어진 조건을 곧이곧대로 썼다가 답없는 상황이 나왔다.&lt;/p&gt;

&lt;p&gt;가장 먼저 입력된 수를 3으로 나눠떨어지는지 검사하고 나눠떨어지면 3으로 나누는 것을 첫번째 조건으로 넣었고&lt;/p&gt;

&lt;p&gt;3으로 나눠떨어지지 않으면 2로 나눠떨어지는지 검사하고 나눠떨어지면 2로 나누는 것을 두번째 조건으로 넣었다.&lt;/p&gt;

&lt;p&gt;이 두가지를 만족하지 않을때 1을 빼는 것으로 3가지 조건을 넣었다.&lt;/p&gt;

&lt;p&gt;도무지 어떻게 더 나갈지 모르겠어서 예전 답을 다시 찾아봤다.&lt;/p&gt;

&lt;p&gt;예전 답도 구글링해서 답 찾아보고 풀었는데, 1년동안 실력이 전혀 안늘어난 느낌이다.&lt;/p&gt;

&lt;p&gt;정답은 우선 1을 뺀 다음, 3으로 나눠떨어지면 3으로 나눴을때와 1을 뺐을때의 DP를 비교하는 것이었다.&lt;/p&gt;

&lt;p&gt;3으로 나눠떨어지지 않을 경우, 2로 나눠떨어지면 2로 나눴을때와 1을 뺐을때의 DP를 비교한다.&lt;/p&gt;

&lt;p&gt;나머지 경우는 당연히 1을 뺀 값이 DP에 들어간다.&lt;/p&gt;

&lt;p&gt;오늘로 DP에서 5문제를 풀고있는데, 문제마다 매번 다른 개념인것 같은 느낌이다.&lt;/p&gt;

&lt;p&gt;DP 문제 전반에 걸칠 수 있는 개념이 안잡힌 느낌. 첫술에 배부를수는 당연히 없지만 이대로 갔을때 실력이 늘긴 할지, DP에 대한 접근 방법을 제대로 파악할 수 있긴 할지 매우 걱정된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 07/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string.h&amp;gt;

using namespace std;

int min(int a, int b){
    return a &amp;gt; b ? b : a;
}

int main(){
    int N;
    int DP[1000000];

    cin &amp;gt;&amp;gt; N;

    bzero(DP, sizeof(DP));

    for(int i=2; i&amp;lt;=N; i++){
        DP[i] = DP[i-1] + 1; // 기본적으로 1 빼준다.

        if(i % 2 == 0){
            DP[i] = min(DP[i], DP[i/2] + 1); // 2로 나눠떨어지면 2로 나눴을때와 1뺐을때를 비교한다.
        }
        if(i % 3 == 0){
            DP[i] = min(DP[i], DP[i/3] + 1); // 3으로 나눠떨어지면 3으로 나눴을때와 1뺐을때를 비교한다.
        }
    }

    cout &amp;lt;&amp;lt; DP[N] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 1463번 Link: 1463번: 1로 만들기</summary></entry><entry><title type="html">4th week summary</title><link href="keithlee94.github.io/java/4th-Week-Summary/" rel="alternate" type="text/html" title="4th week summary" /><published>2019-01-04T00:00:00+09:00</published><updated>2019-01-04T00:00:00+09:00</updated><id>keithlee94.github.io/java/4th%20Week%20Summary</id><content type="html" xml:base="keithlee94.github.io/java/4th-Week-Summary/">&lt;h1 id=&quot;java-스터디-내용-정리&quot;&gt;Java 스터디 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;project-package-분리-이유&quot;&gt;Project, Package 분리 이유&lt;/h1&gt;
&lt;p&gt;프로젝트의 각 기능을 쪼개기 위해 패키지 사용.&lt;/p&gt;

&lt;p&gt;논리적으로 따로 나눠 작업하기 위해 분리하는 경우가 대다수이다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java의-특징&quot;&gt;Java의 특징&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;객체지향
    &lt;ul&gt;
      &lt;li&gt;시스템의 기본 구성단위는 &lt;strong&gt;객체(Object)&lt;/strong&gt; 이다.&lt;/li&gt;
      &lt;li&gt;객체: 일종의 부품 역할.&lt;/li&gt;
      &lt;li&gt;여러 부품들을 모아 조립하듯이 프로그램을 완성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;플랫폼 독립적
    &lt;ul&gt;
      &lt;li&gt;하드웨어, OS와 상관없이 모든 환경에서 동작 가능.&lt;/li&gt;
      &lt;li&gt;이유: JVM 위에서 작동하므로.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;분산 프로그래밍: 원격 접속 가능.&lt;/li&gt;
  &lt;li&gt;멀티스레드&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java-컴파일-과정&quot;&gt;Java 컴파일 과정&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;소스코드 작성: (…).java 파일 생성.&lt;/li&gt;
  &lt;li&gt;컴파일
    &lt;ul&gt;
      &lt;li&gt;명령어: javac (…).java
        &lt;ul&gt;
          &lt;li&gt;javac -d …: 패키지가 있을 경우 자동으로 패키지 폴더를 생성하며 컴파일.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;JVM이 인식 가능한 byte code로 번역하는 과정.&lt;/li&gt;
      &lt;li&gt;결과: Bytecode 생성 - (…).class 파일 생성.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실행
    &lt;ul&gt;
      &lt;li&gt;명령어: java (…)&lt;/li&gt;
      &lt;li&gt;JVM 위에서 실행됨.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/23356503/50677469-654b6480-103d-11e9-9b3c-e330a67fba48.jpeg&quot; alt=&quot;java compile&quot; /&gt;&lt;/p&gt;

&lt;p&gt;C의 경우 실행파일을 다른 환경에서 실행시키면 실행 안됨.&lt;/p&gt;

&lt;p&gt;Java의 경우 JVM이 존재하므로 다른 환경에서 실행 가능함.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;primitive-data-type&quot;&gt;Primitive Data Type&lt;/h1&gt;
&lt;p&gt;기본적인 값을 기억하는 type.&lt;/p&gt;

&lt;p&gt;1 byte = 8 bit&lt;/p&gt;

&lt;p&gt;char = 16 bit = 2 byte&lt;/p&gt;

&lt;p&gt;int = 32 bit = 4 byte&lt;/p&gt;

&lt;p&gt;float = 32 bit = 4 byte&lt;/p&gt;

&lt;p&gt;double = 64 bit = 8 byte&lt;/p&gt;

&lt;p&gt;long = 64 bit = 8 byte&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;reference-data-type&quot;&gt;Reference Data Type&lt;/h1&gt;
&lt;p&gt;객체의 참조값을 기억하는 type.&lt;/p&gt;

&lt;p&gt;class, interface, 배열 등.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;String: class이므로 Reference Type이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;literal&quot;&gt;Literal&lt;/h1&gt;
&lt;p&gt;값 자체.&lt;/p&gt;

&lt;p&gt;예: 3.14, 10, ‘C’, false, …&lt;/p&gt;

&lt;p&gt;정수 리터럴 = 4바이트에 저장됨.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;논리연산자&quot;&gt;논리연산자&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&amp;amp;&amp;amp; 연산자: 앞조건이 false면 뒤에 오는 조건 확인하지 않고 연산 종료.&lt;/li&gt;
  &lt;li&gt;&amp;amp; 연산자: 앞조건이 false여도 뒤에 오는 조건을 확인한 후 연산 종료.&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;,&lt;/td&gt;
          &lt;td&gt;연산자도 동일함.&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;3항연산자&quot;&gt;3항연산자&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(x &amp;gt; y) ? x : y =&amp;gt; 실행결과: x가 y보다 크면 x, 작거나 같으면 y가 된다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;for--each&quot;&gt;for ~ each&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int sum = 0;
int[] su = {24, 6, 5, 36, 36, 65, 245, 56, 3, 64};

for(int s: su){
    System.out.println(s);
    sum += s;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;실행결과: sum에는 su 배열의 모든 숫자를 더한 값이 저장되고, su 배열의 모든 원소가 한번씩 출력된다.&lt;/p&gt;

&lt;p&gt;=&amp;gt; 배열 내 모든 원소에 한번씩 접근한다.(파이썬과 유사함)&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;error-exception&quot;&gt;Error, Exception&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Error
    &lt;ul&gt;
      &lt;li&gt;복구 불가능&lt;/li&gt;
      &lt;li&gt;프로그램이 비정상적으로 종료됨.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Exception
    &lt;ul&gt;
      &lt;li&gt;일종의 가벼운 에러&lt;/li&gt;
      &lt;li&gt;프로그램상으로 수정 가능함.&lt;/li&gt;
      &lt;li&gt;Java가 해결 방법을 알려줄 수 있음.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;배열-기본값&quot;&gt;배열 기본값&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;배열의 type에 따라 다르게 배열 생성시 기본값으로 자동으로 채워진다.&lt;/li&gt;
  &lt;li&gt;int형: 0&lt;/li&gt;
  &lt;li&gt;boolean형: false&lt;/li&gt;
  &lt;li&gt;double형: 0.0&lt;/li&gt;
  &lt;li&gt;String형: null
    &lt;ul&gt;
      &lt;li&gt;참조형 type의 배열의 기본값은 항상 null이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;main메소드의-args-사용법&quot;&gt;main메소드의 args 사용법&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;Run Configuration 설정&lt;/li&gt;
  &lt;li&gt;Arguments -&amp;gt; Program arguments -&amp;gt; ${string-prompt} 설정.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;new-키워드&quot;&gt;new 키워드&lt;/h1&gt;
&lt;p&gt;객체를 만들때 사용하는 키워드.&lt;/p&gt;

&lt;h1 id=&quot;method&quot;&gt;method&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;C의 함수와 같다.&lt;/li&gt;
  &lt;li&gt;클래스 내에서 객체가 가져야 할 기능을 정의.&lt;/li&gt;
  &lt;li&gt;독립적인 기능들을 분리하여 재사용 가능하도록 하기 위해 사용.&lt;/li&gt;
  &lt;li&gt;return type, method 이름, parameter list가 반드시 있어야 한다.&lt;/li&gt;
  &lt;li&gt;method 내에 method 정의 불가능.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;arraycopy&quot;&gt;arraycopy()&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;배열 복사 함수.&lt;/li&gt;
  &lt;li&gt;System.arraycopy(소스배열, 소스배열의 시작위치, 목적배열, 목적배열의 시작위치, 길이);&lt;/li&gt;
  &lt;li&gt;작은 배열일 경우 통상적인 반복문이 더 효율적.&lt;/li&gt;
  &lt;li&gt;배열이 클때 사용시 효율적이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;다차원-배열-길이&quot;&gt;다차원 배열 길이&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;su = new int[5][3];
su2 = new int[3];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;su.length: 5&lt;/p&gt;

&lt;p&gt;su[0].length: 3&lt;/p&gt;

&lt;p&gt;su2.length: 3&lt;/p&gt;

&lt;p&gt;=&amp;gt; 가장 첫번째 칸의 숫자가 배열의 길이.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;return&quot;&gt;return&lt;/h1&gt;
&lt;p&gt;문장의 실행을 그자리에서 멈춘다.&lt;/p&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Java" /><summary type="html">Java 스터디 내용 정리</summary></entry><entry><title type="html">2579</title><link href="keithlee94.github.io/algorithm/2579/" rel="alternate" type="text/html" title="2579" /><published>2019-01-04T00:00:00+09:00</published><updated>2019-01-04T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/2579</id><content type="html" xml:base="keithlee94.github.io/algorithm/2579/">&lt;h1 id=&quot;백준-2579번&quot;&gt;백준 2579번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2579&quot;&gt;2579번: 계단 오르기&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;오늘도 DP문제다.&lt;/p&gt;

&lt;p&gt;그리고 오늘도 내힘으로 푸는데 실패.&lt;/p&gt;

&lt;p&gt;앞선 두문제와 비슷하면서도 달랐는데, 이번 문제를 풀수 있느냐 없느냐는 문제를 보고 조건을 이해하여 점화식을 세울 수 있는지였다.&lt;/p&gt;

&lt;p&gt;물론 나는 점화식 못세워서 예전 코드 보고, 검색해서 그제서야 이해해서 풀었다.&lt;/p&gt;

&lt;p&gt;점화식 세우는 방법은 우선 DP배열의 3번째까지 채우는 방법과 동일했다.&lt;/p&gt;

&lt;p&gt;그전에 이 문제에서 DP 배열의 의미를 이해할 필요가 있었다.&lt;/p&gt;

&lt;p&gt;DP[N]이란 N번째 계단을 밟았음을 의미한다.&lt;/p&gt;

&lt;p&gt;이렇게 이해하고 시작해보면 DP[1]은 첫번째 계단을 밟은것이므로 score[1]이 된다.&lt;/p&gt;

&lt;p&gt;DP[2]는 첫번째 계단, 두번째 계단을 둘 다 밟았을때와 두번째 계단만 밟았을때의 점수를 비교하여 큰 값이 곧 DP[2]의 값이 된다.&lt;/p&gt;

&lt;p&gt;DP[3]은 조건에 의해 세 계단을 연속으로 밟을 수 없고, 한번에 최대 2개의 계단만 오를 수 있으므로 첫번째 계단과 세번째 계단을 밟았을 때, 두번째 계단과 세번째 계단을 밟았을때의 점수를 비교하여 큰 값이 DP[3]이 된다.&lt;/p&gt;

&lt;p&gt;DP[4]를 생각해보자. DP[4]는 첫번째 계단, 세번째 계단, 네번째 계단의 점수를 더한 값과 첫번째 계단, 두번째 계단, 네번째 계단의 점수를 더한 값을 비교하여 더 큰 값이 DP[4]이다.&lt;/p&gt;

&lt;p&gt;이는 곧 DP[1] + score[3] + score[4], DP[2] + score[4]를 비교하는 것과 같다.&lt;/p&gt;

&lt;p&gt;이를 토대로 점화식을 세워 보면, DP[N] = max(DP[N-3] + score[N-1] + score[N], DP[N-2] + score[N])이라는 점화식을 얻을 수 있다.&lt;/p&gt;

&lt;p&gt;이 점화식대로 풀면 풀리는 문제다.&lt;/p&gt;

&lt;p&gt;항상 느끼는건데 점화식 세우는게 정말 너무 어렵다. 규칙은 나름대로 찾은것 같지만 뭔가 나사 하나씩은 꼭 빠져있다는 생각이 든다.&lt;/p&gt;

&lt;p&gt;푸는방법 까먹을때쯤 한번 더 풀어봐야 할 문제인것 같다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 04/01/2019.
//

#include &amp;lt;iostream&amp;gt;

using namespace std;

int N;

int max(int a, int b){
    return (a &amp;gt; b) ? a : b;
}

int main(){
    cin &amp;gt;&amp;gt; N;

    int DP[N+1];
    int score[N+1];

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; score[i];
    }

    DP[1] = score[1];
    DP[2] = max(score[1] + score[2], score[2]);
    DP[3] = max(score[1] + score[3], score[2] + score[3]);

    for(int i=4; i&amp;lt;=N; i++){
        DP[i] = max(DP[i-2] + score[i], DP[i-3] + score[i] + score[i-1]);
    }

    cout &amp;lt;&amp;lt; DP[N] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 2579번 Link: 2579번: 계단 오르기</summary></entry><entry><title type="html">1932</title><link href="keithlee94.github.io/algorithm/1932/" rel="alternate" type="text/html" title="1932" /><published>2019-01-03T00:00:00+09:00</published><updated>2019-01-03T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1932</id><content type="html" xml:base="keithlee94.github.io/algorithm/1932/">&lt;h1 id=&quot;백준-1932번&quot;&gt;백준 1932번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1932&quot;&gt;1932번: 정수 삼각형&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;어제 풀었던 RGB거리와 비슷한 유형의 DP 문제.&lt;/p&gt;

&lt;p&gt;다른점이 있다면 제한조건인데, 3가지 경우를 고려했어야 했던 RGB 거리와 달리 삼각형을 이루는 정수들의 왼쪽 대각선, 오른쪽 대각선의 2가지 경우로만 이동 가능하므로 오히려 조건은 완화되었다.&lt;/p&gt;

&lt;p&gt;딱 문제 보고나서 ‘어 이거 어제 풀었던거랑 비슷한데’ 라는 생각으로 시작했다.&lt;/p&gt;

&lt;p&gt;결론부터 말하면 못풀어서 답보고 이해했는데, 접근방법이 아예 잘못되었다.&lt;/p&gt;

&lt;p&gt;조건에서 주어졌듯이 2개의 이전 결과값을 비교하고 현재 삼각형 위치의 숫자를 더하면 되는거였는데, 일단 이 조건을 무시하고 최대값만 다 찾았다가 1차로 망했다.&lt;/p&gt;

&lt;p&gt;잘못생각했다는걸 알아차리고 다른 방법을 생각해봤는데, 이것도 틀렸다.&lt;/p&gt;

&lt;p&gt;뭔지 대충 설명하자면 최대값을 가질때의 배열 인덱스를 따로 받아두고 이 인덱스를 기준으로 다음 최대값을 찾는 방식.&lt;/p&gt;

&lt;p&gt;DP에 대해 완벽히 이해하고 있는건 아닌것 같다.&lt;/p&gt;

&lt;p&gt;예전 계산 결과 가져다 쓰는 문제구나 하는 느낌은 오는데, 예전 계산 결과를 어떤식으로 저장할 것이며 어떻게 가져다 쓸것인지에 대해 생각해내는 부분이 부족한 것 같다.&lt;/p&gt;

&lt;p&gt;문제 보고도 뭔소린가 싶었던 옛날에 비해서는 많이 나아진 편이지만 아직도 갈길이 멀다…&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 03/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;

int n;
int maximum = 0;

int max(int a, int b){
    return (a &amp;gt; b) ? a : b;
}

int main(){
    cin &amp;gt;&amp;gt; n;

    int DP[n+1][n+1];
    int tree[n+1][n+1];

    bzero(DP, sizeof(DP));
    bzero(tree, sizeof(tree));

    int inputNum;

    for(int i=1; i&amp;lt;=n; i++){
        for(int j=1; j&amp;lt;=i; j++){
            cin &amp;gt;&amp;gt; inputNum;
            tree[i][j] = inputNum;
        }
    }

    for(int i=1; i&amp;lt;=n; i++){
        for(int j=1; j&amp;lt;=i; j++){
            DP[i][j] = max(DP[i-1][j-1], DP[i-1][j]) + tree[i][j];

            if(maximum &amp;lt; DP[i][j]){
                maximum = DP[i][j];
            }
        }
    }

    cout &amp;lt;&amp;lt; maximum &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 1932번 Link: 1932번: 정수 삼각형</summary></entry><entry><title type="html">1149</title><link href="keithlee94.github.io/algorithm/1149/" rel="alternate" type="text/html" title="1149" /><published>2019-01-02T00:00:00+09:00</published><updated>2019-01-02T00:00:00+09:00</updated><id>keithlee94.github.io/algorithm/1149</id><content type="html" xml:base="keithlee94.github.io/algorithm/1149/">&lt;h1 id=&quot;백준-1149번&quot;&gt;백준 1149번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1149&quot;&gt;1149번: RGB 거리&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;마을의 집 갯수와 각 집을 빨강, 초록, 파랑으로 각각 칠하는데 드는 비용이 입력으로 주어졌을때 마을의 모든 집을 칠하는 최저 비용을 구하는 문제.&lt;/p&gt;

&lt;p&gt;이웃하는 집들은 같은 색으로 칠할 수 없다는 조건도 붙었다.&lt;/p&gt;

&lt;p&gt;작년에 답보고 풀었던 기억이 나는 문제. 이번에는 꼭 내 힘으로 풀어내리라 결심하고 풀어보았다.&lt;/p&gt;

&lt;p&gt;우선 이웃하는 집들이 같은 색이 될수 없다는 조건을 단순화하여 앞집이랑만 다른 색이면 되지 않나? 라는 생각으로 풀었다.&lt;/p&gt;

&lt;p&gt;틀리고 한참 고민하고서야 왜 틀렸는지 알게 되었다. 반드시 최저값만으로 구성된 조합이 존재하지 않는 경우가 있다는 것.&lt;/p&gt;

&lt;p&gt;거꾸로도 풀어보고 어떻게든 풀어보려 애써봤는데 결국 안풀려서 예전 답을 보고 풀었다…&lt;/p&gt;

&lt;p&gt;생각보다 매우 단순했는데, 처음 칠하는 비용을 0으로 초기화한 다음 모든 경우를 따져가며 답을 구하는 방식이었다.&lt;/p&gt;

&lt;p&gt;예를 들면 DP[i][0]은 DP[i-1][1]과 DP[i-1][2] 중 작은 값에다가 칠하는 비용인 price[i][0]을 더하는 식.&lt;/p&gt;

&lt;p&gt;즉 DP[i][0]은 i번째 집을 0번째 색으로 칠한다는 것을 의미한다. 당연히 앞집이랑은 색이 겹칠 일이 없다.&lt;/p&gt;

&lt;p&gt;온갖 방법 다 생각해보다 답을 봤는데 정말 간단하게 풀려서 허무했다;;;&lt;/p&gt;

&lt;p&gt;2시간정도 고민해봤지만 못풀겠어서 결국 포기했던 점이 아쉽지만, 이러저러한 방법을 최대한 시도해 본 점은 나름 만족스럽다.&lt;/p&gt;

&lt;p&gt;다음에 푸는 문제들은 이런 고민끝에 끝까지 풀어낼 수 있길!!&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;내가-짰다가-틀린-코드&quot;&gt;내가 짰다가 틀린 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 02/01/2019.
//

#include &amp;lt;iostream&amp;gt;

using namespace std;

int N;

int main(){
    cin &amp;gt;&amp;gt; N;

    int price[N][3];
    int DP[N][2];

    for(int i=0; i&amp;lt;N; i++){
        cin &amp;gt;&amp;gt; price[i][0] &amp;gt;&amp;gt; price[i][1] &amp;gt;&amp;gt; price[i][2];
    }

    for(int i=0; i&amp;lt;N; i++){
        int min = 1001;

        if(i == 0){
            for(int j=0; j&amp;lt;3; j++){
                if(min &amp;gt; price[0][j]){
                    min = price[0][j];
                    DP[0][0] = min;
                    DP[0][1] = j;
                }
            }
        }
        else{
            for(int j=0; j&amp;lt;3; j++){
                if(j != DP[i-1][1]){
                    if(min + price[i][j] &amp;gt; DP[i-1][0] + price[i][j]){
                        min = price[i][j];
                        DP[i][0] = min + DP[i-1][0];
                        DP[i][1] = j;
                    }
                }
            }
        }
    }

    cout &amp;lt;&amp;lt; DP[N-1][0] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 02/01/2019.
//

#include &amp;lt;iostream&amp;gt;

using namespace std;

int N;

int min(int a, int b){
    return (a &amp;gt; b) ? b : a;
}

int main(){
    cin &amp;gt;&amp;gt; N;

    int price[N+1][3];
    int DP[N+1][3];

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; price[i][0] &amp;gt;&amp;gt; price[i][1] &amp;gt;&amp;gt; price[i][2];
    }

    price[0][0] = price[0][1] = price[0][2] = 0;
    DP[0][0] = DP[0][1] = DP[0][2] = 0;

    for(int i=1; i&amp;lt;N+1; i++){
        DP[i][0] = min(DP[i-1][1], DP[i-1][2]) + price[i][0];
        DP[i][1] = min(DP[i-1][0], DP[i-1][2]) + price[i][1];
        DP[i][2] = min(DP[i-1][0], DP[i-1][1]) + price[i][2];
    }

    cout &amp;lt;&amp;lt; min(min(DP[N][0], DP[N][1]), DP[N][2]) &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 1149번 Link: 1149번: RGB 거리</summary></entry></feed>