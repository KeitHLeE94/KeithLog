<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-01-19T18:04:42+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">KeithLog</title><subtitle>SSAFY 교육내용, 알고리즘 문제풀이 정리하여 업로드할 블로그</subtitle><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><entry><title type="html">6th week summary</title><link href="http://localhost:4000/java/6th-Week-Summary/" rel="alternate" type="text/html" title="6th week summary" /><published>2019-01-19T00:00:00+09:00</published><updated>2019-01-19T00:00:00+09:00</updated><id>http://localhost:4000/java/6th%20Week%20Summary</id><content type="html" xml:base="http://localhost:4000/java/6th-Week-Summary/">&lt;h1 id=&quot;알고리즘-스터디-내용-정리&quot;&gt;알고리즘 스터디 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;자료구조&quot;&gt;자료구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;선형
    &lt;ul&gt;
      &lt;li&gt;이전, 이후 데이터가 1:1 관계이다.&lt;/li&gt;
      &lt;li&gt;특정 데이터의 다음에 올 데이터가 무엇인지 확실히 알 수 있다.(예: 배열, 연결리스트)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비선형
    &lt;ul&gt;
      &lt;li&gt;이전, 이후 데이터가 1:다 or 다:다 관계이다.&lt;/li&gt;
      &lt;li&gt;특정 데이터의 다음에 올 데이터가 무엇인지 확실하게 알 수 없다.&lt;/li&gt;
      &lt;li&gt;전체를 빠짐없이 순회하며 한번씩만 방문하는 것이 관건(예: 그래프)
        &lt;ul&gt;
          &lt;li&gt;그래프
            &lt;ul&gt;
              &lt;li&gt;트리: 사이클이 없어야 한다.&lt;/li&gt;
              &lt;li&gt;트리를 제외한 나머지: 사이클이 있을 수 있다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;검색&quot;&gt;검색&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;순차 검색
    &lt;ul&gt;
      &lt;li&gt;O(n) -&amp;gt; Best: O(1), Worst: O(n), Average: O(n/2) = O(n)&lt;/li&gt;
      &lt;li&gt;정렬 여부와 상관없이 사용 가능.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이진 검색
    &lt;ul&gt;
      &lt;li&gt;O(log n)&lt;/li&gt;
      &lt;li&gt;Divide &amp;amp; Conquer&lt;/li&gt;
      &lt;li&gt;자료가 정렬된 상태에서만 사용 가능.&lt;/li&gt;
      &lt;li&gt;데이터 양이 많을수록 유리함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정렬되지-않은-데이터-검색&quot;&gt;정렬되지 않은 데이터 검색&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;이진 검색
    &lt;ol&gt;
      &lt;li&gt;정렬&lt;/li&gt;
      &lt;li&gt;이진검색
        &lt;ul&gt;
          &lt;li&gt;O(n^2) + O(log n) = O(n^2) 소요.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;순차검색: O(n)&lt;/li&gt;
  &lt;li&gt;결론: 정렬 알고리즘에서 이미 순차검색보다 성능이 떨어지므로 정렬되지 않은 데이터에 대해서는 순차검색을 사용하는 것이 유리하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java-메모리-영역&quot;&gt;Java 메모리 영역&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Call Stack: 자동으로 초기화되지 않음.&lt;/li&gt;
  &lt;li&gt;Heap: 자동으로 초기화됨.&lt;/li&gt;
  &lt;li&gt;Method Area: 자동으로 초기화됨.&lt;/li&gt;
  &lt;li&gt;Constant Pool: Method Area에 포함됨. 상수를 재활용하기 위해 존재함.(여러개의 상수가 있어도 해싱하여 저장되므로 검색시간이 느려지는 일이 없다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;string-선언별-차이점&quot;&gt;String 선언별 차이점&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;String str1 = “abc”; =&amp;gt; Constant Pool에 생성된다.&lt;/li&gt;
  &lt;li&gt;String str2 = new String(“abc”); =&amp;gt; Heap에 생성된다.&lt;/li&gt;
  &lt;li&gt;String str3 = “abc”; =&amp;gt; str1과 같은 주소가 할당된다.&lt;/li&gt;
  &lt;li&gt;str1, str3처럼 기본형으로 만들 경우 Constant Pool에 저장되고, 둘의 값이 같을 경우 같은 주소가 할당된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;stringtokenizer&quot;&gt;StringTokenizer&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;문자열을 쪼갤때 사용한다.&lt;/li&gt;
  &lt;li&gt;정규식을 인자로 허용하지 않으므로 String.split()보다 속도가 빠르다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;stringbuilder-stringbuffer&quot;&gt;StringBuilder, StringBuffer&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;문자열 저장시 사용.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;objectequals&quot;&gt;Object.equals()&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 자식 클래스에서 사용할지 모르므로 == 연산자로 구현되어 있다.&lt;/li&gt;
  &lt;li&gt;내용 비교하려면: 자식 클래스에서 오버라이딩하여 사용해야 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;dp와-divide--conquer&quot;&gt;DP와 Divide &amp;amp; Conquer&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Divide &amp;amp; Conquer: 작은 문제를 해결하여 큰 문제를 해결하는 기법.&lt;/li&gt;
  &lt;li&gt;DP: Divide &amp;amp; Conquer + Memoization. 작은 문제를 해결하고 이를 따로 저장해둠으로써 똑같은 작은 문제를 다시 풀게 되어 발생하는 시간 낭비를 줄일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java-스터디-내용-정리&quot;&gt;Java 스터디 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;자주-오버라이딩하는-함수들&quot;&gt;자주 오버라이딩하는 함수들&lt;/h1&gt;
&lt;h2 id=&quot;1-tostring&quot;&gt;1. toString()&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 오버라이딩 했을 경우: System.out.println(객체); 실행시 객체의 클래스에서 재정의된 toString()이 실행됨.
- 오버라이딩 안했을 경우: System.out.println(객체); 실행시 주소값만 출력된다 - Object 클래스의 toString()은 객체의 주소값만 돌려주므로.
- 출력함수의 인자로 객체를 넣을 시 자동으로 toString()이 호출된다. ## 2. hashCode()
- 같은 객체인지 확인할 때 사용. ## 3. equals()
- 두 객체의 내용물이 같은지 확인할 때 사용.
- Object.equals(): 단순 객체 주소 비교.
- String.equals(): Object.equals()를 오버라이딩하여 문자 하나씩 비교하여 일치하는지 확인.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;string-객체의-특징&quot;&gt;String 객체의 특징&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;String 클래스의 메소드들은 원본 데이터를 바꾸지 않는다.&lt;/li&gt;
  &lt;li&gt;String은 final 상수이므로 내용을 바꿀때마다 새로운 데이터가 heap에 쌓인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;사용-제한자&quot;&gt;사용 제한자&lt;/h1&gt;
&lt;h2 id=&quot;1-final&quot;&gt;1. final&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- class, method, variable에 붙일 수 있다.
- class앞에 붙으면: 상속 불가. 그 클래스 안의 모든 method, field는 내용을 변경할 수 없다.
- method앞에 붙으면: 오버라이딩 불가, 오버로딩은 가능.
- field앞에 붙으면: 값 수정 불가.(변수가 상수로 변한다.)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-static&quot;&gt;2. static&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- member변수, member메소드, block에 붙일 수 있다.
- static이 붙은 모든 것들은 main 메소드 실행 전에 Class Area에 한개씩만 생성된다.
    - 실행 전에 만들어진다.
    - 컴파일이 완료된 시점에 생성되므로 따로 객체를 만들 필요가 없다.
- static이 없는 모든 것들은 main 메소드 실행 후 Heap에 생성된다.
    - 실행 후에 만들어진다.
- static variable = class variable
- non-static variable = instance variable
- 다른 클래스에서도 사용 가능: class이름.변수이름 or class이름.메소드이름 으로 사용 가능.
- static block: main 메소드보다 우선순위가 높다.
    - main 메소드보다 먼저 실행된다.
    - static block간 우선순위는 코드 내 순서와 같다.
- static 메소드 내에서는 this, super 키워드를 사용할 수 없다.
    - 이유: this, super 키워드는 객체가 있을때만 사용 가능하다.
    - static 메소드는 객체가 생성되기 전에 실행되므로 this, super 키워드를 사용할 수 없다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-abstract&quot;&gt;3. abstract&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- abstract: 추상적인, 구체적이지 않은, 완성되지 않은.
- abstract 클래스: 클래스 내에 abstract 메소드가 존재한다.
- abstract 메소드: 바디가 없는 미완성 메소드. abstract 클래스 내에만 정의 가능.(C의 prototype과 같다.)
- concrete 메소드: 바디가 있는 완성된 메소드. abstract 클래스 내에도 정의 가능.
- abstract 메소드가 있으면 객체 생성 불가능.
    - 미완성 메소드가 있다 = 미완성 클래스이다.
    - 자식 클래스에서 상속받아 완성시켜야 객체 생성이 가능하다.(자식 클래스가 오버라이딩해야 한다.)
- 장점: 상속관계로 묶여있으므로 여러 종류의 객체들을 부모 타입으로 묶어 하나의 자료구조에 넣고 handling할 수 있다.
- 용도
    - 타입을 물려주는 용도로 빈 껍데기만 미리 만들어놓는다.
    - 객체 생성을 막는 용도로도 사용 가능하다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;interface&quot;&gt;interface&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;추상 클래스와 유사하다.&lt;/li&gt;
  &lt;li&gt;시작 키워드가 class가 아닌 interface이다.(용도는 추상 클래스와 같이 타입을 물려주는 용도이다.)&lt;/li&gt;
  &lt;li&gt;상수와 추상 메소드들로만 구성되어 있다: concrete 메소드를 포함할 수 없다.&lt;/li&gt;
  &lt;li&gt;내부 메소드에 별도로 abstact를 붙일 필요가 없다: interface 자체가 미완성이므로 포함하는 모든 메소드들에 자동으로 public abstract 키워드가 붙는다.&lt;/li&gt;
  &lt;li&gt;내부 field에는 자동으로 static final 키워드가 붙는다: 값을 변경할 수 없다.&lt;/li&gt;
  &lt;li&gt;자식 클래스에서 상속시 extends가 아닌 implements 키워드를 사용해야 한다.&lt;/li&gt;
  &lt;li&gt;다중 상속 지원: implements 키워드를 통해 여러 클래스를 상속 가능하다.&lt;/li&gt;
  &lt;li&gt;extends와 달리 implements 클래스1, 클래스2, … 형태로 사용 가능.&lt;/li&gt;
  &lt;li&gt;예:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  class ICircle extends Boat implements IShape, Seoul
  =&amp;gt; iCircle의 타입이 될 수 있는 것: Boat, IShape, Seoul.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;의존성 감소: 고치는 부분을 줄일 수 있다 - 유지보수를 편하게 해준다.&lt;/li&gt;
  &lt;li&gt;interface와 interface 간에도 상속관계 성립 가능.&lt;/li&gt;
  &lt;li&gt;interface 예시
&lt;img src=&quot;https://user-images.githubusercontent.com/23356503/51424291-ffe79e00-1c0e-11e9-9061-3b57a81ae7ef.png&quot; alt=&quot;interface example&quot; /&gt;
  위 그림처럼 관계를 만든 다음
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  void pay(Thing x){
      ...
  }
  메소드를
  void pay(Valuable x){
      ...
  }
  으로 변경한다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;instanceof&quot;&gt;instanceof&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;상속관계가 없을 경우 사용 불가능한 연산자.&lt;/li&gt;
  &lt;li&gt;작은 타입 -&amp;gt; 큰 타입 순서로 사용해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;has-a-관계&quot;&gt;has-a 관계&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;서로 의존성을 갖게 되는 관계(Coupling) - 지양해야 함.&lt;/li&gt;
  &lt;li&gt;한 클래스가 다른 클래스를 인자로 가지고 있는 관계.&lt;/li&gt;
  &lt;li&gt;수정사항 발생시 두개의 클래스를 전부 수정해야 한다.&lt;/li&gt;
  &lt;li&gt;보완: interface를 사용하여 타입의 자유도를 높여 의존성을 낮출 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;collections&quot;&gt;Collections&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;여러개의 데이터를 저장.&lt;/li&gt;
  &lt;li&gt;저장 방식에 따라 List, Set, Map으로 나뉜다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;center&gt;구분&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;center&gt;List&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;center&gt;Set&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;center&gt;Map&lt;/center&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;중복&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;center&gt;허용&lt;/center&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;center&gt;허용 X&lt;/center&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;center&gt;허용 X&lt;/center&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;strong&gt;순서&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;center&gt;있음&lt;/center&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;center&gt;없음&lt;/center&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;center&gt;없음&lt;/center&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;1-list-기존-배열과-유사&quot;&gt;1. List: 기존 배열과 유사.&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- ArrayList
- Vector
    - 아무 인자 없이 생성시 10칸짜리 Vector가 생성되고, 용량이 부족하면 기존의 크기를 2배로 늘린 후 재배치.
    - Vector.capacity(): Vector 전체의 크기 리턴.
    - Vector.size(): Vector 내 component 갯수 리턴.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-set-집합과-같은-개념&quot;&gt;2. Set: 집합과 같은 개념.&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- HashSet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-map-key-value-쌍으로-데이터-저장-key값-중복-불가&quot;&gt;3. Map: (Key, Value) 쌍으로 데이터 저장, Key값 중복 불가.&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- HashMap
- HashTable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Iterator: 순서 없는 자료구조를 탐색하기 위해 사용함.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;generic-programming&quot;&gt;Generic Programming&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;HashMap&amp;lt;K, V&amp;gt; 와 같이 &amp;lt;…&amp;gt;의 형태를 이룬다.&lt;/li&gt;
  &lt;li&gt;&amp;lt;&amp;gt; 안에는 객체만 올 수 있다: 기본형을 사용하고싶을 경우 wrapper class로 바꿔 넣어야 한다.
    &lt;ul&gt;
      &lt;li&gt;예: int형 ArrayList - ArrayList&lt;Integer&gt;&lt;/Integer&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Generic을 사용할 경우 클래스 변동사항이 있으면 적용되는 시점이 미뤄진다: 객체 생성시 유연성이 생긴다.
    &lt;ul&gt;
      &lt;li&gt;통상 클래스들은 한번 컴파일하면 다시 컴파일하지 않는 이상 변경사항이 반영되지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클래스는 완성되었으나 타입이 정해지지 않은 형태이다.
    &lt;ul&gt;
      &lt;li&gt;설계 단계에서는 타입 미정.&lt;/li&gt;
      &lt;li&gt;객체 생성시 타입 확정.&lt;/li&gt;
      &lt;li&gt;결론: compile time에서는 타입이 결정되지 않은 상태, runtime에서 타입이 결정.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예시
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public class MyClass&amp;lt;X&amp;gt;{
      private X data;

      public X getData(){
          return data;
      }

      public void setData(X data){
          this.data = data;
      }

      public static void main(String[] args){
          MyClass&amp;lt;String&amp;gt; m1 = new MyClass&amp;lt;&amp;gt;();
          MyClass&amp;lt;Integer&amp;gt; m2 = new MyClass&amp;lt;&amp;gt;();
          MyClass&amp;lt;Circle&amp;gt; m3 = new MyClass&amp;lt;&amp;gt;();
      }
  }

  =&amp;gt; m1, m2, m3의 타입은 모두 MyClass로 같다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;singleton-pattern&quot;&gt;Singleton Pattern&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;디자인 패턴: 설계 패턴. 클래스를 설계하는 패턴을 의미.&lt;/li&gt;
  &lt;li&gt;어플리케이션 전체에서 객체를 한개만 생성하여 사용하는 패턴: 하나의 객체를 전체가 공유한다.&lt;/li&gt;
  &lt;li&gt;클래스명에 static이 붙는다: 오직 하나의 객체만 생성한다.&lt;/li&gt;
  &lt;li&gt;조건
    &lt;ol&gt;
      &lt;li&gt;field: private static이며 클래스 자신의 타입으로 선언되어야 한다.&lt;/li&gt;
      &lt;li&gt;생성자: private으로 설정.&lt;/li&gt;
      &lt;li&gt;객체를 생성하여 리턴하는 static 메소드가 반드시 있어야 한다.(통상 getInstance()라는 메소드 정의)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;외부에서 객체 생성에 영향을 주지 않도록 한다
    &lt;ul&gt;
      &lt;li&gt;생성자는 Default 생성자만 두는 경우가 대부분이다.&lt;/li&gt;
      &lt;li&gt;생성자, 생성 메소드 오버로딩하지 않음.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예시
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public class Speaker{
      private static Speaker speaker;
      private int volume;

      private Speaker(){
          volume = 5;
      }

      public static Speaker getInstance(){
          if(speaker == null){
              speaker = new Speaker();
          }

          return speaker;
      }

      public int getVolume(){
          return volume;
      }

      public void setVolume(int volume){
          this.volume = volume;
      }
  }

  public class SingletonTest{

      public static void main(String[] args){
          Speaker s1 = Speaker.getInstance();
          Speaker s2 = Speaker.getInstance();
          Speaker s3 = Speaker.getInstance();

          System.out.println(s1 == s2);
          System.out.prinltn(s2 == s3);

          s1.setVolume(10);
          System.out.println(s1.getVolume());
          System.out.println(s2.getVolume());
          System.out.println(s3.getVolume());
      }
  }

  실행 결과: s1, s2, s3의 주소값은 전부 같다.
  =&amp;gt; 전부 똑같은 하나의 객체만을 가리키고 있으므로, 한 객체에서 volume을 변경하면 모든 객체의 volume이 똑같이 바뀐다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;comparable-comparator&quot;&gt;Comparable, Comparator&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;객체의 정렬과 관련한 인터페이스.&lt;/li&gt;
  &lt;li&gt;Comparable: 클래스 내부에 객체의 정렬 기준을 만들어놓고자 할때 사용하는 인터페이스.(반드시 한개만 존재한다.)&lt;/li&gt;
  &lt;li&gt;Comparator: 클래스 외부에 특정 객체의 정렬 기준을 명시하는 인터페이스.(클래스 내부의 Comparable 이외의 정렬 기준이 필요할 경우 별도의 클래스를 만들어 정의한다. - 정렬 기준은 한 메소드 내에 한개만 정의 가능.)&lt;/li&gt;
  &lt;li&gt;sort()로 정렬 가능한 객체: Comparator나 Comparable 인터페이스를 implements 하고 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;class-종류&quot;&gt;Class 종류&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;VO
    &lt;ul&gt;
      &lt;li&gt;Value Object&lt;/li&gt;
      &lt;li&gt;값을 저장할 수 있는 객체.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DAO
    &lt;ul&gt;
      &lt;li&gt;Data Access Object&lt;/li&gt;
      &lt;li&gt;이미 만들어진 VO를 프로세싱하는 목적.&lt;/li&gt;
      &lt;li&gt;CRUD: Create, Read, Update, Delete 기능 수행.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CO
    &lt;ul&gt;
      &lt;li&gt;Client Object&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Java" /><summary type="html">알고리즘 스터디 내용 정리</summary></entry><entry><title type="html">16234</title><link href="http://localhost:4000/algorithm/16234/" rel="alternate" type="text/html" title="16234" /><published>2019-01-17T00:00:00+09:00</published><updated>2019-01-17T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/16234</id><content type="html" xml:base="http://localhost:4000/algorithm/16234/">&lt;h1 id=&quot;백준-16234번&quot;&gt;백준 16234번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/16234&quot;&gt;16234번: 인구 이동&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;작년 하반기 삼성 SW 역량테스트 문제다.&lt;/p&gt;

&lt;p&gt;시험장에서 문제 보고 뭔가싶어서 바로 넘기고 다른문제 올인하다 결국 둘다 못풀어서 광탈했던 악몽이 다시 떠오른다.&lt;/p&gt;

&lt;p&gt;아무 문제나 붙잡고 풀다가 다 안풀려서 어차피 한번은 풀어야될 문제라 결국 붙잡고 풀었다.&lt;/p&gt;

&lt;p&gt;예전부터 지인들이 니가 문제보고 쫄아서그렇지 별거 아닌문제다 라는 말을 했었는데 막상 풀어보니 틀린말은 아닌거같다.&lt;/p&gt;

&lt;p&gt;하지만 내가 저날 시험장에서 이문제를 제대로 읽고 이해했다고 해도 시간안에 푸는건 무리였을것 같다.&lt;/p&gt;

&lt;p&gt;BFS를 여러번 해야되는 문제다.&lt;/p&gt;

&lt;p&gt;map에서 수정할 부분이 어디인지 찾아내는 부분에서 BFS를 해야 하고, 수정할 부분을 찾은 다음 map을 수정하기 위한 BFS를 해야하는 문제.&lt;/p&gt;

&lt;p&gt;거기다 이 과정을 더이상 수정할 부분이 없을때까지 반복해야 한다.&lt;/p&gt;

&lt;p&gt;BFS문제라는 느낌은 확실히 들었다.&lt;/p&gt;

&lt;p&gt;처음에 문제 접했을땐 map에서 수정할 부분을 찾는 과정에 대해 BFS를 써야겠다는 생각이 안들었다.&lt;/p&gt;

&lt;p&gt;그래서 3중 for문을 사용해서 수정할 부분을 찾아 마킹했다.&lt;/p&gt;

&lt;p&gt;그 이후 map을 수정하는 부분에 대해서는 BFS로 구현하여 풀어보았다.&lt;/p&gt;

&lt;p&gt;풀어본 다음 테스트케이스들을 넣어보니, 단순히 3중 for문으로는 풀수 없는 문제라는 것을 깨달았다.&lt;/p&gt;

&lt;p&gt;마지막까지 가장 애먹였던 부분이 이부분인데, map에서 수정할 부분을 단순히 1로 마킹할 경우 영역간 경계가 있으나 이 경계를 무시하고 BFS를 진행하는 문제가 생긴다.&lt;/p&gt;

&lt;p&gt;BFS로 바꿔서 해보고도 마지막에 이부분을 놓쳐 한번 더 삽질하다 결국 풀었다.&lt;/p&gt;

&lt;p&gt;막상 풀고나니 별거 아닌건 맞는데, 시험장의 압박감과 이 시험볼 당시 알고리즘 공부도 어설프게 하고 간 나는 절대 못풀었을 것 같다는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;얻어가는 점은 몇번씩 실패하고도 남의 도움 안받고 내 힘만으로 풀어냈다는 점, BFS문제를 혼자 힘만으로 제대로 풀어냈다는 점이다.&lt;/p&gt;

&lt;p&gt;이런 점을 밑거름삼아 앞으로 있을 역량테스트에서도 포기하지 않고 끝까지 풀어내는 것이 목표이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;다시는 악몽 안꾸련다. 앞으로도 화이팅!!!&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 15/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory.h&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int N, L, R;
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

int map[50][50] = {0, };
int toChange[50][50] = {0, };
int visit[50][50] = {0, };

vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; changes(){
    vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; result;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;N; j++){
            if(toChange[i][j] != 0){
                result.push_back(make_pair(i, j));
            }
        }
    }

    return result;
}

void toChange_init(){
    int areaCount = 1;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;N; j++){
            queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;
            Queue.push(make_pair(i, j));

            while(!Queue.empty()){
                int currentX = Queue.front().first;
                int currentY = Queue.front().second;
                Queue.pop();

                for(int k=0; k&amp;lt;4; k++){
                    int nextX = currentX + dx[k];
                    int nextY = currentY + dy[k];

                    if(nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt; N &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt; N){
                        int gap = abs(map[currentX][currentY] - map[nextX][nextY]);
                        if(gap &amp;gt;= L &amp;amp;&amp;amp; gap &amp;lt;= R &amp;amp;&amp;amp; toChange[nextX][nextY] == 0){
                            toChange[nextX][nextY] = areaCount;
                            Queue.push(make_pair(nextX, nextY));
                        }
                    }
                }
            }

            areaCount++;
        }
    }
}

void BFS(int currentX, int currentY){
    vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; visited;

    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;
    Queue.push(make_pair(currentX, currentY));

    int changeCount = 0;
    int changeSum = 0;
    visit[currentX][currentY] = 1;

    while(!Queue.empty()){
        int startX = Queue.front().first;
        int startY = Queue.front().second;
        Queue.pop();

        changeCount++;
        changeSum += map[startX][startY];
        visited.push_back(make_pair(startX, startY));

        for(int i=0; i&amp;lt;4; i++){
            int nextX = startX + dx[i];
            int nextY = startY + dy[i];

            if(nextX &amp;gt;= 0 &amp;amp;&amp;amp; nextX &amp;lt; N &amp;amp;&amp;amp; nextY &amp;gt;= 0 &amp;amp;&amp;amp; nextY &amp;lt; N){
                if(visit[nextX][nextY] == 0 &amp;amp;&amp;amp; toChange[nextX][nextY] == toChange[startX][startY]){
                    Queue.push(make_pair(nextX, nextY));
                    visit[nextX][nextY] = 1;
                }
            }
        }
    }

    for(int i=0; i&amp;lt;visited.size(); i++){
        map[visited[i].first][visited[i].second] = changeSum / changeCount;
    }
}

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; L &amp;gt;&amp;gt; R;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;N; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    int count = 0;

    while(true) {
        memset(toChange, 0, sizeof(toChange));
        memset(visit, 0, sizeof(visit));

        toChange_init();

        vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; ones = changes();
        if (ones.size() == 0) {
            break;
        }

        for (int i = 0; i &amp;lt; ones.size(); i++) {
            if (visit[ones[i].first][ones[i].second] == 0) {
                BFS(ones[i].first, ones[i].second);
            }
        }

        count++;
    }

    cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DFS" /><category term="BFS" /><summary type="html">백준 16234번 Link: 16234번: 인구 이동</summary></entry><entry><title type="html">1520</title><link href="http://localhost:4000/algorithm/1520/" rel="alternate" type="text/html" title="1520" /><published>2019-01-14T00:00:00+09:00</published><updated>2019-01-14T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/1520</id><content type="html" xml:base="http://localhost:4000/algorithm/1520/">&lt;h1 id=&quot;백준-1520번&quot;&gt;백준 1520번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1520&quot;&gt;1520번: 내리막 길&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;평범한 길찾는문제일줄 알고 우선 BFS부터 냅다 써서 풀었다.&lt;/p&gt;

&lt;p&gt;분명 틀린 답은 아니다. 그런데 문제의 의도는 BFS 대신 DFS를 사용하여 메모리를 절약하고, DFS에 DP를 적용하여 시간을 절약하는 것이 의도였다.&lt;/p&gt;

&lt;p&gt;DFS에 DP를 접목시키는 문제는 처음 보는것 같다.&lt;/p&gt;

&lt;p&gt;그 느린 DFS를 이렇게 보완할수도 있구나 하는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;이 문제를 풀면서 BFS와 DFS의 차이를 제대로 체감할 수 있었던 것 같다.&lt;/p&gt;

&lt;p&gt;BFS는 시간 내에 해를 찾을 수 있지만, 큐를 사용하는 만큼 더 많은 메모리 공간을 사용한다는 점이 특징.&lt;/p&gt;

&lt;p&gt;DFS는 메모리 공간은 절약할 수 있지만, 깊이가 깊어질수록 매우 많은 시간을 요구한다는 점이 특징이다.&lt;/p&gt;

&lt;p&gt;이러한 DFS의 깊이에 따른 문제를 보완하는 방법으로 DP를 사용하는 문제였다.&lt;/p&gt;

&lt;p&gt;둘을 어떻게 접목시킬지 방법이 안떠올라서 결국 답을 찾아보고서야 이해할 수 있었다.&lt;/p&gt;

&lt;p&gt;우선 DP 배열을 전부 -1로 초기화하고 시작한다.&lt;/p&gt;

&lt;p&gt;그 다음, DFS를 목적지부터 (0, 0)까지 가도록 거꾸로 실행한다.&lt;/p&gt;

&lt;p&gt;DFS에 들어가면 우선 DP 배열부터 살펴보게 되는데, DP[startX][startY]가 -1이 아니라는 것은 이미 저장된 값이 있으며, 이는 이미 탐색해서 구한 값이 있음을 의미하므로 그대로 리턴한다.&lt;/p&gt;

&lt;p&gt;만약 startX나 startY가 범위를 벗어나면 0을 리턴하고, (0, 0)에 도착하게 되면 1을 리턴한다.&lt;/p&gt;

&lt;p&gt;이 3가지 조건문에 걸리지 않았다는 것은 아직 탐색하지 않은 곳임을 의미하므로 탐색을 진행한다.&lt;/p&gt;

&lt;p&gt;가장 먼저 DP[startX][startY]를 0으로 설정한다.&lt;/p&gt;

&lt;p&gt;그 다음은 통상 아는 DFS를 진행하는데, 내려가는 방향으로만 갈 수 있고 우리는 DFS를 거꾸로 진행하고 있으므로 map[nextX][nextY]가 map[startX][startY]보다 클 경우에만 DFS를 진행한다.&lt;/p&gt;

&lt;p&gt;조금 다른점이 있다면 통상 아는 DFS였다면 DFS(nextX, nextY)만 부르고 끝났겠지만, 이 문제는 DP를 접목시켜야 하므로 DP[startX][startY]의 값에 DFS(nextX, nextY)를 더한 값을 설정한다.&lt;/p&gt;

&lt;p&gt;이때 연쇄적으로 재귀함수를 돌다 더 갈수 없으면 DP[startX][startY]를 리턴하고, 리턴되는 값을 계속 더해주는 것이다.&lt;/p&gt;

&lt;p&gt;같은 방법으로 4방향 모두 탐색하며 DFS를 완성한다.&lt;/p&gt;

&lt;p&gt;풀이방법을 외워둬야 할 것 같은 문제다.&lt;/p&gt;

&lt;p&gt;BFS와 DFS의 차이점, DFS와 DP의 연계를 모두 배울 수 있는 문제였다. 까먹을때쯤 꼭 다시풀어볼 문제.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;bfs로-풀다-틀린-코드&quot;&gt;BFS로 풀다 틀린 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 13/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

int N, M;

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

int map[501][501];

int BFS(int startX, int startY){
    int result = 0;
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; Queue;

    Queue.push(make_pair(startX, startY));

//    vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; visits;

    while(!Queue.empty()){
        int currentX = Queue.front().first;
        int currentY = Queue.front().second;
        Queue.pop();

//        visits.push_back(make_pair(currentX, currentY));

        if(currentX == N &amp;amp;&amp;amp; currentY == M){
//            for(int i=0; i&amp;lt;visits.size(); i++){
//                cout &amp;lt;&amp;lt; map[visits[i].first][visits[i].second] &amp;lt;&amp;lt; ' ';
//            }
//            cout &amp;lt;&amp;lt; '\n';
//            visits.clear();
            result++;
        }

        for(int i=0; i&amp;lt;4; i++){
            int nextX = currentX + dx[i];
            int nextY = currentY + dy[i];

            if(nextX &amp;gt; 0 &amp;amp;&amp;amp; nextX &amp;lt;= N &amp;amp;&amp;amp; nextY &amp;gt; 0 &amp;amp;&amp;amp; nextY &amp;lt;= N){
                if(map[currentX][currentY] &amp;gt; map[nextX][nextY]){
                    Queue.push(make_pair(nextX, nextY));
                }
            }
        }
    }

    return result;
}

int main(){
    cin &amp;gt;&amp;gt; M &amp;gt;&amp;gt; N;

    for(int i=1; i&amp;lt;=M; i++) {
        for (int j = 1; j &amp;lt;= N; j++) {
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }

    cout &amp;lt;&amp;lt; BFS(1, 1) &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 13/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory.h&amp;gt;

using namespace std;

int N, M;

int map[501][501];
int DP[501][501];

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

int DFS(int startX, int startY){
    if(DP[startX][startY] != -1){
        return DP[startX][startY];
    }
    if(startX &amp;lt; 0 || startX &amp;gt;= N || startY &amp;lt; 0 || startY &amp;gt;= M){
        return 0;
    }
    if(startX == 0 &amp;amp;&amp;amp; startY == 0){
        return 1;
    }

    DP[startX][startY] = 0;

    for(int i=0; i&amp;lt;4; i++){
        int nextX = startX + dx[i];
        int nextY = startY + dy[i];

        if(map[nextX][nextY] &amp;gt; map[startX][startY]){
            DP[startX][startY] += DFS(nextX, nextY);
        }
    }

    return DP[startX][startY];
}

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;M; j++){
            cin &amp;gt;&amp;gt; map[i][j];
        }
    }
    memset(DP, -1, sizeof(DP));

    cout &amp;lt;&amp;lt; DFS(N-1, M-1) &amp;lt;&amp;lt; '\n';

    for(int i=0; i&amp;lt;N; i++){
        for(int j=0; j&amp;lt;M; j++){
            cout &amp;lt;&amp;lt; DP[i][j] &amp;lt;&amp;lt; ' ';
        }
        cout &amp;lt;&amp;lt; '\n';
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><category term="DFS" /><category term="BFS" /><summary type="html">백준 1520번 Link: 1520번: 내리막 길</summary></entry><entry><title type="html">5th week summary</title><link href="http://localhost:4000/java/5th-Week-Summary/" rel="alternate" type="text/html" title="5th week summary" /><published>2019-01-11T00:00:00+09:00</published><updated>2019-01-11T00:00:00+09:00</updated><id>http://localhost:4000/java/5th%20Week%20Summary</id><content type="html" xml:base="http://localhost:4000/java/5th-Week-Summary/">&lt;h1 id=&quot;알고리즘-스터디-내용-정리&quot;&gt;알고리즘 스터디 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;알고리즘-설계-기법&quot;&gt;알고리즘 설계 기법&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;완전검색: Brute Force
    &lt;ul&gt;
      &lt;li&gt;시간이 가장 많이 걸린다.&lt;/li&gt;
      &lt;li&gt;반드시 답을 찾을 수 있다 =&amp;gt; 소요 시간 비교의 척도가 된다.&lt;/li&gt;
      &lt;li&gt;시간 내에 답을 찾을 수 있는지 사전에 확인해봐야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;탐욕기법: Greedy
    &lt;ul&gt;
      &lt;li&gt;현재의 위치에서 최선의 선택을 한다.&lt;/li&gt;
      &lt;li&gt;선택이 옳았음을 증명하는 과정이 필요하다.&lt;/li&gt;
      &lt;li&gt;코드가 짧다.&lt;/li&gt;
      &lt;li&gt;답을 못찾을 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가지치기: Backtracking
    &lt;ul&gt;
      &lt;li&gt;답이 될 수 없는 것은 탐색하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;분할정복: Divide &amp;amp; Conquer
    &lt;ul&gt;
      &lt;li&gt;부분해로 전체 해를 구해 나간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;동적계획법: Dynamic Programming
    &lt;ul&gt;
      &lt;li&gt;부분해로 전체 해를 구해 나간다.(분할정복과 유사)&lt;/li&gt;
      &lt;li&gt;분할정복과의 차이: 부분해를 따로 저장함으로써 중복된 계산을 방지한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정렬&quot;&gt;정렬&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;버블 정렬
    &lt;ul&gt;
      &lt;li&gt;O(n^2)&lt;/li&gt;
      &lt;li&gt;맨 뒤에 정렬된 원소는 고정시킨다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;카운팅 정렬
    &lt;ul&gt;
      &lt;li&gt;O(n+k)&lt;/li&gt;
      &lt;li&gt;n이 비교적 작을때만 가능.&lt;/li&gt;
      &lt;li&gt;양의 정수만 정렬 가능.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;선택 정렬
    &lt;ul&gt;
      &lt;li&gt;O(n^2)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;퀵 정렬
    &lt;ul&gt;
      &lt;li&gt;O(nlogn)&lt;/li&gt;
      &lt;li&gt;상용 API의 정렬은 거의 퀵정렬로 구현되어 있음: 카운팅 정렬이 가장 빠르지만 대상이 정수일때만 사용 가능하므로 제약사항이 없는 퀵정렬로 구현.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;병합 정렬
    &lt;ul&gt;
      &lt;li&gt;O(nlogn)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;가능하면-카운팅-정렬-사용-안되면-api-사용&quot;&gt;가능하면 카운팅 정렬 사용, 안되면 API 사용.&lt;/h3&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;입력-방식-비교&quot;&gt;입력 방식 비교&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Scanner: 편하지만 시간이 많이 걸린다.&lt;/li&gt;
  &lt;li&gt;BufferedReader: 시간이 적게 걸리나 문자열로만 리턴 가능.
    &lt;ul&gt;
      &lt;li&gt;사용 예시
  ```
  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  String s = br.readLine(); // 문자열로만 리턴. 사용자가 입력한 한 줄을 문자열로 통째로 받아옴.
  s = “20”;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;int num = Integer.parseInt(s); // 숫자로 변경됨.&lt;/p&gt;

    &lt;p&gt;s = “1 2 3 4 5”;
  String[] arr = s.split(“ “); // s를 공백단위로 쪼갠다 =&amp;gt; arr: 5개의 문자열이 들어간다.
  ```&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;출력-방식-비교&quot;&gt;출력 방식 비교&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;System.out.println(): 출력하기 쉬우나 느리다.&lt;/li&gt;
  &lt;li&gt;BufferedWriter: 빠르게 출력 가능.
    &lt;ul&gt;
      &lt;li&gt;사용 예시
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  BufferedWriter bw = new BufferedWriter(System.out);
  bw.write(&quot;abcde&quot;); // 줄 안바뀜.
  bw.write(&quot;\n&quot;); // 줄바꿈하려면 개행문자 써줘야 함.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;static--non-static&quot;&gt;static / non-static&lt;/h1&gt;
&lt;p&gt;static 멤버는 non-static 멤버에 접근할 수 없다: static 멤버는 객체 생성 전에 사용할 수 있고, non-static 멤버는 객체 생성 후에 사용할 수 있기 때문.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;static
    &lt;ul&gt;
      &lt;li&gt;클래스 정보가 처음 로딩된 후 ~ 프로그램 종료시까지 사용 가능.(속도 빠름)&lt;/li&gt;
      &lt;li&gt;단점: 메모리에 상주하므로 메모리 낭비 가능성 존재.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;non-static
    &lt;ul&gt;
      &lt;li&gt;객체 생성 시점 ~ 참조변수가 없어질때까지 사용 가능.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;java-프로그램-메모리-영역&quot;&gt;Java 프로그램 메모리 영역&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Call Stack: 메인 메소드, 지역변수 + 메인 메소드에서 호출된 메소드, 지역변수 저장.&lt;/li&gt;
  &lt;li&gt;Heap&lt;/li&gt;
  &lt;li&gt;Method Area&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;의 3가지 영역이 프로그램 실행시 자동으로 생성됨.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;반복문-재귀함수&quot;&gt;반복문, 재귀함수&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;반복문: CPU의 연산만 사용하므로 메모리 사용량이 적다.&lt;/li&gt;
  &lt;li&gt;재귀함수: 속도가 느리고 Call Stack 영역의 메모리를 많이 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;=&amp;gt; 꼭 필요한 경우에만 재귀함수 사용할것.(필요할때: 동적으로 반복문을 추가해야할 때)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;재귀함수의 인자도 Call Stack에 계속 쌓이므로 반드시 필요한 경우가 아니면 전역변수 등으로 처리하여 메모리를 절약할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;재귀함수 예시: 2진수 3자리를 모두 출력하는 재귀함수
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void twoThree(int i, int end, int[] arr){ // i: 시작 차수, end: 종료 차수, arr: 숫자 저장할 배열
  if(i == end){
      System.out.println(Arrays.toString(arr));
      return;
  }
  else{
      arr[i] = 0;
      twoThree(i+1, end, arr);
      arr[i] = 1;
      twoThree(i+1, end, arr);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;java-내용-정리&quot;&gt;Java 내용 정리&lt;/h1&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;class-object&quot;&gt;class, object&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;class: 틀&lt;/li&gt;
  &lt;li&gt;object: 틀에서 만든 대상.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;class-정의&quot;&gt;class 정의&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;class명: 특수문자는 $, _만 허용. 길이제한 없음. 반드시 문자로 시작(숫자로 시작할 수 없음)&lt;/li&gt;
  &lt;li&gt;class를 개발한다 = 부품을 만드는 것과 같다. =&amp;gt; 재활용성을 염두에 두고 개발해야 한다.&lt;/li&gt;
  &lt;li&gt;class 내 field값을 초기화하지 않고 객체 생성시 각 타입의 기본값으로 초기화된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;객체-생성&quot;&gt;객체 생성&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;Class Area에서 호출하려는 class가 있는지 찾는다.&lt;/li&gt;
  &lt;li&gt;있으면 Heap 영역에 객체 주소 할당.&lt;/li&gt;
  &lt;li&gt;생성된 객체에 할당된 주소값 저장.
    &lt;ul&gt;
      &lt;li&gt;Class Loader: 하드디스크에 있는 class 파일을 메모리로 읽어온다.&lt;/li&gt;
      &lt;li&gt;Class Area: 메모리로 읽어온 클래스의 정보를 저장하는 곳.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;생성자&quot;&gt;생성자&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;클래스와 이름이 같은 메소드.&lt;/li&gt;
  &lt;li&gt;반드시 리턴타입이 없어야 한다.&lt;/li&gt;
  &lt;li&gt;객체 생성시 항상 호출된다 =&amp;gt; 반드시 있어야 한다.(초기화작업 필요없을 경우 생략 가능)&lt;/li&gt;
  &lt;li&gt;생성자를 따로 정의해두지 않았다면 컴파일러가 컴파일 시 기본 생성자를 코드에 삽입한다.&lt;/li&gt;
  &lt;li&gt;기본 생성자: 아무 파라미터가 없는 생성자.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;this&quot;&gt;this()&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;생성자 안에서만 사용 가능한 메소드.&lt;/li&gt;
  &lt;li&gt;다른 여러 생성자가 있으면 this()를 통해 다른 생성자 실행 가능.&lt;/li&gt;
  &lt;li&gt;다른 생성자 호출시 넘겨줄 인자가 없으면 임의로 기본값을 정해 넘길 수 있다. =&amp;gt; 아무 인자 없이 호출시 전부 설정된 기본값으로 들어간다.&lt;/li&gt;
  &lt;li&gt;목적: 중복 코드를 줄이기 위해.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;overloading&quot;&gt;Overloading&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;같거나 비슷한 일을 하는 메소드 구현시 메소드 이름을 같게 정의하여 사용을 편리하게 한다.&lt;/li&gt;
  &lt;li&gt;메소드명은 같고, 파라미터가 다르다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;접근-수식어접근-지정자-접근-제한자&quot;&gt;접근 수식어(=접근 지정자, 접근 제한자)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;public: 모든 경우 접근 가능.&lt;/li&gt;
  &lt;li&gt;protected: 패키지 상관없이 상속관계면 접근 가능.&lt;/li&gt;
  &lt;li&gt;default: 아무 접근 지정자가 없으면 default. 같은 패키지 내에서만 접근 가능.&lt;/li&gt;
  &lt;li&gt;private: 같은 class 내에서만 접근 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;같은 패키지 &amp;amp; 상속관계: default, protected, public 접근 가능.&lt;/li&gt;
  &lt;li&gt;같은 패키지 &amp;amp; 다른 클래스: default, protected, public 접근 가능.&lt;/li&gt;
  &lt;li&gt;같은 클래스: default, private, protected, public 접근 가능.&lt;/li&gt;
  &lt;li&gt;다른 패키지 &amp;amp; 상속관계: protected, public 접근 가능.&lt;/li&gt;
  &lt;li&gt;다른 패키지: public 접근 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;getter-setter&quot;&gt;getter, setter&lt;/h1&gt;
&lt;p&gt;함부로 데이터에 접근하려는 시도를 방지할 수 있다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;한개의-java파일-내에-여러개의-클래스&quot;&gt;한개의 .java파일 내에 여러개의 클래스&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;한 클래스 내에 여러 클래스 생성 가능.&lt;/li&gt;
  &lt;li&gt;But, 접근지정자는 단 하나의 클래스에만 붙일 수 있다.(.java파일의 파일명과 일치하는 클래스에만 붙일 수 있음): 프로그램 외부에서 무분별하게 접근하는 것을 막기 위함(보안적 측면)&lt;/li&gt;
  &lt;li&gt;파일명과 일치하지 않는 모든 클래스들은 default 접근 지정자만 혀용한다.&lt;/li&gt;
  &lt;li&gt;class에 대한 접근 지정자는 public, default의 2가지만 가능.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;api&quot;&gt;API&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Application Programming Interface&lt;/li&gt;
  &lt;li&gt;객체지향 언어에서 class 단위로 미리 구현되어 제공되는 프로그램.&lt;/li&gt;
  &lt;li&gt;class 단위의 library.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;객체지향형-언어의-3가지-특징&quot;&gt;객체지향형 언어의 3가지 특징&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;Encapsulation(캡슐화)&lt;/li&gt;
  &lt;li&gt;Inheritance(상속)&lt;/li&gt;
  &lt;li&gt;Polymorphism(다형성)&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;inheritance&quot;&gt;Inheritance&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Java에서는 단일 상속만 지원.(부모는 하나만 가능)&lt;/li&gt;
  &lt;li&gt;class 설계시 특정 class를 상속받아 그 class의 variable과 메소드를 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;is a 관계
    &lt;ul&gt;
      &lt;li&gt;자식이 부모자리에 갈 수 있으나 부모가 자식자리에 갈 수 없다.&lt;/li&gt;
      &lt;li&gt;예: Tiger is an Animal - Tiger: 자식, Animal: 부모.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Generalization: class들의 공통된 특징을 모아 super class를 만든다.&lt;/li&gt;
  &lt;li&gt;Specialization: 비슷한 속성, 기능을 가진 클래스를 상속받아 새로운 클래스를 만든다.(sub class를 만든다)&lt;/li&gt;
  &lt;li&gt;sub class object 생성시 자동으로 super class의 생성자가 먼저 실행된다.
    &lt;ul&gt;
      &lt;li&gt;parent 객체가 먼저 생성된다.&lt;/li&gt;
      &lt;li&gt;상속관계가 여러 단계를 거치면 메모리가 낭비될 수 있다 =&amp;gt; 상속구조를 최소화하는 것이 좋다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;overriding&quot;&gt;Overriding&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;부모에게 물려받은 메소드를 자식 클래스에 맞게 재정의하는 것.&lt;/li&gt;
  &lt;li&gt;메소드 이름, 리턴 타입, 파라미터 모두 부모클래스의 메소드와 일치해야 한다.&lt;/li&gt;
  &lt;li&gt;바꿀 수 있는것: 메소드 바디, 접근 지정자.&lt;/li&gt;
  &lt;li&gt;접근 지정자는 부모의 접근 지정자와 같게 하거나 범위를 넓히는 방향으로만 가능하다.(좁아지면 안됨)&lt;/li&gt;
  &lt;li&gt;@Override annotation이 붙는다.&lt;/li&gt;
  &lt;li&gt;오버라이딩한 후에는 부모의 메소드 대신 항상 자식이 오버라이딩한 메소드가 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;annotation&quot;&gt;@annotation&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램에 대한 설명이나 설정사항 등을 나타냄.&lt;/li&gt;
  &lt;li&gt;함부로 지우다가 큰일난다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;super-this&quot;&gt;super, this&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;static 메소드 내에서 사용 불가.&lt;/li&gt;
  &lt;li&gt;static 메소드 내에서 굳이 쓰려면: non static 메소드를 메소드에서 super나 this를 사용하도록 새롭게 정의한 후 static 메소드에서 그 메소드를 호출한다.&lt;/li&gt;
  &lt;li&gt;super는 한번만 쓸 수 있다: super.super 안됨.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;nullpointerexception&quot;&gt;NullPointerException&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;객체 생성이 안된 상태에서 객체의 메소드 호출시 발생.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;상속관계에서-인자-있는-생성자&quot;&gt;상속관계에서 인자 있는 생성자&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;부모, 자식의 생성자 인자 중 겹치는게 있으면 super(겹치는인자, 겹치는인자, …)을 쓴 다음 자식만의 인자를 사용하여 따로 초기화하면 편하다.&lt;/li&gt;
  &lt;li&gt;목적: 코드 중복 제거 + 자식이 별도의 생성자를 정의할 수 있도록 한다.&lt;/li&gt;
  &lt;li&gt;주의사항: super(…) 구문이 항상 맨 먼저 나와야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;상속관계-예시&quot;&gt;상속관계 예시&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Parent{}

class Child extends Parent{}

Parent x = new Child(); // 가능: 자식은 부모자리에 갈 수 있다.
Child x = new Parent(): // 불가능: 부모는 자식자리에 갈 수 없다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;polymorphism다형성&quot;&gt;Polymorphism(다형성)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;생성된 객체를 가리키는 레퍼런스(변수)의 타입이 여러가지인 경우.&lt;/li&gt;
  &lt;li&gt;타입 캐스팅: 실제 저장되어 있는 객체가 캐스팅할 타입보다 작은 타입이어야 형변환 가능.
    &lt;ul&gt;
      &lt;li&gt;반대로 할 경우 컴파일은 되지만 실행시 Exception 발생.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상속관계에서는 부모가 항상 자식보다 큰 타입이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;polymorphism-예시&quot;&gt;Polymorphism 예시&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class GrandParent{
    String name = &quot;Doe&quot;;

    public void printName(){
        System.out.println(name);
    }

}

class Parent extends GrandParent{
    String name = &quot;Tom&quot;;
    String address = &quot;Seoul&quot;;

    public void printName(){
        System.out.println(name);
    }

    public void printAddress(){
        System.out.println(address);
    }

}

public class Child extends Parent{
    public void printName(){
        System.out.println(&quot;Tomson&quot;);
    }

    public void callSuper(){
        super.printName();
    }

    public static void main(String[] args){
        Parent x = new Child(); // 가능
        GrandParent c = new Child(); // 가능
        Child y = new Parent(); // 불가능

        c.printName(); // 결과: Tomson =&amp;gt; GrandParent의 printName을 Parent가, Parent의 printName을 Child가 재정의하므로 Child까지의 범위에서 가장 마지막에 재정의된 Child의 printName이 실행된다.
        c.callSuper(); // 에러: GrandParent 타입의 상위가 없기 때문.
        c.printAddress(); // 에러: GrandParent에 printAddress 메소드가 정의되어 있지 않다.
        System.out.println(c.getClass().getSimpleName()); // 결과: Child =&amp;gt; c의 타입은 GrandParent지만, 실제로 저장된 객체는 Child이므로 Child가 출력된다.(getClass: 실제로 저장된 객체의 타입을 가져온다.)
        
        GrandParent e = new Parent();
        e.printName(); // 결과: Tom =&amp;gt; GrandParent의 printName을 Parent가 재정의했으므로 Parent까지의 범위에서 가장 마지막에 재정의된 Parent의 printName이 실행된다.
        System.out.println(e.getClass().getSimpleName()); // 결과: Parent.
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="Java" /><summary type="html">알고리즘 스터디 내용 정리</summary></entry><entry><title type="html">2156</title><link href="http://localhost:4000/algorithm/2156/" rel="alternate" type="text/html" title="2156" /><published>2019-01-11T00:00:00+09:00</published><updated>2019-01-11T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2156</id><content type="html" xml:base="http://localhost:4000/algorithm/2156/">&lt;h1 id=&quot;백준-2156번&quot;&gt;백준 2156번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2156&quot;&gt;2156번: 포도주 시식&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;문제를 보자마자 예전에 풀었던 계단 오르기와 비슷한 문제라는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;Link: &lt;a href=&quot;https://keithlee94.github.io/KeithLog/algorithm/2579/&quot;&gt;2579번: 계단 오르기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;차이점이 있다면 계단 오르기의 경우 마지막 계단을 반드시 밟아야 했지만, 이 문제는 3잔을 연속으로 마실 수 없다는 제약을 제외하면 어떠한 제약사항이 없다는 점이다.&lt;/p&gt;

&lt;p&gt;점화식으로 풀어야 한다는 점은 동일하다.&lt;/p&gt;

&lt;p&gt;예전에 계단 오르기를 풀때 점화식 세우는 과정을 제대로 이해하지 못한 것 같다.&lt;/p&gt;

&lt;p&gt;이번 문제에서도 점화식 세우는데 많은 어려움을 겪었고, 결국 에전에 풀었던 계단 오르기 문제를 다시 보면서 점화식을 어떻게 세워야 하는지 생각했다.&lt;/p&gt;

&lt;p&gt;또, 마지막 계단을 반드시 밟아야 한다는 제약사항을 빼고 구현하는 방법에 대해서도 많이 고민했던것 같다.&lt;/p&gt;

&lt;p&gt;결론적으로는 답을 찾아서 풀었다.&lt;/p&gt;

&lt;p&gt;점화식 세우는 연습은 얼마나 해야 점화식을 세울 줄 알게 되려나??&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 11/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int N;

int maximum(vector&amp;lt;int&amp;gt; numbers){
    int result = 0;

    for(int i=0; i&amp;lt;numbers.size(); i++){
        if(numbers[i] &amp;gt; result){
            result = numbers[i];
        }
    }

    numbers.clear();
    return result;
}

int main(){
    cin &amp;gt;&amp;gt; N;

    int DP[10001];
    int score[10001];

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; score[i];
    }

    vector&amp;lt;int&amp;gt; to_compare;

    DP[1] = score[1];
    DP[2] = max(score[1] + score[2], score[2]);

    for(int i=3; i&amp;lt;=N; i++){
        to_compare.push_back(DP[i-1]);
        to_compare.push_back(DP[i-2] + score[i]);
        to_compare.push_back(DP[i-3] + score[i] + score[i-1]);
        DP[i] = maximum(to_compare);
    }

    cout &amp;lt;&amp;lt; DP[N] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 2156번 Link: 2156번: 포도주 시식</summary></entry><entry><title type="html">2293</title><link href="http://localhost:4000/algorithm/2293/" rel="alternate" type="text/html" title="2293" /><published>2019-01-10T00:00:00+09:00</published><updated>2019-01-10T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2293</id><content type="html" xml:base="http://localhost:4000/algorithm/2293/">&lt;h1 id=&quot;백준-2293번&quot;&gt;백준 2293번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/2293&quot;&gt;2293번: 동전 1&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;이 문제도 어떻게든 DP로 풀어보려 온갖 방법으로 생각해봤다.&lt;/p&gt;

&lt;p&gt;우선 각 동전들에 대해 최대로 쓸 수 있는 갯수를 구한 다음 하나씩 빼가면서 조합을 구하려고 생각해봤다.&lt;/p&gt;

&lt;p&gt;그런데 동전이 몇종류나 있을지도 모르고 시간도 그만큼 오래걸릴것 같아 이 생각은 접었다.&lt;/p&gt;

&lt;p&gt;암만 고민해봐도 이 방법 말고는 떠오르는 방법이 없어 결국 답을 찾아봤다.&lt;/p&gt;

&lt;p&gt;답 찾아보니 점화식을 세울줄 알아야 풀 수 있는 문제더라.&lt;/p&gt;

&lt;p&gt;심지어 그 점화식을 어떻게 세우는지에 대해서도 설명이 자세하게 나와있는게 잘 없어서 한참 뒤지면서 여러개 찾아보다가 겨우 이해했다.&lt;/p&gt;

&lt;p&gt;어떤 블로그에서 표를 그려가면서 풀면 금방 이해하고 점화식을 세울 수 있을거라 했는데, 점화식에 대해 이해하고 나니 왜 그렇게 말했는지 알 것 같다.&lt;/p&gt;

&lt;p&gt;점화식을 구하는 과정이다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;1원만 쓸 때 각 금액에 대해 나올 수 있는 경우의 수
    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;1원&lt;/td&gt;
            &lt;td&gt;2원&lt;/td&gt;
            &lt;td&gt;3원&lt;/td&gt;
            &lt;td&gt;4원&lt;/td&gt;
            &lt;td&gt;5원&lt;/td&gt;
            &lt;td&gt;6원&lt;/td&gt;
            &lt;td&gt;7원&lt;/td&gt;
            &lt;td&gt;8원&lt;/td&gt;
            &lt;td&gt;9원&lt;/td&gt;
            &lt;td&gt;10원&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;{1, 1, 1, 1, 1, 1, 1, 1, 1, 1}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;2원도 쓸 때 각 금액에 대해 나올 수 있는 경우의 수
    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;1원&lt;/td&gt;
            &lt;td&gt;2원&lt;/td&gt;
            &lt;td&gt;3원&lt;/td&gt;
            &lt;td&gt;4원&lt;/td&gt;
            &lt;td&gt;5원&lt;/td&gt;
            &lt;td&gt;6원&lt;/td&gt;
            &lt;td&gt;7원&lt;/td&gt;
            &lt;td&gt;8원&lt;/td&gt;
            &lt;td&gt;9원&lt;/td&gt;
            &lt;td&gt;10원&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;{1, 2, 2, 3, 3, 4, 4, 5, 5, 6}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;규칙&quot;&gt;규칙&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2원 경우의수 = 1원, 2원을 쓸때 0원 경우의수 + 1원만 쓸때 2원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3원 경우의수 = 1원, 2원을 쓸때 1원 경우의수 + 1원만 쓸때 3원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4원 경우의수 = 1원, 2원을 쓸때 2원 경우의수 + 1원만 쓸때 4원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1원, 2원을 쓸때 K원을 만드는 경우의 수: DP[K] += DP[K - 2]&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;5원도 쓸 때 각 금액에 대해 나올 수 있는 경우의 수
    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;1원&lt;/td&gt;
            &lt;td&gt;2원&lt;/td&gt;
            &lt;td&gt;3원&lt;/td&gt;
            &lt;td&gt;4원&lt;/td&gt;
            &lt;td&gt;5원&lt;/td&gt;
            &lt;td&gt;6원&lt;/td&gt;
            &lt;td&gt;7원&lt;/td&gt;
            &lt;td&gt;8원&lt;/td&gt;
            &lt;td&gt;9원&lt;/td&gt;
            &lt;td&gt;10원&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;{1, 2, 2, 3, 4, 5, 6, 7, 8, 10}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;규칙-1&quot;&gt;규칙&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;6원 경우의수 = 1원, 2원, 5원을 쓸때 6원 경우의수 + 1원, 2원을 쓸때 6원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7원 경우의수 = 1원, 2원, 5원을 쓸때 7원 경우의수 + 1원, 2원을 쓸때 7원에 대한 경우의 수&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1원, 2원, 5원을 쓸때 K원을 만드는 경우의 수: DP[K] += DP[K - 5]&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;최종-점화식-x원을-추가했을때-k원을-만드는-경우의-수-dpk--dpk---x&quot;&gt;최종 점화식: x원을 추가했을때 K원을 만드는 경우의 수: DP[K] += DP[K - x]&lt;/h1&gt;

&lt;p&gt;이대로 코드로 옮기면 풀린다.&lt;/p&gt;

&lt;p&gt;작은문제로 쪼개고 그 결과를 저장하며 DP문제를 해결하는 유형에 대해서는 어떻게든 방법을 생각해낼 수 있을것 같은데, 점화식 짜서 풀어야되는 문제는 정말 답이 없는것 같다.&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 10/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int N, K;

int main(){
    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K;

    int DP[10001] = {0, };
    int coins[101];

    for(int i=1; i&amp;lt;=N; i++){
        cin &amp;gt;&amp;gt; coins[i];
    }

    DP[0] = 1;

    for(int i=1; i&amp;lt;=N; i++){
        for(int j=1; j&amp;lt;=K; j++){
            if(j &amp;gt;= coins[i]){
                DP[j] += DP[j - coins[i]];
            }
        }
    }

    cout &amp;lt;&amp;lt; DP[K] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 2293번 Link: 2293번: 동전 1</summary></entry><entry><title type="html">10844</title><link href="http://localhost:4000/algorithm/10844/" rel="alternate" type="text/html" title="10844" /><published>2019-01-09T00:00:00+09:00</published><updated>2019-01-09T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/10844</id><content type="html" xml:base="http://localhost:4000/algorithm/10844/">&lt;h1 id=&quot;백준-10844번&quot;&gt;백준 10844번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/10844&quot;&gt;10844번: 쉬운 계단 수&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;어제는 피곤함에 빈둥거리다 아무것도 못올렸다.&lt;/p&gt;

&lt;p&gt;이 문제는 어제부터 고민하다 방법을 찾았고, 그 방법을 어떻게 구현할지 많은 시행착오를 거친 끝에 결국 풀었다.&lt;/p&gt;

&lt;p&gt;사실 맨 마지막에 내 생각이 확실한데 답이 자꾸 틀려서 다른사람 답을 찾아보긴 했지만, 그 답이 내가 생각한 그대로여서 여태껏 답 찾아본 문제들중 가장 치열하게 고민한 문제인 것 같다는 생각을 했다.&lt;/p&gt;

&lt;p&gt;그만큼 이번에는 답찾아서 풀었음에도 쪽팔리다는 생각이 들지 않았고.&lt;/p&gt;

&lt;p&gt;각설하고, 푸는 방법에 대해 설명해보자면 이 문제에서 각 자릿수가 몇자리수이냐는 아무 상관이 없다.&lt;/p&gt;

&lt;p&gt;가장 중요한 것은 1의자리 숫자가 무엇인지.&lt;/p&gt;

&lt;p&gt;N이 1일때, 2일때, 3일때의 경우들을 직접 구해보니 1의자리 숫자에 따라 다음 수가 영향을 받는다는 것을 알 수 있었다.&lt;/p&gt;

&lt;p&gt;자꾸 보다보니 N일때의 답 = (N-1일때의 답 * 2) - (N-1일때의 계단수 중 첫자리 숫자가 1인 것의 갯수) 라는 규칙을 찾은것같은데, 맞는지는 모르겠다.&lt;/p&gt;

&lt;p&gt;어떻게 구현할지 한참 고민하다 저 규칙대로 풀어보기 위해 우선 큐에 넣고 갱신해가면서 모든 경우를 다 돌려봤다.&lt;/p&gt;

&lt;p&gt;한 5분은 지나야 전체 답을 구할 수 있더라.&lt;/p&gt;

&lt;p&gt;이런 과정을 거치면서 이 문제를 어떻게하면 이전 N에서 얻은 답을 사용할수 있을지에 대해 중점적으로 고민해보았고, 결국 1의자리 숫자만이 영향을 미친다는 점을 찾기에 이르렀다.&lt;/p&gt;

&lt;p&gt;이 문제를 풀며 가장 고무적이었다고 생각했던 부분은 DP의 특성을 어떻게든 적용하기 위해 노력했다는 점.&lt;/p&gt;

&lt;p&gt;앞에서 구한 답을 어떻게 써먹을수 있는지 그 어느때보다 치열하게 고민한 것 같다.&lt;/p&gt;

&lt;p&gt;이 문제를 풀어낸 것이 앞으로 DP문제를 푸는데 있어 전환점이 되길!!&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 08/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;strings.h&amp;gt;

using namespace std;

int main(){
    int N;

    cin &amp;gt;&amp;gt; N;

    unsigned long long DP[101][11];
    bzero(DP, sizeof(DP));

    for(int i=1; i&amp;lt;10; i++){
        DP[1][i] = 1;
    }

    for(int i=2; i&amp;lt;=N; i++) {
        DP[i][0] = DP[i-1][1];
        for(int j=1; j&amp;lt;10; j++){
            DP[i][j] = (DP[i-1][j-1] + DP[i-1][j+1]) % 1000000000;
        }
    }

    unsigned long long sum = 0;
    for(int i=0; i&amp;lt;10; i++){
        sum += DP[N][i];
    }
    cout &amp;lt;&amp;lt; (sum % 1000000000) &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 10844번 Link: 10844번: 쉬운 계단 수</summary></entry><entry><title type="html">1463</title><link href="http://localhost:4000/algorithm/1463/" rel="alternate" type="text/html" title="1463" /><published>2019-01-07T00:00:00+09:00</published><updated>2019-01-07T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/1463</id><content type="html" xml:base="http://localhost:4000/algorithm/1463/">&lt;h1 id=&quot;백준-1463번&quot;&gt;백준 1463번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.acmicpc.net/problem/1463&quot;&gt;1463번: 1로 만들기&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;오늘도 내힘으로 푸는데 실패.&lt;/p&gt;

&lt;p&gt;이 문제도 직전에 풀었던 계단문제처럼 점화식이 가장 중요했다.&lt;/p&gt;

&lt;p&gt;주어진 조건을 곧이곧대로 썼다가 답없는 상황이 나왔다.&lt;/p&gt;

&lt;p&gt;가장 먼저 입력된 수를 3으로 나눠떨어지는지 검사하고 나눠떨어지면 3으로 나누는 것을 첫번째 조건으로 넣었고&lt;/p&gt;

&lt;p&gt;3으로 나눠떨어지지 않으면 2로 나눠떨어지는지 검사하고 나눠떨어지면 2로 나누는 것을 두번째 조건으로 넣었다.&lt;/p&gt;

&lt;p&gt;이 두가지를 만족하지 않을때 1을 빼는 것으로 3가지 조건을 넣었다.&lt;/p&gt;

&lt;p&gt;도무지 어떻게 더 나갈지 모르겠어서 예전 답을 다시 찾아봤다.&lt;/p&gt;

&lt;p&gt;예전 답도 구글링해서 답 찾아보고 풀었는데, 1년동안 실력이 전혀 안늘어난 느낌이다.&lt;/p&gt;

&lt;p&gt;정답은 우선 1을 뺀 다음, 3으로 나눠떨어지면 3으로 나눴을때와 1을 뺐을때의 DP를 비교하는 것이었다.&lt;/p&gt;

&lt;p&gt;3으로 나눠떨어지지 않을 경우, 2로 나눠떨어지면 2로 나눴을때와 1을 뺐을때의 DP를 비교한다.&lt;/p&gt;

&lt;p&gt;나머지 경우는 당연히 1을 뺀 값이 DP에 들어간다.&lt;/p&gt;

&lt;p&gt;오늘로 DP에서 5문제를 풀고있는데, 문제마다 매번 다른 개념인것 같은 느낌이다.&lt;/p&gt;

&lt;p&gt;DP 문제 전반에 걸칠 수 있는 개념이 안잡힌 느낌. 첫술에 배부를수는 당연히 없지만 이대로 갔을때 실력이 늘긴 할지, DP에 대한 접근 방법을 제대로 파악할 수 있긴 할지 매우 걱정된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 07/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string.h&amp;gt;

using namespace std;

int min(int a, int b){
    return a &amp;gt; b ? b : a;
}

int main(){
    int N;
    int DP[1000000];

    cin &amp;gt;&amp;gt; N;

    bzero(DP, sizeof(DP));

    for(int i=2; i&amp;lt;=N; i++){
        DP[i] = DP[i-1] + 1; // 기본적으로 1 빼준다.

        if(i % 2 == 0){
            DP[i] = min(DP[i], DP[i/2] + 1); // 2로 나눠떨어지면 2로 나눴을때와 1뺐을때를 비교한다.
        }
        if(i % 3 == 0){
            DP[i] = min(DP[i], DP[i/3] + 1); // 3으로 나눠떨어지면 3으로 나눴을때와 1뺐을때를 비교한다.
        }
    }

    cout &amp;lt;&amp;lt; DP[N] &amp;lt;&amp;lt; '\n';

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">백준 1463번 Link: 1463번: 1로 만들기</summary></entry><entry><title type="html">Swea_3307</title><link href="http://localhost:4000/algorithm/SWEA_3307/" rel="alternate" type="text/html" title="Swea_3307" /><published>2019-01-07T00:00:00+09:00</published><updated>2019-01-07T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/SWEA_3307</id><content type="html" xml:base="http://localhost:4000/algorithm/SWEA_3307/">&lt;h1 id=&quot;swea-3307번&quot;&gt;SWEA 3307번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AWgebGzaXfEDFAW0&amp;amp;contestProbId=AWBOKg-a6l0DFAWr&amp;amp;probBoxId=AWgebGzqXfIDFAW0+&amp;amp;type=PROBLEM&amp;amp;problemBoxTitle=Club+Problem+box+01&amp;amp;problemBoxCnt=++3+&quot;&gt;3307번: 최장 증가 부분 수열&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;완전탐색 문제인줄 알고 앞에서 썼던 DFS 써서 풀었다가 시간초과났던 문제.&lt;/p&gt;

&lt;p&gt;조합을 하는건 맞는데, DP로 풀었어야 풀리는 문제였다.&lt;/p&gt;

&lt;p&gt;최근에 DP 공부를 하고있었는데도 DP로 풀어야겠다는 생각은 여전히 들지 않았다.&lt;/p&gt;

&lt;p&gt;어찌어찌 테스트케이스는 맞출수 있도록 구현했는데, 제출해보니 한개도 못맞히더라.&lt;/p&gt;

&lt;p&gt;시험장가서 테스트케이스 맞히고도 탈락하는 경우가 왕왕 있다던데, 이런 경우인가 싶었다.&lt;/p&gt;

&lt;p&gt;덤으로 이딴 실력으로 시험장에 가지 않았다는 점이 천만다행.&lt;/p&gt;

&lt;p&gt;풀이에 대해 설명하자면, 우선 입력받은 숫자들 중 수열의 시작점을 for문을 통해 정한다.&lt;/p&gt;

&lt;p&gt;그 다음, 남은 숫자들을 택해서 증가수열을 만들고 그 증가수열의 길이를 갱신하며 최대값을 구하는 문제다.&lt;/p&gt;

&lt;p&gt;이를 위한 조건으로 2가지를 넣었다.&lt;/p&gt;

&lt;p&gt;첫째는 다음 숫자가 반드시 수열의 시작점보다 큰 숫자일 것.&lt;/p&gt;

&lt;p&gt;두번째는 증가수열의 길이가 증가하는 방향일 것.&lt;/p&gt;

&lt;p&gt;이 두가지를 만족하지 못하면 증가수열에 숫자를 포함하지 않고, 다음 숫자들을 계속 살펴보는 식이다.&lt;/p&gt;

&lt;p&gt;이 문제도 답보고 겨우 풀었는데, DP 문제에 대한 감을 살짝 잡은 것 같다.(아직 확실하진 않음)&lt;/p&gt;

&lt;p&gt;이런 최대값 찾는 DP문제의 경우 조건에 맞아 DP 배열의 값을 갱신한 후, 최대값을 갱신하는 작업을 반복하는 방식인 것 같다.&lt;/p&gt;

&lt;p&gt;너무 당연한 말을 한것 같지만, 이런 감 찾는데 정말 오래걸렸다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;아무튼&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;될때까지-하자&quot;&gt;될때까지 하자.&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 08/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;string.h&amp;gt;

using namespace std;

int T;

int main(){
    cin &amp;gt;&amp;gt; T;

    for(int test=1; test&amp;lt;=T; test++){
        int maximum = 0;
        int N;

        cin &amp;gt;&amp;gt; N;

        int numbers[N];
        int DP[N];

        for(int i=0; i&amp;lt;N; i++){
            cin &amp;gt;&amp;gt; numbers[i];
        }

        bzero(DP, sizeof(DP));

        for(int i=0; i&amp;lt;N; i++){
            for(int j=i+1; j&amp;lt;N; j++){
                if(numbers[j] &amp;lt; numbers[i]) continue;
                if(DP[j] &amp;gt;= DP[i] + 1) continue;
                DP[j] = DP[i] + 1; // 증가수열이면서 수열 count가 증가한다면 1 더해줌.
                maximum = max(maximum, DP[j]); // 최대값 갱신.
            }
        }

        cout &amp;lt;&amp;lt; '#' &amp;lt;&amp;lt; test &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; maximum+1 &amp;lt;&amp;lt; '\n';
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DP" /><summary type="html">SWEA 3307번 Link: 3307번: 최장 증가 부분 수열</summary></entry><entry><title type="html">Swea_5215</title><link href="http://localhost:4000/algorithm/SWEA_5215/" rel="alternate" type="text/html" title="Swea_5215" /><published>2019-01-07T00:00:00+09:00</published><updated>2019-01-07T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/SWEA_5215</id><content type="html" xml:base="http://localhost:4000/algorithm/SWEA_5215/">&lt;h1 id=&quot;swea-5215번&quot;&gt;SWEA 5215번&lt;/h1&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AWgebGzaXfEDFAW0&amp;amp;contestProbId=AWT-lPB6dHUDFAVT&amp;amp;probBoxId=AWgebGzqXfIDFAW0+&amp;amp;type=PROBLEM&amp;amp;problemBoxTitle=Club+Problem+box+01&amp;amp;problemBoxCnt=++3+&quot;&gt;5215번: 햄버거 다이어트&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;
&lt;p&gt;완전탐색으로 최적의 조합을 구하는 문제.&lt;/p&gt;

&lt;p&gt;문제 보자마자 ‘이건 DFS쓰면 풀리겠구나’ 하는 생각은 들었다.&lt;/p&gt;

&lt;p&gt;이렇게 생각하고 풀었는데, DFS 구현에서 정말 많이 헤맸다.&lt;/p&gt;

&lt;p&gt;DFS랑 BFS는 그래도 구현방법을 다 외우고 있었다고 생각했었는데 벌써 다 까먹은 모양이다.&lt;/p&gt;

&lt;p&gt;예전에 코딩테스트 볼때도 확실하게 몰랐던거니 당연할수도.&lt;/p&gt;

&lt;p&gt;어떻게든 고쳐서 해보다 안되서 답 찾아서 풀었다.&lt;/p&gt;

&lt;p&gt;핵심은 DFS를 쓰긴 하는데 각각의 재료를 포함했을때와 포함하지 않았을때를 반드시 같이 돌려야 한다는것.&lt;/p&gt;

&lt;p&gt;제약조건에 따라 포함하거나 포함안하거나 따지면서 DFS 두번 돌리면 바로 풀린다.&lt;/p&gt;

&lt;p&gt;아직도 정말 갈길이 멀다고 생각했다.&lt;/p&gt;

&lt;p&gt;DFS, BFS는 자신있다고 생각했는데… 심지어 DFS로 풀어야된다는걸 알면서도 틀려서 더 자괴감 오진다.&lt;/p&gt;

&lt;h1 id=&quot;될때까지-하자&quot;&gt;될때까지 하자.&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;정답-코드&quot;&gt;정답 코드&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by Keith_Lee on 07/01/2019.
//

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int T;
int N, L;
int maximum = 0;

vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; base;

void DFS(int start, int calory, int score){
    if(start == N){
        maximum = maximum &amp;gt; score ? maximum : score;
        return;
    }
    if(calory + base[start].second &amp;lt;= L){
        DFS(start+1, calory+base[start].second, score+base[start].first); // start번째 재료 추가
    }
    DFS(start+1, calory, score); // start번째 재료 거름
}

int main(){
    cin &amp;gt;&amp;gt; T;

    for(int test=1; test&amp;lt;=T; test++){
        cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; L;

        for(int i=0; i&amp;lt;N; i++){
            int calory;
            int score;

            cin &amp;gt;&amp;gt; score &amp;gt;&amp;gt; calory;

            base.push_back(make_pair(score, calory));
        }

        DFS(0, 0, 0);

        cout &amp;lt;&amp;lt; '#' &amp;lt;&amp;lt; test &amp;lt;&amp;lt; ' ' &amp;lt;&amp;lt; maximum &amp;lt;&amp;lt; '\n';
        while(!base.empty()){
            base.pop_back();
        }
        maximum = 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;</content><author><name>Jaehyun Keith Lee</name><email>wogus4187@naver.com</email></author><category term="DFS" /><summary type="html">SWEA 5215번 Link: 5215번: 햄버거 다이어트</summary></entry></feed>